!-------------------------------------------------------------------------------
!
! RMS2_INDICES
!
! This object is used to store precalculated information pertaining to the
! reduced multiplication scheme (RMS) used in electron repulsion integral 
! evaluation, for shell quartets. The module RMS_INDICES produces the same
! information but for shell pairs.
!
! Copyright (C) Dylan Jayatilaka, 2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module RMS2_INDICES

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object. This version does not set defaults.
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end
 
   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of self
      self :: INOUT

!     nullify(.e)
!     nullify(.f)
!     nullify(.ex)
!     nullify(.ey)
!     nullify(.ez)
!     nullify(.fx)
!     nullify(.fy)
!     nullify(.fz)
!     nullify(.Ixy_is_1)
!     nullify(.Ixy_is_x)
!     nullify(.Ixy_is_y)
!     nullify(.Ixy_is_p)
      nullify(.ef)
      nullify(.efx)
      nullify(.efy)
      nullify(.efz)
      nullify(.do_Ixy_is_x)
      nullify(.do_Ixy_is_y)
      nullify(.do_Ixy)

   end
 
   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

!     .e.destroy
!     .f.destroy
!     .ex.destroy
!     .ey.destroy
!     .ez.destroy
!     .fx.destroy
!     .fy.destroy
!     .fz.destroy
!     .Ixy_is_1.destroy
!     .Ixy_is_x.destroy
!     .Ixy_is_y.destroy
!     .Ixy_is_p.destroy
      .ef.destroy
      .efx.destroy
      .efy.destroy
      .efz.destroy
      .do_Ixy_is_x.destroy
      .do_Ixy_is_y.destroy
      .do_Ixy.destroy

   end

!  ===========
!  Set methods
!  ===========

   set_indices(er,fr,ex,ey,ez,fx,fy,fz,ab_l_sum) ::: leaky
   ! Form the RMS pair indices, which tells when to multiply Ix and Iy,
   ! thus saving work. This version takes care of cases when Ix and Iy
   ! are equal to 1.
      er,fr :: RMS_INDICES, IN
      ex,ey,ez,fx,fy,fz :: VEC{INT}, IN
      ab_l_sum :: INT, IN

      Ixy_is_1,Ixy_is_x,Ixy_is_y,Ixy_is_p :: MAT{INT}@
      n,m,ne,nf,ab,i,k,k1,kx,ky,aa,nn,an,na :: INT
      e,f,ze,ye,xe,zf,yf,xf,fs,es,fm,em :: INT
      xe1,ye1,xf1,yf1,x1,y1,xy1 :: BIN

      ne = ex.dim
      nf = fx.dim
      n  = ne*nf
      ab = ab_l_sum + 1

      .ef.create(n)
      .efx.create(n)
      .efy.create(n)
      .efz.create(n)
      .do_Ixy_is_x.create(n); .do_Ixy_is_x = FALSE
      .do_Ixy_is_y.create(n); .do_Ixy_is_y = FALSE
      .do_Ixy.create(n);      .do_Ixy      = FALSE


      Ixy_is_p.create(n,2)

      m = fr.xy_rms_a.dim*er.xy_rms_a.dim
      Ixy_is_y.create(m,2)
      Ixy_is_x.create(m,2)
      Ixy_is_1.create(m,2)

      k1 = 0; kx = 0; ky = 0
      aa = 0
      do fs = 1,fr.xy_rms_a.dim                       ! Apply (f) RMS here
        f = fr.a0(fr.xy_rms_a(fs).element(1))
        xf  = fx(f); yf = fy(f)
        xf1 = xf==1; yf1 = yf==1
        do es = 1,er.xy_rms_a.dim                     ! Apply (e) RMS here
           e = er.a0(er.xy_rms_a(es).element(1))
           xe  = ex(e); ye  = ey(e)
           xe1 = xe==1; ye1 = ye==1                   ! Eliminate unity factors
           x1 = xf1 AND xe1
           y1 = yf1 AND ye1
           xy1  = x1 AND y1
           if      (xy1) then
              k1 = k1 + 1
              Ixy_is_1(k1,1) = es
              Ixy_is_1(k1,2) = fs
           else if ( x1) then
              ky = ky + 1
              Ixy_is_y(ky,1) = es
              Ixy_is_y(ky,2) = fs
           else if ( y1) then
              kx = kx + 1
              Ixy_is_x(kx,1) = es
              Ixy_is_x(kx,2) = fs
           else
              aa = aa + 1
              Ixy_is_p(aa,1) = es
              Ixy_is_p(aa,2) = fs
           end
        end
      end

      nn = aa
      do fs = 1,fr.xy_rms_n.dim                            ! Apply (f) RMS here
        f = fr.n0(fr.xy_rms_n(fs).element(1))
        do es = 1,er.xy_rms_n.dim                         ! Apply (e) RMS here
           e = er.n0(er.xy_rms_n(es).element(1))
           nn = nn + 1
           Ixy_is_p(nn,1) = es
           Ixy_is_p(nn,2) = fs
        end
      end

      an = nn
      do fs = 1,fr.xy_rms_a.dim                            ! Apply (f) RMS here
        f = fr.a0(fr.xy_rms_a(fs).element(1))
        do es = 1,er.xy_rms_n.dim                         ! Apply (e) RMS here
           e = er.n0(er.xy_rms_n(es).element(1))
           an = an + 1
           Ixy_is_p(an,1) = es
           Ixy_is_p(an,2) = fs
        end
      end

      na = an
      do fs = 1,fr.xy_rms_n.dim                            ! Apply (f) RMS here
        f = fr.n0(fr.xy_rms_n(fs).element(1))
        do es = 1,er.xy_rms_a.dim                         ! Apply (e) RMS here
           e = er.a0(er.xy_rms_a(es).element(1))
           na = na + 1
           Ixy_is_p(na,1) = es
           Ixy_is_p(na,2) = fs
        end
      end

      ! Now order the indices over "i"  for efficiency
      i = 0

      do k = 1,k1
        es = Ixy_is_1(k,1)
        fs = Ixy_is_1(k,2)
        do fm = 1,fr.xy_rms_a(fs).element.dim
           f = fr.a0(fr.xy_rms_a(fs).element(fm))
           xf = fx(f); yf = fy(f); zf = fz(f)
           do em = 1,er.xy_rms_a(es).element.dim
              e = er.a0(er.xy_rms_a(es).element(em))
              xe = ex(e); ye = ey(e); ze = ez(e)
              i = i + 1
              .ef(i)  = e  + ne*(f -1)
              .efx(i) = xe + ab*(xf-1)
              .efy(i) = ye + ab*(yf-1)
              .efz(i) = ze + ab*(zf-1)
           end
        end
      end
      .no_Ixy_is_1 = i
      Ixy_is_1.destroy
  
      do k = 1,kx
        es = Ixy_is_x(k,1)
        fs = Ixy_is_x(k,2)
        .do_Ixy_is_x(i+1) = TRUE
        do fm = 1,fr.xy_rms_a(fs).element.dim
           f = fr.a0(fr.xy_rms_a(fs).element(fm))
           xf = fx(f); yf = fy(f); zf = fz(f)
           do em = 1,er.xy_rms_a(es).element.dim
              e = er.a0(er.xy_rms_a(es).element(em))
              xe = ex(e); ye = ey(e); ze = ez(e)
              i = i + 1
              .ef(i)  = e  + ne*(f -1)
              .efx(i) = xe + ab*(xf-1)
              .efy(i) = ye + ab*(yf-1)
              .efz(i) = ze + ab*(zf-1)
           end
        end
      end
      .no_Ixy_is_x = i
      Ixy_is_x.destroy

      do k = 1,ky
        es = Ixy_is_y(k,1)
        fs = Ixy_is_y(k,2)
        .do_Ixy_is_y(i+1) = TRUE
        do fm = 1,fr.xy_rms_a(fs).element.dim
           f = fr.a0(fr.xy_rms_a(fs).element(fm))
           xf = fx(f); yf = fy(f); zf = fz(f)
           do em = 1,er.xy_rms_a(es).element.dim
              e = er.a0(er.xy_rms_a(es).element(em))
              xe = ex(e); ye = ey(e); ze = ez(e)
              i = i + 1
              .ef(i)  = e  + ne*(f -1)
              .efx(i) = xe + ab*(xf-1)
              .efy(i) = ye + ab*(yf-1)
              .efz(i) = ze + ab*(zf-1)
           end
        end
      end
      .no_Ixy_is_y = i
      Ixy_is_y.destroy

      ! Ixy = Ix*Iy ...
      do k = 1,aa
        es = Ixy_is_p(k,1)
        fs = Ixy_is_p(k,2)
        .do_Ixy(i+1) = TRUE
        do fm = 1,fr.xy_rms_a(fs).element.dim
           f = fr.a0(fr.xy_rms_a(fs).element(fm))
           xf = fx(f); yf = fy(f); zf = fz(f)
           do em = 1,er.xy_rms_a(es).element.dim
              e = er.a0(er.xy_rms_a(es).element(em))
              xe = ex(e); ye = ey(e); ze = ez(e)
              i = i + 1
              .ef(i)  = e  + ne*(f -1)
              .efx(i) = xe + ab*(xf-1)
              .efy(i) = ye + ab*(yf-1)
              .efz(i) = ze + ab*(zf-1)
           end
        end
      end

      do k = aa+1,nn
        es = Ixy_is_p(k,1)
        fs = Ixy_is_p(k,2)
        .do_Ixy(i+1) = TRUE
        do fm = 1,fr.xy_rms_n(fs).element.dim
           f = fr.n0(fr.xy_rms_n(fs).element(fm))
           xf = fx(f); yf = fy(f); zf = fz(f)
           do em = 1,er.xy_rms_n(es).element.dim
              e = er.n0(er.xy_rms_n(es).element(em))
              xe = ex(e); ye = ey(e); ze = ez(e)
              i = i + 1
              .ef(i)  = e  + ne*(f -1)
              .efx(i) = xe + ab*(xf-1)
              .efy(i) = ye + ab*(yf-1)
              .efz(i) = ze + ab*(zf-1)
           end
        end
      end

      do k = nn+1,an
        es = Ixy_is_p(k,1)
        fs = Ixy_is_p(k,2)
        .do_Ixy(i+1) = TRUE
        do fm = 1,fr.xy_rms_a(fs).element.dim
           f = fr.a0(fr.xy_rms_a(fs).element(fm))
           xf = fx(f); yf = fy(f); zf = fz(f)
           do em = 1,er.xy_rms_n(es).element.dim
              e = er.n0(er.xy_rms_n(es).element(em))
              xe = ex(e); ye = ey(e); ze = ez(e)
              i = i + 1
              .ef(i)  = e  + ne*(f -1)
              .efx(i) = xe + ab*(xf-1)
              .efy(i) = ye + ab*(yf-1)
              .efz(i) = ze + ab*(zf-1)
           end
        end
      end

      do k = an+1,na
        es = Ixy_is_p(k,1)
        fs = Ixy_is_p(k,2)
        .do_Ixy(i+1) = TRUE
        do fm = 1,fr.xy_rms_n(fs).element.dim
           f = fr.n0(fr.xy_rms_n(fs).element(fm))
           xf = fx(f); yf = fy(f); zf = fz(f)
           do em = 1,er.xy_rms_a(es).element.dim
              e = er.a0(er.xy_rms_a(es).element(em))
              xe = ex(e); ye = ey(e); ze = ez(e)
              i = i + 1
              .ef(i)  = e  + ne*(f -1)
              .efx(i) = xe + ab*(xf-1)
              .efy(i) = ye + ab*(yf-1)
              .efz(i) = ze + ab*(zf-1)
           end
        end
      end
      Ixy_is_p.destroy

      DIE_IF(i/=n,"inconsistent final index")

   end

end
