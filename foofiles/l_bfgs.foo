!---------------------------------------------------------------------------
!
! L_BFGS: Low memory BFGS minimiser routine.
!
! Copyright (C) Max Davidson, 2017
!
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

module L_BFGS

   implicit none

contains

! =================
! Memory allocation
! =================

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of self
      self :: INOUT

      nullify(.par)
      nullify(.grd)

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .par.destroy
      .grd.destroy

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky, PURE
   ! Set up the default settings
      self :: INOUT

      .iteration             = 0 
      .start_iteration       = DIIS_START_ITERATION
      .save_iteration        = DIIS_SAVE_ITERATION
      .keep                  = DIIS_KEEP

      .grd_norm              = 1000d0
      .convergence_tolerance = DIIS_CONVERGENCE_TOLERANCE
      .start_tolerance       = DIIS_START_TOLERANCE

      ! Clean up (leaky)
      .destroy_ptr_part

   end

   reset_iteration_defaults ::: leaky
   ! Reset defaults without changing user settings
      self :: INOUT

      .iteration  = -1 ! The first time called it is iteration 0

      ! Clean up old stuff (leaky)
      .destroy_ptr_part

   end

   set_convergence_tolerance(tolerance) ::: PURE
   ! Read the convergence tolerance
      self :: INOUT
      tolerance :: REAL, IN

   ENSURE(tolerance>ZERO,"must have positive convergence tolerance")
 ! WARN_IF(tolerance<TOL(6),"convergence tolerance may be too small")

      .convergence_tolerance = tolerance

   end

   set_start_tolerance(tolerance) ::: PURE
   ! Read the start tolerance when extrapolation is supposed to start
      self :: INOUT
      tolerance :: REAL, IN

   ENSURE(tolerance>ZERO,"must have positive start tolerance")
   ENSURE(tolerance>.convergence_tolerance,"start tolerance is <= convergence tolerance")
 ! WARN_IF(tolerance<TOL(6),"start tolerance may be too small")

      .start_tolerance = tolerance

   end

   set_keep(keep)
   ! Set the number of parameter/error vectors to keep 
      self :: INOUT
      keep :: INT, IN

   DIE_IF(keep<4,"no. to keep must be more than 4")

      .keep = keep

   end

   set_start_iteration(start) ::: pure
   ! Set at what iteration the procedure should start
      self :: INOUT
      start :: INT, IN

      .start_iteration = start

   end

   set_save_iteration(save_it) ::: pure
   ! Set at what iteration the procedure should start saving vectors
      self :: INOUT
      save_it :: INT, IN

      .save_iteration = save_it

   end

!  =================
!  Read the keywords
!  =================

   read_keywords ::: get_from(OBJECT)
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process a command "keyword". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("}                       ")  ! exit case
      case ("convergence_tolerance=  "); .read_convergence_tolerance
      case ("keep=                   "); .read_keep
      case ("save_iteration=         "); .read_save_iteration
      case ("start_iteration=        "); .read_start_iteration
      case ("start_tolerance=        "); .read_start_tolerance
      case default;           UNKNOWN(word)
      end

   end

   read_convergence_tolerance ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_convergence_tolerance)
   ! Generic read and set a quantity with units
   end

   read_start_tolerance ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_start_tolerance)
   ! Generic read and set a quantity with units
   end

   read_keep ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_keep)
   ! Generic read and set a quantity with units
   end

   read_start_iteration ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_start_iteration)
   ! Generic read and set a quantity with units
   end

   read_save_iteration ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_save_iteration)
   ! Generic read and set a quantity with units
   end

!  ======
!  L-BFGS
!  ======

   minimize_L_BFGS(func,grad,par,grd) ::: public
   ! Use the limited memory Broyden-Fletcher-Goldfarb-Shanno method to
   ! minimise the molecular orbitals with gradient function from
   ! Stoll(1980). This code is all per Nocedal & Wright
   ! NOTE: set saved_self before calling self & dself
      interface
         func(x,res)
            x :: VEC{REAL}, IN
            res :: REAL, OUT
         end
      end
      interface
         grad(x,res)
            x :: VEC{REAL}, IN
            res :: VEC{REAL}, OUT
         end
      end
      par :: VEC{REAL}, INOUT
      grd :: VEC{REAL}, INOUT
      
   ENSURE(par.dim1==grd.dim1,"inconsistent par and grd")

      j,n,m :: INT
      
      ! alpha, c1 and c2 are used in the line search algorithm and
      ! beta, gamma and rho are used in the Hessian approximation
      alpha,beta,gamma,rho,c1,c2 :: REAL
      
      ! a is used to store the various alpha values in the two loop
      ! recursion, p,q and r are used as generic vectors, and as part
      ! of the two loop recursion process
      a,q,s,y :: VEC{REAL}*
      
      .iteration = .iteration + 1
      n =  par.dim1
      m = .par.dim1 ! Note self

      ! Store the parameter & gradient
      ! NOTE: you should reset if you change
      ! any of the par vectors outside of here ...
      .par.append_fifo(par,.keep)
      .grd.append_fifo(grd,.keep)

      ! Gradient 
      q.create(n)
      call grad(par,q)

      ! Converged?
      .grd_norm = q.norm
      if(.is_converged) then
         ! Cleanup
         q.destroy
         return
      end if
   
      ! Workspace
      s.create(n)
      y.create(n)
      a.create(m)
      a = ZERO

      ! The values used for line search algorithms. These values are
      ! the ones which usually work.
      c1 = 10d-4
      c2 = 9d-1

      
      ! Initialises the values used in the two-loop recursion.
      rho = 1
      if (m>1) then   
         s = .par(m).element - .par(m-1).element
         y = .grd(m).element - .grd(m-1).element
         gamma = dot_product(s,y)/dot_product(y,y)
      else
         gamma = 1 
      end if
      
      ! Will cause the program to exit if a suitable step can not be
      ! determined 
      alpha = ZERO
      

      ! The two loop recursion process approximates the Hessian by
      ! using stored values of delta x and delta grad, as well as a
      ! pre-scaling, gamma, to allow for a stepping at alpha = 1, to
      ! be suitable 
         
      ! H^0 is approximated by I   
         
         if (m > 1) then
            do j = m,2,-1
               s = .par(j).element - .par(j-1).element
               y = .grd(j).element - .grd(j-1).element
               rho = 1/(dot_product(y,s))
               a(j) = rho*dot_product(s,q)
               q = q - a(j)*y
            end do
         end if

         q = gamma*q

         do j = 2,m
            s = .par(j).element - .par(j-1).element
            y = .grd(j).element - .grd(j-1).element
            rho = 1/dot_product(y,s)
            beta = rho*dot_product(y,q) 
            q = q + (a(j) - beta)*s
         end do

      ! This is the step toward the minimum
         q = -q

      ! Fines the ideal multiple of the step to take (usually 1)
      ! and stores that in alpha
      VEC{REAL}::line_search(func,grad,10d0,par,q,c1,c2,alpha)
         
      ! Performs the step (and stores the previous x value)
      par = par + alpha*q
         
      ! Cleanup
      q.destroy
      s.destroy
      y.destroy
      a.destroy     

   end

!   gradient(g,F,D,MO)
   ! Make the real gradient "g" of the *occupied* MO's,
   ! g = F MO S^{-1} - (1/2)S D F MO S^{-1}
!      self :: IN
!      g :: MAT{REAL}, OUT
!      F,D,MO :: MAT{REAL}, IN
!
!   ENSURE(g.is_same_shape_as(MO),"gradient g and MO are not the same shape")
!   ENSURE(F.is_square,"F is not square")
!   ENSURE(F.dim1==.n_bf,"F is not the right size, n_bf = "//trim(.n_bf.to_str))
!   ENSURE(D.is_same_shape_as(F),"D is not the right size")
!   ENSURE( .overlap_matrix.created,"NO overlap_matrix")

!      S_inv, FcSm1,cSm1 :: MAT{REAL}*

      ! Make S, S^{-1} in the MO basis
 !     S_inv.create(.n_a,.n_a)
 !     .BASE:make_ELMO_S_inv_r(S_inv,MO)

      ! Make gradient
  !    FcSm1.create(.n_bf,.n_a)
   !   cSm1.create(.n_bf,.n_a)
!      cSm1.to_product_of(MO,S_inv)
!      FcSm1.to_product_of(F,cSm1)
!      cSm1.destroy
!      cSm1.create(.n_bf,.n_bf)
!      cSm1.to_scaled_product_of(.overlap_matrix,D,fac=HALF)

      ! Assemble 1st and 2nd terms of gradient
!      g = FcSm1
!      g.plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)

      ! Clean up
!      cSm1.destroy
!      FcSm1.destroy
!      S_inv.destroy

!   end


!  =======
!  Queries
!  =======

   subspace_saturated result (res) ::: pure
   ! Return TRUE if the subspace is saturated; no more new
   ! vectors can be stored.
      self :: IN
      res :: BIN

      res = .par.dim == .keep

   end

   apply_l_bfgs result (res) ::: pure
   ! Return TRUE if extrapolation must be applied this iteration
      self :: IN
      res :: BIN

      res = .iteration - .start_iteration >= 0

   end

   saved_iteration result (res) ::: pure
   ! Return the actual iteration number since starting to save vectors
      self :: IN
      res :: INT

      res = .iteration - .save_iteration

   end

!  =============
!  Extrapolation
!  =============

   is_converged result (res) ::: PURE
   ! Return TRUE if the procedure is converged
      self :: IN
      res :: BIN

      res = .grd_norm<.convergence_tolerance

   end

!  ======
!  Output
!  ======

   put
   ! Print out info
      self :: IN

      stdout.flush
      stdout.text("L_BFGS options: ")
      stdout.flush
      stdout.set_real_style("e")
      stdout.show("Convergence on max(abs(error)) =",.convergence_tolerance)
      stdout.set_real_style("f")
      stdout.show("Extrapolate  from iteration    =",.start_iteration)
      stdout.show("Save vectors from iteration    =",.save_iteration)
      stdout.show("No. of vectors to keep         =",.keep)

   end

end
