!===============================================================================
!
! SHELL1QUARTET : Group of 4 SHELL1s, used for two-electron integrals.  This
! module is designed for speed, but still try to keep it readable.
!
! I improved the readability and added cleaner code which can always be used in
! the general case. In addition optimal code was generated by a program. Some use
! of assumed size arrays was done for efficiency. -- dylan
!
! Copyright (C) Daniel Grimwood, 2002
! Copyright (C) Dylan Jayatilaka, 2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: shell1quartet.foo 4035 2013-05-28 14:04:59Z dylan_ $

module SHELL1QUARTET

   implicit none

   ! List of cartesian powers for gaussian functions in a certain angular
   ! momentum range
!  nx, ny, nz :: VEC{INT}*, private  DEFAULT_NULL
!  gaussian_indices :: MAT{GAUSSIAN_INDICES}*, private  DEFAULT_NULL

   ! These are indexing arrays used for the horizontal recursion relation.
   ! They are set using the set_hrr_indexing_arrays routine.

!  l_max_hrr :: INT, private = -1
!  first_nonzero :: VEC{INT}*, private  DEFAULT_NULL
!  index_m1 :: VEC{INT}*, private  DEFAULT_NULL
!  index_p1 :: MAT{INT}*, private  DEFAULT_NULL

   ! The minimum number of contractions of the ab shellpair for which to
   ! precalculate the cd shellpair data.

!  n_contraction_cutoff :: INT = 0

   ! The minimum value of l angular momentum for a shellpair to perform the
   ! reduced multiplication scheme.

!  ERI_rms_min_l :: INT = 4

   ! When a factor controlling the size of a primitive pair integral is smaller
   ! than this cutoff, its contribution to the ERI is ignored.

   pair_cutoff :: REAL, private = SHELL1QUARTET_ERI_PAIR_CUTOFF

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of self
      self :: INOUT

      .a.nullify_ptr_part
      .b.nullify_ptr_part
      .c.nullify_ptr_part
      .d.nullify_ptr_part

      nullify(.ab_exponent_sum)
      nullify(.ab_exponent_inv)
      nullify(.ab_contraction_prefactor)
      nullify(.ab_contraction_s_prefactor)
      nullify(.ab_contraction_p_prefactor)
      nullify(.ab_pair_center)
      nullify(.ab_center_diff)
      nullify(.cd_exponent_sum)
      nullify(.cd_exponent_inv)
      nullify(.cd_contraction_prefactor)
      nullify(.cd_contraction_s_prefactor)
      nullify(.cd_contraction_p_prefactor)
      nullify(.cd_pair_center)
      nullify(.cd_center_diff)

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .destroy_ab
      .destroy_cd

   end

   destroy_ab ::: leaky, PURE
   ! Destroy the shella and shellb pointer parts of self
      self :: INOUT

      .a.nullify_ptr_part
      .b.nullify_ptr_part

      if (.ab_nullify) then

         nullify(.ab_exponent_sum)
         nullify(.ab_exponent_inv)
         if (.ab_same_center) then
            nullify(.ab_contraction_prefactor)
            nullify(.ab_contraction_s_prefactor)
            nullify(.ab_contraction_p_prefactor)
         else
            .ab_contraction_prefactor.destroy
            .ab_contraction_s_prefactor.destroy
            .ab_contraction_p_prefactor.destroy
         end
   !     nullify(.ab_form_3dints_yz_rms_indices)

      else

         .ab_exponent_sum.destroy
         .ab_exponent_inv.destroy
         .ab_contraction_prefactor.destroy
         .ab_contraction_s_prefactor.destroy
         .ab_contraction_p_prefactor.destroy
   !     .ab_form_3dints_yz_rms_indices.destroy

      end

      .ab_pair_center.destroy
      .ab_center_diff.destroy

   end

   destroy_cd ::: leaky, PURE
   ! Destroy the shellc and shelld pointer parts of self
      self :: INOUT

      .c.nullify_ptr_part
      .d.nullify_ptr_part

      if (.cd_nullify) then
       nullify(.cd_exponent_sum)
       nullify(.cd_exponent_inv)
       if (.cd_same_center) then
          nullify(.cd_contraction_prefactor)
          nullify(.cd_contraction_s_prefactor)
          nullify(.cd_contraction_p_prefactor)
       else
          .cd_contraction_prefactor.destroy
          .cd_contraction_s_prefactor.destroy
          .cd_contraction_p_prefactor.destroy
       end
   !   nullify(.cd_form_3dints_yz_rms_indices)

      else

       .cd_exponent_sum.destroy
       .cd_exponent_inv.destroy
       .cd_contraction_prefactor.destroy
       .cd_contraction_s_prefactor.destroy
       .cd_contraction_p_prefactor.destroy
   !   .cd_form_3dints_yz_rms_indices.destroy

      end

      .cd_pair_center.destroy
      .cd_center_diff.destroy

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: PURE
   ! Set defaults
      self :: INOUT

      .is_spherical = FALSE
      .ab_nullify  = TRUE
      .cd_nullify  = TRUE

   end

   set_spherical(val) ::: PURE
   ! Set sphericals to "val" defaults
      self :: INOUT
      val :: BIN, IN

      .is_spherical = val

   end

!  ======================
!  Miscellaneous Routines
!  ======================

   unnormalise ::: pure
   ! Unnormalise each shell in this shell quartet
      self :: INOUT

      .a.unnormalise
      .b.unnormalise
      .c.unnormalise
      .d.unnormalise

   end

!  ===================
!  Precalculated stuff
!  ===================

   set_pair_cutoff(cutoff)
   ! Set the "cutoff" for the exponential prefactor for the product of two
   ! gaussian primitives, below which that primitive pair is is ignored in
   ! the calculation of the ERI's.
      cutoff :: REAL, IN

   ENSURE(cutoff>ZERO,"cutoff must be pisitive")

      if (FALSE) self = self
      pair_cutoff = cutoff

   end

   set_ab_new(shellpr,pos_a,pos_b,same_center,skip) ::: leaky
   ! Set the a and b parts from "shellpr" but override the positions.
   ! "same_center" should be set TRUE if pos_a==pos_b.
   ! "skip" can be set TRUE if NOT same_center; it skips gaussian product
   ! pairs which are too small to worry about.
   ! NOTE: this does not create many pointer parts
      shellpr :: SHELL1PAIR, IN, target
      pos_a,pos_b :: VEC{REAL}, IN
      same_center,skip :: BIN, IN

      exponent_sum,exponent_inv :: VEC{REAL}*
      AB,At,P,PAt,b_pos_b :: VEC{REAL}(3)
      a,b,r2ab,b_r2ab,ab_inv,prefac :: REAL
      i,j,bg,ag :: INT

      .is_spherical = shellpr.a.is_spherical ! b must be the same

      .a = shellpr.a
      .b = shellpr.b
      .a.position = pos_a
      .b.position = pos_b
      .ab_same_center = same_center
      .ab_l_max = shellpr.l_max
      .ab_l_min = shellpr.l_min
      .ab_l_sum = shellpr.l_sum
      .ab_l_tri = .ab_l_max*(.ab_l_max+1)/2 + .ab_l_min + 1
      .ab_n_gaussian_pairs = shellpr.n_gaussian_pairs
      .ab_n_comp_pairs   = shellpr.n_comp_pairs
      .ab_n_sph_pairs   = shellpr.n_sph_pairs
      .ab_n_bf_pairs   = shellpr.n_bf_pairs
      .ab_first_gaussian = shellpr.first_gaussian
      .ab_last_gaussian  = shellpr.last_gaussian
      .n_ab = shellpr.n_gaussian

      .ab_pair_center.create(3,.ab_n_gaussian_pairs)
      .ab_center_diff.create(3,.ab_n_gaussian_pairs)

      if (NOT skip) then
        .ab_nullify = TRUE
        .ab_exponent_sum => shellpr.exponent_sum
        .ab_exponent_inv => shellpr.exponent_inv
        if (same_center) then
           .ab_contraction_prefactor => shellpr.contraction_prefactor
           .r2ab = ZERO
           i = 0
           do bg = 1,.b.n_cc
              do ag = 1,.a.n_cc
                 i = i + 1
               ! prefac = shellpr.contraction_prefactor(i)
               ! .ab_contraction_prefactor(i) = prefac
                 .ab_pair_center(1,i) = pos_a(1)
                 .ab_pair_center(2,i) = pos_a(2)
                 .ab_pair_center(3,i) = pos_a(3)
                 .ab_center_diff(1,i) = ZERO
                 .ab_center_diff(2,i) = ZERO
                 .ab_center_diff(3,i) = ZERO
              end
           end
        else
           .ab_contraction_prefactor.create(.ab_n_gaussian_pairs)
           ! Want position of shell1 with higher angular momentum.
           if (.a.l > .b.l) then; At = pos_a
           else;                  At = pos_b
           end
           AB = pos_a-pos_b
           r2ab = dot_product(AB,AB)
           .r2ab = r2ab
           i = 0
           do bg = 1,.b.n_cc
              b = .b.exponent(bg)
              b_pos_b = b*pos_b
              b_r2ab = b*r2ab
              do ag = 1,.a.n_cc
                 i = i + 1
                 a = .a.exponent(ag)
                 ab_inv = .ab_exponent_inv(i)
                 prefac = shellpr.contraction_prefactor(i)*exp(-a*b_r2ab*ab_inv)
                 .ab_contraction_prefactor(i) = prefac
                 P = (b_pos_b + a*pos_a) * ab_inv ! This can't be precalculated
                 PAt = P - At                     ! it could be compressed, below
                 .ab_pair_center(1,i) = P(1)
                 .ab_pair_center(2,i) = P(2)
                 .ab_pair_center(3,i) = P(3)
                 .ab_center_diff(1,i) = PAt(1)
                 .ab_center_diff(2,i) = PAt(2)
                 .ab_center_diff(3,i) = PAt(3)
              end
           end
        end
      else
        .ab_contraction_prefactor.create(.ab_n_gaussian_pairs)
        ! When skipping, centers must not be the same ....
        ! Want position of shell1 with higher angular momentum.
        if (.a.l > .b.l) then; At = pos_a
        else;                  At = pos_b
        end
        AB = pos_a-pos_b
        r2ab = dot_product(AB,AB)
        .r2ab = r2ab
        .ab_nullify = FALSE
        .ab_exponent_sum.create(.ab_n_gaussian_pairs)
        .ab_exponent_inv.create(.ab_n_gaussian_pairs)
        exponent_sum => shellpr.exponent_sum
        exponent_inv => shellpr.exponent_inv
        i = 0
        j = 0
        do bg = 1,.b.n_cc
           b = .b.exponent(bg)
           b_pos_b = b*pos_b
           b_r2ab = b*r2ab
           do ag = 1,.a.n_cc
              i = i + 1
              a = .a.exponent(ag)
              ab_inv = exponent_inv(i)
              prefac = exp(-a*b_r2ab*ab_inv)
              if (prefac<pair_cutoff) cycle  ! <<<<<<<<<<<<<
              j = j + 1
              .ab_exponent_sum(j) = exponent_sum(i)
              .ab_exponent_inv(j) = ab_inv
              .ab_contraction_prefactor(j) = prefac*shellpr.contraction_prefactor(i)
              P = (b_pos_b + a*pos_a) * ab_inv
              PAt = P - At
              .ab_pair_center(1,j) = P(1)
              .ab_pair_center(2,j) = P(2)
              .ab_pair_center(3,j) = P(3)
              .ab_center_diff(1,j) = PAt(1)
              .ab_center_diff(2,j) = PAt(2)
              .ab_center_diff(3,j) = PAt(3)
           end
        end
        .ab_n_gaussian_pairs = j
      end
   end

   set_cd_new(shellpr,pos_c,pos_d,same_center,skip) ::: leaky
   ! Set the c and d parts from "shellpr" but override the positions.
   ! "same_center" should be set TRUE if pos_a==pos_b.
   ! "skip" can be set TRUE if NOT same_center; it skips gaussian product
   ! pairs which are too small to worry about.
   ! NOTE: this does not create many pointer parts
      shellpr :: SHELL1PAIR, IN, target
      pos_c,pos_d :: VEC{REAL}, IN
      same_center,skip :: BIN, IN
      exponent_sum,exponent_inv :: VEC{REAL}*
      CD,Ct,Q,QCt,d_pos_d :: VEC{REAL}(3)
      c,d,r2cd,d_r2cd,cd_inv,prefac :: REAL
      i,j,dg,cg :: INT

      .is_spherical = shellpr.a.is_spherical ! d must be the same

      .c = shellpr.a
      .d = shellpr.b
      .c.position = pos_c
      .d.position = pos_d

      .cd_same_center = same_center
      .cd_l_max = shellpr.l_max
      .cd_l_min = shellpr.l_min
      .cd_l_sum = shellpr.l_sum
      .cd_l_tri = .cd_l_max*(.cd_l_max+1)/2 + .cd_l_min + 1
      .cd_n_gaussian_pairs = shellpr.n_gaussian_pairs
      .cd_n_comp_pairs   = shellpr.n_comp_pairs
      .cd_n_sph_pairs   = shellpr.n_sph_pairs
      .cd_n_bf_pairs   = shellpr.n_bf_pairs
      .cd_first_gaussian = shellpr.first_gaussian
      .cd_last_gaussian  = shellpr.last_gaussian
      .n_cd = shellpr.n_gaussian

      .cd_pair_center.create(3,.cd_n_gaussian_pairs)
      .cd_center_diff.create(3,.cd_n_gaussian_pairs)

      if (NOT skip) then

        .cd_nullify = TRUE
        .cd_exponent_sum => shellpr.exponent_sum
        .cd_exponent_inv => shellpr.exponent_inv

        if (same_center) then
           .cd_contraction_prefactor => shellpr.contraction_prefactor
           .r2cd = ZERO
           i = 0
           do dg = 1,.d.n_cc
              do cg = 1,.c.n_cc
                 i = i + 1
               ! prefac = shellpr.contraction_prefactor(i)
               ! .cd_contraction_prefactor(i) = prefac
                 .cd_pair_center(1,i) = pos_c(1)
                 .cd_pair_center(2,i) = pos_c(2)
                 .cd_pair_center(3,i) = pos_c(3)
                 .cd_center_diff(1,i) = ZERO
                 .cd_center_diff(2,i) = ZERO
                 .cd_center_diff(3,i) = ZERO
              end
           end

        else

           .cd_contraction_prefactor.create(.cd_n_gaussian_pairs)
           ! Want position of shell1 with higher angular momentum.
           if (.c.l > .d.l) then; Ct = pos_c
           else;                  Ct = pos_d
           end
           CD = pos_c-pos_d
           r2cd = dot_product(CD,CD)
           .r2cd = r2cd
           i = 0
           do dg = 1,.d.n_cc
              d = .d.exponent(dg)
              d_pos_d = d*pos_d
              d_r2cd = d*r2cd
              do cg = 1,.c.n_cc
                 i = i + 1
                 c = .c.exponent(cg)
                 cd_inv  = .cd_exponent_inv(i)
                 prefac = shellpr.contraction_prefactor(i)*exp(-c*d_r2cd*cd_inv)
                 .cd_contraction_prefactor(i) = prefac
                 Q = (d_pos_d + c*pos_c) * cd_inv
                 QCt = Q - Ct
                 .cd_pair_center(1,i) = Q(1)
                 .cd_pair_center(2,i) = Q(2)
                 .cd_pair_center(3,i) = Q(3)
                 .cd_center_diff(1,i) = QCt(1)
                 .cd_center_diff(2,i) = QCt(2)
                 .cd_center_diff(3,i) = QCt(3)
              end
           end

        end

      else

        .cd_contraction_prefactor.create(.cd_n_gaussian_pairs)
        ! When skipping, centers must not be the same ....
        ! Want position of shell1 with higher angular momentum.
        if (.c.l > .d.l) then; Ct = pos_c
        else;                  Ct = pos_d
        end
        CD = pos_c-pos_d
        r2cd = dot_product(CD,CD)
        .r2cd = r2cd
        .cd_nullify = FALSE
        .cd_exponent_sum.create(.cd_n_gaussian_pairs)
        .cd_exponent_inv.create(.cd_n_gaussian_pairs)
        exponent_sum => shellpr.exponent_sum
        exponent_inv => shellpr.exponent_inv
        i = 0
        j = 0
        do dg = 1,.d.n_cc
           d = .d.exponent(dg)
           d_pos_d = d*pos_d
           d_r2cd = d*r2cd
           do cg = 1,.c.n_cc
              i = i + 1
              c = .c.exponent(cg)
              cd_inv  = exponent_inv(i)
              prefac = exp(-c*d_r2cd*cd_inv)
              if (prefac<pair_cutoff) cycle
              j = j + 1
              .cd_exponent_sum(j) = exponent_sum(i)
              .cd_exponent_inv(j) = cd_inv
              .cd_contraction_prefactor(j) = prefac*shellpr.contraction_prefactor(i)
              Q = (d_pos_d + c*pos_c) * cd_inv
              QCt = Q - Ct
              .cd_pair_center(1,j) = Q(1)
              .cd_pair_center(2,j) = Q(2)
              .cd_pair_center(3,j) = Q(3)
              .cd_center_diff(1,j) = QCt(1)
              .cd_center_diff(2,j) = QCt(2)
              .cd_center_diff(3,j) = QCt(3)
           end
        end

        .cd_n_gaussian_pairs = j

      end

   end

!  ===========
!  ERI cutoffs
!  ===========

! What is this routine below doing? hasn't it been subsumed into the type? -- dylan

!   cd_kappa_max result (res) ::: pure
!   ! Return the largest kappa_cd used in the Lindh integrals.
!     self :: IN
!     res :: REAL
!     CD :: VEC{REAL}(3)
!     d,d_cc,c,cd_inv,prefac,r2_cd :: REAL
!     dg,cg :: INT
!     CD = .d.position - .c.position
!     r2_cd = dot_product(CD,CD)
!     res = ZERO
!     do dg = 1,.d.n_cc
!       d      = .d.exponent(dg)
!       d_cc   = .d.contraction(dg)
!       do cg = 1,.c.n_cc
!         c = .c.exponent(cg)
!         cd_inv = ONE/(c+d)
!         prefac = d_cc*.c.contraction(cg) * cd_inv * sqrt(cd_inv) * exp(-c*d*r2_cd*cd_inv)
!         res = max(res,prefac/(sqrt(cd_inv)*cd_inv))
!       end
!     end
!   end

!   skip_ERI result (res) ::: pure
!   ! Whether the ERI block will be less than a cutoff value.
!     self :: IN
!     res :: BIN
!     res = (.ab_kappa_max*.cd_kappa_max < SHELL4_ERI_CUTOFF)
!   end

!   skip_ERI(cutoff) result (res) ::: pure
!   ! Whether the ERI block will be less than a cutoff value.
!     self :: IN
!     cutoff :: REAL, IN
!     res :: BIN
!     res = (.ab_kappa_max*.cd_kappa_max < cutoff)
!   end

!===============================================================================
!                   Roland Lindh-style integrals
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 1991, 5889-5897.
!
! See also:
! Obara and Saika, J. Chem. Phys. 84(7), 1986, 3963-3974.
! Head-Gordon and Pople, J. Chem. Phys. 89(9), 1988, 5777-5786.
!
!===============================================================================

   make_ERI(abcd) ::: public
   ! Makes the (ab|cd) integrals, summed over the primitives
   ! (uses the transfer equation to make (ab|cd) from (es|fs))
   ! ENSURE(.is_spherical,"wrong ERI routine call, sph vs cart violation")
      self :: IN
      abcd :: VEC{REAL}(*), OUT

      W :: MAT4{REAL}*

      if (NOT .is_spherical) then

         SHELL1QUARTET::make_ERI_c(self,abcd)

      elseif (max(.ab_l_max,.cd_l_max)<2) then

         SHELL1QUARTET::make_ERI_c(self,abcd)

      else

         W.create(.a.n_comp,.b.n_comp,.c.n_comp,.d.n_comp)
         SHELL1QUARTET::make_ERI_c(self,W)
         SHELL1QUARTET::change_to_spherical(self,W,abcd)

      end

   end

   make_ERI_c(abcd)
   ! Makes the (ab|cd) integrals, summed over the primitives
   ! (uses the transfer equation to make (ab|cd) from (es|fs))
      self :: IN
      abcd :: VEC{REAL}(*), OUT
 ! ENSURE(.n_ab==(.ab_last_gaussian-.ab_first_gaussian+1),"n_ab wrong")
 ! ENSURE(.n_cd==(.cd_last_gaussian-.cd_first_gaussian+1),"n_cd wrong")

      esfs,escd :: VEC{REAL}*
      ssss :: REAL

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then

        .make_esfs_ss_0000(ssss)
        abcd(1) = ssss

      else if (.ab_l_sum==0) then

        esfs.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        SHELL1QUARTET::transfer_cd_s(self,esfs,abcd)   ! Transfer, ab = ss
        esfs.destroy

      else if (.cd_l_sum==0) then

        esfs.create(.n_ab)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        SHELL1QUARTET::transfer_ab_s(self,esfs,abcd)   ! Transfer, cd = ss
        esfs.destroy

      else

        esfs.create(.n_ab*.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        escd.create(.n_ab*.c.n_comp*.d.n_comp)
        SHELL1QUARTET::transfer_cd(self,esfs,escd)     ! Transfer relations
        SHELL1QUARTET::transfer_ab(self,escd,abcd)
        escd.destroy
        esfs.destroy

      end

   end

   change_to_spherical(C,S) ::: leaky
   ! Normalise a cartesian integral block "C" to a spherical integral
   ! block "S" . "C" is destroyed.
      self :: IN
      C :: MAT4{REAL}*
      S :: MAT4{REAL}(.a.n_sph,.b.n_sph,.c.n_sph,.d.n_sph), OUT

      UU  :: VEC{MAT_{REAL}}*
      U :: MAT{REAL}*
      W,WW :: MAT4{REAL}*

      UU => GAUSSIAN_DATA::spherical_harmonics_for

      if (max(.ab_l_max,.cd_l_max)<2) then

         S = C             ! don't use this case
         C.destroy

      else

         W => C

         if (.a.l>=2) then
            U => UU(.a.l).element
            WW.create(.a.n_sph,.b.n_comp,.c.n_comp,.d.n_comp)
            W.change_index_1_to(WW,U)
            W.destroy
            W => WW
         end

         if (.b.l>=2) then
            U => UU(.b.l).element
            WW.create(.a.n_sph,.b.n_sph,.c.n_comp,.d.n_comp)
            W.change_index_2_to(WW,U)
            W.destroy
            W => WW
         end

         if (.c.l>=2) then
            U => UU(.c.l).element
            WW.create(.a.n_sph,.b.n_sph,.c.n_sph,.d.n_comp)
            W.change_index_3_to(WW,U)
            W.destroy
            W => WW
         end

         if (.d.l>=2) then
            U => UU(.d.l).element
            WW.create(.a.n_sph,.b.n_sph,.c.n_sph,.d.n_sph)
            W.change_index_4_to(WW,U)
            W.destroy
            W => WW
         end

         S = W

         WW.destroy

      end

   end

! This is a general purpose routine which always works
! but it calls special case code

   make_esfs(esfs)
   ! Makes the (es|fs) integrals, summed over primitives.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd)

      l_max :: INT
      l_max = max(.ab_l_sum,.cd_l_sum)
    ! if (GAUSSIAN_DATA::Ishida_ordering) then
    !    SHELL1QUARTET::make_esfs_general(self,esfs)
    !    return
    ! end
      select case (l_max)
        case (0)
                                                            SHELL1QUARTET::make_esfs_ss_ssss(self,esfs)
        case (1)
           if      (.ab_l_sum==1 AND .cd_l_sum==0) then;    SHELL1QUARTET::make_esfs_ps_psss(self,esfs)
           else if (.ab_l_sum==0 AND .cd_l_sum==1) then;    SHELL1QUARTET::make_esfs_sp_ssps(self,esfs)
           else if (.ab_l_sum==1 AND .cd_l_sum==1) then;    SHELL1QUARTET::make_esfs_pp_psps(self,esfs)
           end
        case (2)
           if      (.ab_l_sum==2 AND .cd_l_sum==0) then ! ; SHELL1QUARTET::make_esfs_ds(self,esfs)
              if   (.ab_l_min==0) then;                     SHELL1QUARTET::make_esfs_ds_dsss(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_ds_ppss(self,esfs)
              end
           else if (.ab_l_sum==0 AND .cd_l_sum==2) then ! ; SHELL1QUARTET::make_esfs_sd(self,esfs)
              if   (.cd_l_min==0) then;                     SHELL1QUARTET::make_esfs_sd_ssds(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_sd_sspp(self,esfs)
              end
           else if (.ab_l_sum==2 AND .cd_l_sum==1) then ! ; SHELL1QUARTET::make_esfs_dp(self,esfs)
              if   (.ab_l_min==0) then;                     SHELL1QUARTET::make_esfs_dp_dsps(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_dp_ppps(self,esfs)
              end
           else if (.ab_l_sum==1 AND .cd_l_sum==2) then ! ; SHELL1QUARTET::make_esfs_pd(self,esfs)
              if   (.cd_l_min==0) then;                     SHELL1QUARTET::make_esfs_pd_psds(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_pd_pspp(self,esfs)
              end
           else if (.ab_l_sum==2 AND .cd_l_sum==2) then ! ; SHELL1QUARTET::make_esfs_dd(self,esfs)
              if      (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_dd_dsds(self,esfs)
              else if (.ab_l_min==0 AND .cd_l_min==1) then; SHELL1QUARTET::make_esfs_dd_dspp(self,esfs)
              else if (.ab_l_min==1 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_dd_ppds(self,esfs)
              else;                                         SHELL1QUARTET::make_esfs_dd_pppp(self,esfs)
              end
           end
   ! else if (.ab_l_sum==3 AND .cd_l_sum==0) then ! ; SHELL1QUARTET::make_esfs_fs(self,esfs)
   !    if      (.ab_l_min==0) then;                  SHELL1QUARTET::make_esfs_fs_fsss(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_fs_dpss(self,esfs)
   !    end
   ! else if (.ab_l_sum==0 AND .cd_l_sum==3) then ! ; SHELL1QUARTET::make_esfs_sf(self,esfs)
   !    if      (.cd_l_min==0) then;                  SHELL1QUARTET::make_esfs_sf_ssfs(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_sf_ssdp(self,esfs)
   !    end
   ! else if (.ab_l_sum==3 AND .cd_l_sum==1) then ! ; SHELL1QUARTET::make_esfs_fp(self,esfs)
   !    if      (.ab_l_min==0) then;                  SHELL1QUARTET::make_esfs_fp_fsps(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_fp_dpps(self,esfs)
   !    end
   ! else if (.ab_l_sum==1 AND .cd_l_sum==3) then ! ; SHELL1QUARTET::make_esfs_pf(self,esfs)
   !    if      (.ab_l_min==0) then;                  SHELL1QUARTET::make_esfs_pf_psfs(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_pf_psdp(self,esfs)
   !    end
   ! else if (.ab_l_sum==3 AND .cd_l_sum==2) then ! ; SHELL1QUARTET::make_esfs_fd(self,esfs)
   !    if      (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_fd_fsds(self,esfs)
   !    else if (.ab_l_min==0 AND .cd_l_min==1) then; SHELL1QUARTET::make_esfs_fd_fspp(self,esfs)
   !    else if (.ab_l_min==1 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_fd_dpds(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_fd_dppp(self,esfs)
   !    end
   ! else if (.ab_l_sum==2 AND .cd_l_sum==3) then ! ; SHELL1QUARTET::make_esfs_df(self,esfs)
   !    if      (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_df_dsfs(self,esfs)
   !    else if (.ab_l_min==1 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_df_ppfs(self,esfs)
   !    else if (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_df_dsdp(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_df_ppdp(self,esfs)
   !    end
   ! else if (.ab_l_sum==3 AND .cd_l_sum==3) then ! ; SHELL1QUARTET::make_esfs_ff(self,esfs)
   !    if      (.ab_l_min==0 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_ff_fsfs(self,esfs)
   !    else if (.ab_l_min==0 AND .cd_l_min==1) then; SHELL1QUARTET::make_esfs_ff_fsdp(self,esfs)
   !    else if (.ab_l_min==1 AND .cd_l_min==0) then; SHELL1QUARTET::make_esfs_ff_dpfs(self,esfs)
   !    else;                                         SHELL1QUARTET::make_esfs_ff_dpdp(self,esfs)
   !    end
        case default
   !       if (.a.l==2 AND .b.l==2 AND .c.l==2 AND .d.l==2) then
   !                                                        SHELL1QUARTET::make_esfs_gg_dddd(self,esfs)
   !       else
           if      (                 .cd_l_sum==0) then;    SHELL1QUARTET::make_esfs_Xs(self,esfs)
           else if (.ab_l_sum==0                 ) then;    SHELL1QUARTET::make_esfs_sX(self,esfs)
           else if (                 .cd_l_sum==1) then;    SHELL1QUARTET::make_esfs_Xp(self,esfs)
           else if (.ab_l_sum==1                 ) then;    SHELL1QUARTET::make_esfs_pX(self,esfs)
           else if (                 .cd_l_sum==2) then;    SHELL1QUARTET::make_esfs_Xd(self,esfs)
           else if (.ab_l_sum==2                 ) then;    SHELL1QUARTET::make_esfs_dX(self,esfs)
           else;                                            SHELL1QUARTET::make_esfs_XX(self,esfs)
   !       else;                                            SHELL1QUARTET::make_esfs_general(self,esfs)
           end
   !       end
      end
   end

! This is a general purpose routine which always works
! but it doesn't use special case code.

!   make_esfs_general(esfs) ::: private
!   ! Makes the initial (es|fs) integrals, summed over the primitives
!      self :: IN
!      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT
!      Ixa,Iya,Iza :: MAT3{REAL}*
!      Ix,Iy,Iz :: MAT{REAL}*
!      Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
!      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
!      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
!      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
!      ce,cf,bb,ce1,cf1 :: REAL
!      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
!      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
!      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
!      Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
!      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
!      n_roots,dim1,dim2 :: INT
!      e,f,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
!   ! j0,j1,j2,j3,k0,k1,k2,k3 :: INT
!      rys :: RYS*
!      ss :: BIN
!      ss = .ab_l_max==0 AND .cd_l_max==0
!      dim1 = .ab_l_sum + 1                            ! Space for 2D integrals
!      dim2 = .cd_l_sum + 1
!      n_roots = (dim1+dim2)/2
!      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
!      Ixa.create(n_sum,dim1,dim2)                     ! Allocate 2D integrals
!      Iya.create(n_sum,dim1,dim2)
!      Iza.create(n_sum,dim1,dim2)
!
!      rys.create(n_roots)
!
!      i = 0
!   ! k0 = 0
!      do k = 1,.ab_n_gaussian_pairs
!         ab_cc = .ab_contraction_prefactor(k)
!   !     if (ab_cc<pair_cutoff) cycle
!         zeta = .ab_exponent_sum(k)
!         zinv = .ab_exponent_inv(k)
!         half_zinv = HALF * zinv
!         ab_cc = ab_cc * TWOPI5ON2
!   !     k1 = k0+1; k2 = k0+2; k3 = k0+3; k0 = k3
!         Px = .ab_pair_center(1,k)
!         Py = .ab_pair_center(2,k)
!         Pz = .ab_pair_center(3,k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!   !     j0 = 0
!         do j = 1,.cd_n_gaussian_pairs
!             cd_cc = .cd_contraction_prefactor(j)
!   !         if (cd_cc<pair_cutoff) cycle
!             eta  = .cd_exponent_sum(j)
!             einv = .cd_exponent_inv(j)
!   !         j1 = j0+1; j2 = j0+2; j3 = j0+3; j0 = j3
!             Qx = .cd_pair_center(1,j)
!             Qy = .cd_pair_center(2,j)
!             Qz = .cd_pair_center(3,j)
!             QCx = .cd_center_diff(1,j)
!             QCy = .cd_center_diff(2,j)
!             QCz = .cd_center_diff(3,j)
!             rho  = zeta * eta / (zeta + eta)
!             rho_zinv = rho * zinv
!             rho_einv = rho * einv
!             half_einv = HALF * einv
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx,only_weight=ss)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!               i = i + 1
!               Ix => Ixa(i,:,:)
!               Iy => Iya(i,:,:)
!               Iz => Iza(i,:,:)
!               t2      = rys.root(n)
!               Ix(1,1) = ONE
!               Iy(1,1) = ONE
!               Iz(1,1) = ONE
!               if (.ab_l_sum>0) then
!                 t2_rz = t2 * rho_zinv
!                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
!                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
!                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
!               end
!               if (.ab_l_sum>1) then
!                 ce  = (ONE - t2_rz) * half_zinv
!                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
!                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
!                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
!               end
!               if (.ab_l_sum>2) then
!                 Ixe = Ix31; Ixm1 = Ix21
!                 Iye = Iy31; Iym1 = Iy21
!                 Ize = Iz31; Izm1 = Iz21
!                 ce1 = ce
!                 do ep1 = 4,.ab_l_sum+1
!                   ce1 = ce1 + ce
!                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1,1) = Ixp1
!                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1,1) = Iyp1
!                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1,1) = Izp1
!                   Ixm1 = Ixe; Ixe = Ixp1
!                   Iym1 = Iye; Iye = Iyp1
!                   Izm1 = Ize; Ize = Izp1
!                 end
!               end
!               if (.cd_l_sum>0) then
!                 t2_re = t2 * rho_einv
!                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
!                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
!                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
!               end
!               if (.cd_l_sum>1) then
!                 cf  = (ONE - t2_re) * half_einv
!                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
!                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
!                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
!               end
!               if (.cd_l_sum>2) then
!                 Ixf = Ix13; Ixm1 = Ix12
!                 Iyf = Iy13; Iym1 = Iy12
!                 Izf = Iz13; Izm1 = Iz12
!                 cf1 = cf
!                 do fp1 = 4,.cd_l_sum+1
!                   cf1 = cf1 + cf
!                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(1,fp1) = Ixp1
!                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(1,fp1) = Iyp1
!                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(1,fp1) = Izp1
!                   Ixm1 = Ixf; Ixf = Ixp1
!                   Iym1 = Iyf; Iyf = Iyp1
!                   Izm1 = Izf; Izf = Izp1
!                 end
!               end
!               if (.ab_l_sum>0 AND .cd_l_sum>0) then
!                 bb = t2_rz * half_einv
!                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
!                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
!                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
!               end
!               if (.ab_l_sum>0 AND .cd_l_sum>1) then
!                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
!                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
!                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
!               end
!               if (.ab_l_sum>1 AND .cd_l_sum>0) then
!                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
!                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
!                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
!               end
!               if (.ab_l_sum>0 AND .cd_l_sum>2) then
!                 Ixf = Ix23; Ixm1 = Ix22
!                 Iyf = Iy23; Iym1 = Iy22
!                 Izf = Iz23; Izm1 = Iz22
!                 cf1 = cf
!                 do f = 3,.cd_l_sum
!                   fp1 = f + 1
!                   cf1 = cf1 + cf
!                   Ixp1 = Ix12*Ixf + cf1*Ixm1 + bb*Ix(1,f); Ix(2,fp1) = Ixp1
!                   Iyp1 = Iy12*Iyf + cf1*Iym1 + bb*Iy(1,f); Iy(2,fp1) = Iyp1
!                   Izp1 = Iz12*Izf + cf1*Izm1 + bb*Iz(1,f); Iz(2,fp1) = Izp1
!                   Ixm1 = Ixf; Ixf = Ixp1
!                   Iym1 = Iyf; Iyf = Iyp1
!                   Izm1 = Izf; Izf = Izp1
!                 end
!               end
!               if (.ab_l_sum>2 AND .cd_l_sum>0) then
!                 Ixe = Ix32; Ixm1 = Ix22
!                 Iye = Iy32; Iym1 = Iy22
!                 Ize = Iz32; Izm1 = Iz22
!                 ce1 = ce
!                 do e = 3,.ab_l_sum
!                   ep1 = e + 1
!                   ce1 = ce1 + ce
!                   Ixp1 = Ix21*Ixe + ce1*Ixm1 + bb*Ix(e,1); Ix(ep1,2) = Ixp1
!                   Iyp1 = Iy21*Iye + ce1*Iym1 + bb*Iy(e,1); Iy(ep1,2) = Iyp1
!                   Izp1 = Iz21*Ize + ce1*Izm1 + bb*Iz(e,1); Iz(ep1,2) = Izp1
!                   Ixm1 = Ixe; Ixe = Ixp1
!                   Iym1 = Iye; Iye = Iyp1
!                   Izm1 = Ize; Ize = Izp1
!                 end
!               end
!               if (.ab_l_sum>1 AND .cd_l_sum>1) then
!                 f1_bb = bb
!                 do f = 3,.cd_l_sum+1
!                   fm1 = f - 1
!                   Ix_f => Ix(:,f)
!                   Iy_f => Iy(:,f)
!                   Iz_f => Iz(:,f)
!                   Ix_1 => Ix(:,fm1)
!                   Iy_1 => Iy(:,fm1)
!                   Iz_1 => Iz(:,fm1)
!                   Ixe = Ix_f(2); Ixm1 = Ix_f(1)
!                   Iye = Iy_f(2); Iym1 = Iy_f(1)
!                   Ize = Iz_f(2); Izm1 = Iz_f(1)
!                   f1_bb = f1_bb + bb
!                   ce1 = ZERO
!                   do e = 2,.ab_l_sum
!                     ep1 = e + 1
!                     ce1 = ce1 + ce
!                     Ixp1 = Ix21*Ixe + ce1*Ixm1 + f1_bb*Ix_1(e); Ix_f(ep1) = Ixp1
!                     Iyp1 = Iy21*Iye + ce1*Iym1 + f1_bb*Iy_1(e); Iy_f(ep1) = Iyp1
!                     Izp1 = Iz21*Ize + ce1*Izm1 + f1_bb*Iz_1(e); Iz_f(ep1) = Izp1
!                     Ixm1 = Ixe; Ixe = Ixp1
!                     Iym1 = Iye; Iye = Iyp1
!                     Izm1 = Ize; Ize = Izp1
!                   end
!                 end
!               end
!               Iz = Iz * rys.weight(n)
!             end
!         end     ! -- loops over c,d
!      end         ! -- loops over a,b
!
!      rys.destroy
!
!      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)
!
!      Iza.destroy
!      Iya.destroy
!      Ixa.destroy
!   end

! These are optimised routines derived from the make_esfs_general routine
! and from the code in RMS2_INDICES which generates optimal fortran source.

   make_esfs_ss_0000(v11) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      v11 :: REAL

      Qx,Qy,Qz,Px,Py,Pz,QPx,QPy,QPz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho :: REAL
      j,k :: INT
      rys :: RYS*

      rys.create(1)

      v11 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx,only_weight=TRUE)
             ! Now make the 2 dimensional integrals.
             ! Only weights are needed for ss case
             v11 = v11 + rys.weight(1) * ab_cc * cd_cc * sqrt(rho)
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

   end

   make_esfs_ss_ssss(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}, OUT

      Qx,Qy,Qz,Px,Py,Pz,QPx,QPy,QPz :: REAL
      v11,zeta,eta,xx,ab_cc,cd_cc,rho :: REAL
      j,k :: INT
      rys :: RYS*

      rys.create(1)

      v11 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx,only_weight=TRUE)
             ! Now make the 2 dimensional integrals.
             ! Only weights are needed for ss case
             v11 = v11 + rys.weight(1) * ab_cc * cd_cc * sqrt(rho)
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

   ! .form_esfs(esfs,Iza,Iza,Iza,Iza(:,1,1))

      esfs(1,1) = v11

   end

   make_esfs_ps_psss(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_ab), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
      Ix21,Iy21,Iz21,v11,v21,v31 :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
      wt,t2,t2_rz :: REAL
      j,k :: INT
      rys :: RYS*

      rys.create(1)

      v11 = ZERO; v21 = ZERO; v31 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
               t2      = rys.root(1)
               wt      = rys.weight(1)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               v11 = v11 + Ix21*wt
               v21 = v21 + Iy21*wt
               v31 = v31 + Iz21*wt
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(2) = v21
      esfs(3) = v31

   end

   make_esfs_sp_ssps(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      Ix12,Iy12,Iz12,v11,v12,v13 :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,einv,rho_einv :: REAL
      wt,t2,t2_re :: REAL
      j,k :: INT
      rys :: RYS*

      rys.create(1)

      v11 = ZERO; v12 = ZERO; v13 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
               t2      = rys.root(1)
               wt      = rys.weight(1)

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               v11 = v11 + Ix12*wt
               v12 = v12 + Iy12*wt
               v13 = v13 + Iz12*wt
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(2) = v12
      esfs(3) = v13

   end

   make_esfs_pp_psps(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,zinv,rho,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,bb,half_einv :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      v11,v21,v31,v12,v22,v32,v13,v23,v33 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v21 = ZERO; v31 = ZERO
      v12 = ZERO; v22 = ZERO; v32 = ZERO
      v13 = ZERO; v23 = ZERO; v33 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 =  PAx + t2_rz*QPx
               Iy21 =  PAy + t2_rz*QPy
               Iz21 =  PAz + t2_rz*QPz

               t2_re = t2 * rho_einv
               Ix12 =  QCx - t2_re*QPx
               Iy12 =  QCy - t2_re*QPy
               Iz12 =  QCz - t2_re*QPz

               bb = t2_rz * half_einv
               Ix22 =  Ix12*Ix21 + bb
               Iy22 =  Iy12*Iy21 + bb
               Iz22 =  Iz12*Iz21 + bb

               Iz21 = Iz21*wt
               Iy21 = Iy21*wt
               Ix21 = Ix21*wt

               v11 = v11 + Ix22          *wt
               v21 = v21 + Ix12*Iy21
               v31 = v31 + Ix12*     Iz21
               v12 = v12 + Ix21*Iy12
               v22 = v22 +      Iy22     *wt
               v32 = v32 +      Iy12*Iz21
               v13 = v13 + Ix21*     Iz12
               v23 = v23 +      Iy21*Iz12
               v33 = v33 +           Iz22*wt
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(2,1) = v21
      esfs(3,1) = v31
      esfs(1,2) = v12
      esfs(2,2) = v22
      esfs(3,2) = v32
      esfs(1,3) = v13
      esfs(2,3) = v23
      esfs(3,3) = v33

   end

   make_esfs_ds_dsss(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_ab), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
      wt,t2,t2_rz,half_zinv,ce :: REAL
      Ix21,Iy21,Iz21 :: REAL
      Ix31,Iy31,Iz31 :: REAL
      v11,v21,v31,v41,v51,v61 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v21 = ZERO; v31 = ZERO
      v41 = ZERO; v51 = ZERO; v61 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt

               v11 = v11 + Ix31*wt      ! xx
               v21 = v21 + Iy31*wt      ! yy
               v31 = v31 + Iz31         ! zz
               v41 = v41 + Ix21*Iy21*wt ! xy
               v51 = v51 + Ix21*Iz21    ! xz
               v61 = v61 + Iy21*Iz21    ! yz

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(2) = v21
      esfs(3) = v31
      esfs(4) = v41
      esfs(5) = v51
      esfs(6) = v61

   end

   make_esfs_ds_ppss(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}, OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
      wt,t2,t2_rz,half_zinv,ce :: REAL
      Ix21,Iy21,Iz21 :: REAL
      Ix31,Iy31,Iz31 :: REAL
      v11,v21,v31,v41,v51,v61,v71,v81,v91,Iy21_wt :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v21 = ZERO; v31 = ZERO
      v41 = ZERO; v51 = ZERO; v61 = ZERO
      v71 = ZERO; v81 = ZERO; v91 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt

               Iy21_wt = Iy21*wt

               v11 = v11 + Ix21*wt
               v81 = v81 + Ix21*Iz21
               v21 = v21 + Iy21_wt
               v91 = v91 + Iy21*Iz21
               v31 = v31 + Iz21
               v61 = v61 + Iz31
               v41 = v41 + Ix31*wt
               v51 = v51 + Iy31*wt
               v71 = v71 + Ix21*Iy21_wt

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(8,1) = v81
      esfs(2,1) = v21
      esfs(9,1) = v91
      esfs(3,1) = v31
      esfs(6,1) = v61
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(7,1) = v71

   end

   make_esfs_sd_ssds(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,einv,rho_einv :: REAL
      wt,t2,t2_re,half_einv,cf :: REAL
      Ix12,Iy12,Iz12 :: REAL
      Ix13,Iy13,Iz13 :: REAL
      v11,v12,v13,v14,v15,v16 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v12 = ZERO; v13 = ZERO
      v14 = ZERO; v15 = ZERO; v16 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               Iz12 = Iz12*wt
               Iz13 = Iz13*wt

               v11 = v11 + Ix13*wt
               v12 = v12 + Iy13*wt
               v13 = v13 + Iz13
               v14 = v14 + Ix12*Iy12*wt
               v15 = v15 + Ix12*Iz12
               v16 = v16 + Iy12*Iz12

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(2) = v12
      esfs(3) = v13
      esfs(4) = v14
      esfs(5) = v15
      esfs(6) = v16

   end

   make_esfs_sd_sspp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,einv,rho_einv :: REAL
      wt,t2,t2_re,half_einv,cf :: REAL
      Ix12,Iy12,Iz12 :: REAL
      Ix13,Iy13,Iz13 :: REAL
      v11,v18,v12,v19,v13,v16,v14,v15,v17,Iy12_wt :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v18 = ZERO; v12 = ZERO
      v19 = ZERO; v13 = ZERO; v16 = ZERO
      v14 = ZERO; v15 = ZERO; v17 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               Iz12 = Iz12*wt
               Iz13 = Iz13*wt

               Iy12_wt = Iy12*wt

               v11 = v11 + Ix12*wt
               v18 = v18 + Ix12*Iz12
               v12 = v12 + Iy12_wt
               v19 = v19 + Iy12*Iz12
               v13 = v13 + Iz12
               v16 = v16 + Iz13
               v14 = v14 + Ix13*wt
               v15 = v15 + Iy13*wt
               v17 = v17 + Ix12*Iy12_wt

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1) = v11
      esfs(8) = v18
      esfs(2) = v12
      esfs(9) = v19
      esfs(3) = v13
      esfs(6) = v16
      esfs(4) = v14
      esfs(5) = v15
      esfs(7) = v17

   end

   make_esfs_dp_dsps(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,ce,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
      Ix22,Iy22,Iz22,Ix22_bb,Iy22_bb,Iz22_bb :: REAL
      Ix31,Iy31,Iz31,Ix32,Iy32,Iz32 :: REAL
      v11,v21,v31,v41,v51,v61,v12,v22,v32 :: REAL
      v42,v52,v62,v13,v23,v33,v43,v53,v63 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v21 = ZERO; v31 = ZERO; v41 = ZERO; v51 = ZERO; v61 = ZERO
      v12 = ZERO; v22 = ZERO; v32 = ZERO; v42 = ZERO; v52 = ZERO; v62 = ZERO
      v13 = ZERO; v23 = ZERO; v33 = ZERO; v43 = ZERO; v53 = ZERO; v63 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz22 = Iz22*wt
               Iz32 = Iz32*wt

               v11 = v11 + Ix32*wt
               v21 = v21 + Ix12*Iy31*wt
               v31 = v31 + Ix12*Iz31
               v41 = v41 + Ix22*Iy21*wt
               v51 = v51 + Ix22*Iz21
               v61 = v61 + Ix12*Iy21*Iz21
               v12 = v12 + Ix31*Iy12*wt
               v22 = v22 + Iy32*wt
               v32 = v32 + Iy12*Iz31
               v42 = v42 + Ix21*Iy22*wt
               v52 = v52 + Ix21*Iy12*Iz21
               v62 = v62 + Iy22*Iz21
               v13 = v13 + Ix31*Iz12
               v23 = v23 + Iy31*Iz12
               v33 = v33 + Iz32
               v43 = v43 + Ix21*Iy21*Iz12
               v53 = v53 + Ix21*Iz22
               v63 = v63 + Iy21*Iz22

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(2,1) = v21
      esfs(3,1) = v31
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(6,1) = v61
      esfs(1,2) = v12
      esfs(2,2) = v22
      esfs(3,2) = v32
      esfs(4,2) = v42
      esfs(5,2) = v52
      esfs(6,2) = v62
      esfs(1,3) = v13
      esfs(2,3) = v23
      esfs(3,3) = v33
      esfs(4,3) = v43
      esfs(5,3) = v53
      esfs(6,3) = v63

   end

   make_esfs_dp_ppps(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,ce,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
      Ix22,Iy22,Iz22,Ix22_bb,Iy22_bb,Iz22_bb  :: REAL
      Ix31,Iy31,Iz31,Ix32,Iy32,Iz32, Ixy  :: REAL
      v11,v81,v21,v91,v31,v61,v41,v51,v71 :: REAL
      v12,v82,v22,v92,v32,v62,v42,v52,v72 :: REAL
      v13,v83,v23,v93,v33,v63,v43,v53,v73 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v81 = ZERO; v21 = ZERO
      v91 = ZERO; v31 = ZERO; v61 = ZERO
      v41 = ZERO; v51 = ZERO; v71 = ZERO
      v12 = ZERO; v82 = ZERO; v22 = ZERO
      v92 = ZERO; v32 = ZERO; v62 = ZERO
      v42 = ZERO; v52 = ZERO; v72 = ZERO
      v13 = ZERO; v83 = ZERO; v23 = ZERO
      v93 = ZERO; v33 = ZERO; v63 = ZERO
      v43 = ZERO; v53 = ZERO; v73 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz22 = Iz22*wt
               Iz32 = Iz32*wt

               v11 = v11 + Ix22*wt
               v81 = v81 + Ix22*Iz21
               Ixy = Ix12*Iy21
               v21 = v21 + Ixy*wt
               v91 = v91 + Ixy*Iz21
               v31 = v31 + Ix12*Iz21
               v61 = v61 + Ix12*Iz31
               v41 = v41 + Ix32*wt
               v51 = v51 + Ix12*Iy31*wt
               v71 = v71 + Ix22*Iy21*wt
               Ixy = Ix21*Iy12
               v12 = v12 + Ixy*wt
               v82 = v82 + Ixy*Iz21
               v22 = v22 + Iy22*wt
               v92 = v92 + Iy22*Iz21
               v32 = v32 + Iy12*Iz21
               v62 = v62 + Iy12*Iz31
               v42 = v42 + Ix31*Iy12*wt
               v52 = v52 + Iy32*wt
               v72 = v72 + Ix21*Iy22*wt
               v13 = v13 + Ix21*Iz12
               v83 = v83 + Ix21*Iz22
               v23 = v23 + Iy21*Iz12
               v93 = v93 + Iy21*Iz22
               v33 = v33 + Iz22
               v63 = v63 + Iz32
               v43 = v43 + Ix31*Iz12
               v53 = v53 + Iy31*Iz12
               v73 = v73 + Ix21*Iy21*Iz12

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(8,1) = v81
      esfs(2,1) = v21
      esfs(9,1) = v91
      esfs(3,1) = v31
      esfs(6,1) = v61
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(7,1) = v71
      esfs(1,2) = v12
      esfs(8,2) = v82
      esfs(2,2) = v22
      esfs(9,2) = v92
      esfs(3,2) = v32
      esfs(6,2) = v62
      esfs(4,2) = v42
      esfs(5,2) = v52
      esfs(7,2) = v72
      esfs(1,3) = v13
      esfs(8,3) = v83
      esfs(2,3) = v23
      esfs(9,3) = v93
      esfs(3,3) = v33
      esfs(6,3) = v63
      esfs(4,3) = v43
      esfs(5,3) = v53
      esfs(7,3) = v73

   end

   make_esfs_pd_psds(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_einv,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
      Ix22,Iy22,Iz22,Ix22_bb,Iy22_bb,Iz22_bb :: REAL
      Ix13,Iy13,Iz13,Ix23,Iy23,Iz23 :: REAL
      v11,v21,v31,v12,v22,v32,v13,v23,v33 :: REAL
      v14,v24,v34,v15,v25,v35,v16,v26,v36 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v21 = ZERO; v31 = ZERO; v12 = ZERO; v22 = ZERO; v32 = ZERO
      v13 = ZERO; v23 = ZERO; v33 = ZERO; v14 = ZERO; v24 = ZERO; v34 = ZERO
      v15 = ZERO; v25 = ZERO; v35 = ZERO; v16 = ZERO; v26 = ZERO; v36 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Iz21 = Iz21*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt

               v11 = v11 + Ix23*wt
               v21 = v21 + Ix13*Iy21*wt
               v31 = v31 + Ix13*Iz21
               v12 = v12 + Ix21*Iy13*wt
               v22 = v22 + Iy23*wt
               v32 = v32 + Iy13*Iz21
               v13 = v13 + Ix21*Iz13
               v23 = v23 + Iy21*Iz13
               v33 = v33 + Iz23
               v14 = v14 + Ix22*Iy12*wt
               v24 = v24 + Ix12*Iy22*wt
               v34 = v34 + Ix12*Iy12*Iz21
               v15 = v15 + Ix22*Iz12
               v25 = v25 + Ix12*Iy21*Iz12
               v35 = v35 + Ix12*Iz22
               v16 = v16 + Ix21*Iy12*Iz12
               v26 = v26 + Iy22*Iz12
               v36 = v36 + Iy12*Iz22

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(2,1) = v21
      esfs(3,1) = v31
      esfs(1,2) = v12
      esfs(2,2) = v22
      esfs(3,2) = v32
      esfs(1,3) = v13
      esfs(2,3) = v23
      esfs(3,3) = v33
      esfs(1,4) = v14
      esfs(2,4) = v24
      esfs(3,4) = v34
      esfs(1,5) = v15
      esfs(2,5) = v25
      esfs(3,5) = v35
      esfs(1,6) = v16
      esfs(2,6) = v26
      esfs(3,6) = v36

   end

   make_esfs_pd_pspp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_einv,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
      Ix22,Iy22,Iz22,Ix22_bb,Iy22_bb,Iz22_bb :: REAL
      Ix13,Iy13,Iz13,Ix23,Iy23,Iz23, Ixy  :: REAL
      v11,v18,v21,v28,v31,v38,v12,v19,v22 :: REAL
      v29,v32,v39,v13,v16,v23,v26,v33,v36 :: REAL
      v14,v24,v34,v15,v25,v35,v17,v27,v37 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 2
      rys.create(n_roots)

      v11 = ZERO; v18 = ZERO; v21 = ZERO
      v28 = ZERO; v31 = ZERO; v38 = ZERO
      v12 = ZERO; v19 = ZERO; v22 = ZERO
      v29 = ZERO; v32 = ZERO; v39 = ZERO
      v13 = ZERO; v16 = ZERO; v23 = ZERO
      v26 = ZERO; v33 = ZERO; v36 = ZERO
      v14 = ZERO; v24 = ZERO; v34 = ZERO
      v15 = ZERO; v25 = ZERO; v35 = ZERO
      v17 = ZERO; v27 = ZERO; v37 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Iz21 = Iz21*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt

               v11 = v11 + Ix22*wt
               v18 = v18 + Ix22*Iz12
               Ixy = Ix12*Iy21
               v21 = v21 + Ixy*wt
               v28 = v28 + Ixy*Iz12
               v31 = v31 + Ix12*Iz21
               v38 = v38 + Ix12*Iz22
               Ixy = Ix21*Iy12
               v12 = v12 + Ixy*wt
               v19 = v19 + Ixy*Iz12
               v22 = v22 + Iy22*wt
               v29 = v29 + Iy22*Iz12
               v32 = v32 + Iy12*Iz21
               v39 = v39 + Iy12*Iz22
               v13 = v13 + Ix21*Iz12
               v16 = v16 + Ix21*Iz13
               v23 = v23 + Iy21*Iz12
               v26 = v26 + Iy21*Iz13
               v33 = v33 + Iz22
               v36 = v36 + Iz23
               v14 = v14 + Ix23*wt
               v24 = v24 + Ix13*Iy21*wt
               v34 = v34 + Ix13*Iz21
               v15 = v15 + Ix21*Iy13*wt
               v25 = v25 + Iy23*wt
               v35 = v35 + Iy13*Iz21
               v17 = v17 + Ix22*Iy12*wt
               v27 = v27 + Ix12*Iy22*wt
               v37 = v37 + Ix12*Iy12*Iz21

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(1,8) = v18
      esfs(2,1) = v21
      esfs(2,8) = v28
      esfs(3,1) = v31
      esfs(3,8) = v38
      esfs(1,2) = v12
      esfs(1,9) = v19
      esfs(2,2) = v22
      esfs(2,9) = v29
      esfs(3,2) = v32
      esfs(3,9) = v39
      esfs(1,3) = v13
      esfs(1,6) = v16
      esfs(2,3) = v23
      esfs(2,6) = v26
      esfs(3,3) = v33
      esfs(3,6) = v36
      esfs(1,4) = v14
      esfs(2,4) = v24
      esfs(3,4) = v34
      esfs(1,5) = v15
      esfs(2,5) = v25
      esfs(3,5) = v35
      esfs(1,7) = v17
      esfs(2,7) = v27
      esfs(3,7) = v37

   end

   make_esfs_dd_dsds(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ix33,Iy33,Iz33,Ix22_bb,Iy22_bb,Iz22_bb :: REAL
      v11,v21,v31,v41,v51,v61,v12,v22,v32 :: REAL
      v42,v52,v62,v13,v23,v33,v43,v53,v63 :: REAL
      v14,v24,v34,v44,v54,v64,v15,v25,v35 :: REAL
      v45,v55,v65,v16,v26,v36,v46,v56,v66 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 3
      rys.create(n_roots)

      v11 = ZERO; v21 = ZERO; v31 = ZERO; v41 = ZERO; v51 = ZERO; v61 = ZERO
      v12 = ZERO; v22 = ZERO; v32 = ZERO; v42 = ZERO; v52 = ZERO; v62 = ZERO
      v13 = ZERO; v23 = ZERO; v33 = ZERO; v43 = ZERO; v53 = ZERO; v63 = ZERO
      v14 = ZERO; v24 = ZERO; v34 = ZERO; v44 = ZERO; v54 = ZERO; v64 = ZERO
      v15 = ZERO; v25 = ZERO; v35 = ZERO; v45 = ZERO; v55 = ZERO; v65 = ZERO
      v16 = ZERO; v26 = ZERO; v36 = ZERO; v46 = ZERO; v56 = ZERO; v66 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               f1_bb = bb + bb
               Ix33 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22
               Iy33 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22
               Iz33 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt
               Iz32 = Iz32*wt
               Iz33 = Iz33*wt

               v11 = v11 + Ix33*wt
               v21 = v21 + Ix13*Iy31*wt
               v31 = v31 + Ix13*Iz31
               v41 = v41 + Ix23*Iy21*wt
               v51 = v51 + Ix23*Iz21
               v61 = v61 + Ix13*Iy21*Iz21
               v12 = v12 + Ix31*Iy13*wt
               v22 = v22 + Iy33*wt
               v32 = v32 + Iy13*Iz31
               v42 = v42 + Ix21*Iy23*wt
               v52 = v52 + Ix21*Iy13*Iz21
               v62 = v62 + Iy23*Iz21
               v13 = v13 + Ix31*Iz13
               v23 = v23 + Iy31*Iz13
               v33 = v33 + Iz33
               v43 = v43 + Ix21*Iy21*Iz13
               v53 = v53 + Ix21*Iz23
               v63 = v63 + Iy21*Iz23
               v14 = v14 + Ix32*Iy12*wt
               v24 = v24 + Ix12*Iy32*wt
               v34 = v34 + Ix12*Iy12*Iz31
               v44 = v44 + Ix22*Iy22*wt
               v54 = v54 + Ix22*Iy12*Iz21
               v64 = v64 + Ix12*Iy22*Iz21
               v15 = v15 + Ix32*Iz12
               v25 = v25 + Ix12*Iy31*Iz12
               v35 = v35 + Ix12*Iz32
               v45 = v45 + Ix22*Iy21*Iz12
               v55 = v55 + Ix22*Iz22
               v65 = v65 + Ix12*Iy21*Iz22
               v16 = v16 + Ix31*Iy12*Iz12
               v26 = v26 + Iy32*Iz12
               v36 = v36 + Iy12*Iz32
               v46 = v46 + Ix21*Iy22*Iz12
               v56 = v56 + Ix21*Iy12*Iz22
               v66 = v66 + Iy22*Iz22

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(2,1) = v21
      esfs(3,1) = v31
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(6,1) = v61
      esfs(1,2) = v12
      esfs(2,2) = v22
      esfs(3,2) = v32
      esfs(4,2) = v42
      esfs(5,2) = v52
      esfs(6,2) = v62
      esfs(1,3) = v13
      esfs(2,3) = v23
      esfs(3,3) = v33
      esfs(4,3) = v43
      esfs(5,3) = v53
      esfs(6,3) = v63
      esfs(1,4) = v14
      esfs(2,4) = v24
      esfs(3,4) = v34
      esfs(4,4) = v44
      esfs(5,4) = v54
      esfs(6,4) = v64
      esfs(1,5) = v15
      esfs(2,5) = v25
      esfs(3,5) = v35
      esfs(4,5) = v45
      esfs(5,5) = v55
      esfs(6,5) = v65
      esfs(1,6) = v16
      esfs(2,6) = v26
      esfs(3,6) = v36
      esfs(4,6) = v46
      esfs(5,6) = v56
      esfs(6,6) = v66

   end

   make_esfs_dd_dspp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ix33,Iy33,Iz33,Ix22_bb,Iy22_bb,Iz22_bb, Ixy :: REAL
      v11,v18,v21,v28,v31,v38 :: REAL
      v41,v48,v51,v58,v61,v68 :: REAL
      v12,v19,v22,v29,v32,v39 :: REAL
      v42,v49,v52,v59,v62,v69 :: REAL
      v13,v16,v23,v26,v33,v36 :: REAL
      v43,v46,v53,v56,v63,v66 :: REAL
      v14,v24,v34,v44,v54,v64 :: REAL
      v15,v25,v35,v45,v55,v65 :: REAL
      v17,v27,v37,v47,v57,v67 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 3
      rys.create(n_roots)

      v11 = ZERO; v18 = ZERO; v21 = ZERO; v28 = ZERO; v31 = ZERO; v38 = ZERO
      v41 = ZERO; v48 = ZERO; v51 = ZERO; v58 = ZERO; v61 = ZERO; v68 = ZERO
      v12 = ZERO; v19 = ZERO; v22 = ZERO; v29 = ZERO; v32 = ZERO; v39 = ZERO
      v42 = ZERO; v49 = ZERO; v52 = ZERO; v59 = ZERO; v62 = ZERO; v69 = ZERO
      v13 = ZERO; v16 = ZERO; v23 = ZERO; v26 = ZERO; v33 = ZERO; v36 = ZERO
      v43 = ZERO; v46 = ZERO; v53 = ZERO; v56 = ZERO; v63 = ZERO; v66 = ZERO
      v14 = ZERO; v24 = ZERO; v34 = ZERO; v44 = ZERO; v54 = ZERO; v64 = ZERO
      v15 = ZERO; v25 = ZERO; v35 = ZERO; v45 = ZERO; v55 = ZERO; v65 = ZERO
      v17 = ZERO; v27 = ZERO; v37 = ZERO; v47 = ZERO; v57 = ZERO; v67 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               f1_bb = bb + bb
               Ix33 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22
               Iy33 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22
               Iz33 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt
               Iz32 = Iz32*wt
               Iz33 = Iz33*wt

               v11 = v11 + Ix32*wt
               v18 = v18 + Ix32*Iz12
               Ixy = Ix12*Iy31
               v21 = v21 + Ixy*wt
               v28 = v28 + Ixy*Iz12
               v31 = v31 + Ix12*Iz31
               v38 = v38 + Ix12*Iz32
               Ixy = Ix22*Iy21
               v41 = v41 + Ixy*wt
               v48 = v48 + Ixy*Iz12
               v51 = v51 + Ix22*Iz21
               v58 = v58 + Ix22*Iz22
               Ixy = Ix12*Iy21
               v61 = v61 + Ixy*Iz21
               v68 = v68 + Ixy*Iz22
               Ixy = Ix31*Iy12
               v12 = v12 + Ixy*wt
               v19 = v19 + Ixy*Iz12
               v22 = v22 + Iy32*wt
               v29 = v29 + Iy32*Iz12
               v32 = v32 + Iy12*Iz31
               v39 = v39 + Iy12*Iz32
               Ixy = Ix21*Iy22
               v42 = v42 + Ixy*wt
               v49 = v49 + Ixy*Iz12
               Ixy = Ix21*Iy12
               v52 = v52 + Ixy*Iz21
               v59 = v59 + Ixy*Iz22
               v62 = v62 + Iy22*Iz21
               v69 = v69 + Iy22*Iz22
               v13 = v13 + Ix31*Iz12
               v16 = v16 + Ix31*Iz13
               v23 = v23 + Iy31*Iz12
               v26 = v26 + Iy31*Iz13
               v33 = v33 + Iz32
               v36 = v36 + Iz33
               Ixy = Ix21*Iy21
               v43 = v43 + Ixy*Iz12
               v46 = v46 + Ixy*Iz13
               v53 = v53 + Ix21*Iz22
               v56 = v56 + Ix21*Iz23
               v63 = v63 + Iy21*Iz22
               v66 = v66 + Iy21*Iz23
               v14 = v14 + Ix33*wt
               v24 = v24 + Ix13*Iy31*wt
               v34 = v34 + Ix13*Iz31
               v44 = v44 + Ix23*Iy21*wt
               v54 = v54 + Ix23*Iz21
               v64 = v64 + Ix13*Iy21*Iz21
               v15 = v15 + Ix31*Iy13*wt
               v25 = v25 + Iy33*wt
               v35 = v35 + Iy13*Iz31
               v45 = v45 + Ix21*Iy23*wt
               v55 = v55 + Ix21*Iy13*Iz21
               v65 = v65 + Iy23*Iz21
               v17 = v17 + Ix32*Iy12*wt
               v27 = v27 + Ix12*Iy32*wt
               v37 = v37 + Ix12*Iy12*Iz31
               v47 = v47 + Ix22*Iy22*wt
               v57 = v57 + Ix22*Iy12*Iz21
               v67 = v67 + Ix12*Iy22*Iz21

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(1,8) = v18
      esfs(2,1) = v21
      esfs(2,8) = v28
      esfs(3,1) = v31
      esfs(3,8) = v38
      esfs(4,1) = v41
      esfs(4,8) = v48
      esfs(5,1) = v51
      esfs(5,8) = v58
      esfs(6,1) = v61
      esfs(6,8) = v68
      esfs(1,2) = v12
      esfs(1,9) = v19
      esfs(2,2) = v22
      esfs(2,9) = v29
      esfs(3,2) = v32
      esfs(3,9) = v39
      esfs(4,2) = v42
      esfs(4,9) = v49
      esfs(5,2) = v52
      esfs(5,9) = v59
      esfs(6,2) = v62
      esfs(6,9) = v69
      esfs(1,3) = v13
      esfs(1,6) = v16
      esfs(2,3) = v23
      esfs(2,6) = v26
      esfs(3,3) = v33
      esfs(3,6) = v36
      esfs(4,3) = v43
      esfs(4,6) = v46
      esfs(5,3) = v53
      esfs(5,6) = v56
      esfs(6,3) = v63
      esfs(6,6) = v66
      esfs(1,4) = v14
      esfs(2,4) = v24
      esfs(3,4) = v34
      esfs(4,4) = v44
      esfs(5,4) = v54
      esfs(6,4) = v64
      esfs(1,5) = v15
      esfs(2,5) = v25
      esfs(3,5) = v35
      esfs(4,5) = v45
      esfs(5,5) = v55
      esfs(6,5) = v65
      esfs(1,7) = v17
      esfs(2,7) = v27
      esfs(3,7) = v37
      esfs(4,7) = v47
      esfs(5,7) = v57
      esfs(6,7) = v67

   end

   make_esfs_dd_ppds(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ix33,Iy33,Iz33,Ix22_bb,Iy22_bb,Iz22_bb, Ixy :: REAL
      v11,v81,v21,v91,v31,v61 :: REAL
      v41,v51,v71,v12,v82,v22 :: REAL
      v92,v32,v62,v42,v52,v72 :: REAL
      v13,v83,v23,v93,v33,v63 :: REAL
      v43,v53,v73,v14,v84,v24 :: REAL
      v94,v34,v64,v44,v54,v74 :: REAL
      v15,v85,v25,v95,v35,v65 :: REAL
      v45,v55,v75,v16,v86,v26 :: REAL
      v96,v36,v66,v46,v56,v76 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 3
      rys.create(n_roots)


      v11 = ZERO; v81 = ZERO; v21 = ZERO; v91 = ZERO; v31 = ZERO; v61 = ZERO
      v41 = ZERO; v51 = ZERO; v71 = ZERO; v12 = ZERO; v82 = ZERO; v22 = ZERO
      v92 = ZERO; v32 = ZERO; v62 = ZERO; v42 = ZERO; v52 = ZERO; v72 = ZERO
      v13 = ZERO; v83 = ZERO; v23 = ZERO; v93 = ZERO; v33 = ZERO; v63 = ZERO
      v43 = ZERO; v53 = ZERO; v73 = ZERO; v14 = ZERO; v84 = ZERO; v24 = ZERO
      v94 = ZERO; v34 = ZERO; v64 = ZERO; v44 = ZERO; v54 = ZERO; v74 = ZERO
      v15 = ZERO; v85 = ZERO; v25 = ZERO; v95 = ZERO; v35 = ZERO; v65 = ZERO
      v45 = ZERO; v55 = ZERO; v75 = ZERO; v16 = ZERO; v86 = ZERO; v26 = ZERO
      v96 = ZERO; v36 = ZERO; v66 = ZERO; v46 = ZERO; v56 = ZERO; v76 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               f1_bb = bb + bb
               Ix33 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22
               Iy33 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22
               Iz33 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt
               Iz32 = Iz32*wt
               Iz33 = Iz33*wt

               v11 = v11 + Ix23*wt
               v81 = v81 + Ix23*Iz21
               Ixy = Ix13*Iy21
               v21 = v21 + Ixy*wt
               v91 = v91 + Ixy*Iz21
               v31 = v31 + Ix13*Iz21
               v61 = v61 + Ix13*Iz31
               v41 = v41 + Ix33*wt
               v51 = v51 + Ix13*Iy31*wt
               v71 = v71 + Ix23*Iy21*wt
               Ixy = Ix21*Iy13
               v12 = v12 + Ixy*wt
               v82 = v82 + Ixy*Iz21
               v22 = v22 + Iy23*wt
               v92 = v92 + Iy23*Iz21
               v32 = v32 + Iy13*Iz21
               v62 = v62 + Iy13*Iz31
               v42 = v42 + Ix31*Iy13*wt
               v52 = v52 + Iy33*wt
               v72 = v72 + Ix21*Iy23*wt
               v13 = v13 + Ix21*Iz13
               v83 = v83 + Ix21*Iz23
               v23 = v23 + Iy21*Iz13
               v93 = v93 + Iy21*Iz23
               v33 = v33 + Iz23
               v63 = v63 + Iz33
               v43 = v43 + Ix31*Iz13
               v53 = v53 + Iy31*Iz13
               v73 = v73 + Ix21*Iy21*Iz13
               Ixy = Ix22*Iy12
               v14 = v14 + Ixy*wt
               v84 = v84 + Ixy*Iz21
               Ixy = Ix12*Iy22
               v24 = v24 + Ixy*wt
               v94 = v94 + Ixy*Iz21
               Ixy = Ix12*Iy12
               v34 = v34 + Ixy*Iz21
               v64 = v64 + Ixy*Iz31
               v44 = v44 + Ix32*Iy12*wt
               v54 = v54 + Ix12*Iy32*wt
               v74 = v74 + Ix22*Iy22*wt
               v15 = v15 + Ix22*Iz12
               v85 = v85 + Ix22*Iz22
               Ixy = Ix12*Iy21
               v25 = v25 + Ixy*Iz12
               v95 = v95 + Ixy*Iz22
               v35 = v35 + Ix12*Iz22
               v65 = v65 + Ix12*Iz32
               v45 = v45 + Ix32*Iz12
               v55 = v55 + Ix12*Iy31*Iz12
               v75 = v75 + Ix22*Iy21*Iz12
               Ixy = Ix21*Iy12
               v16 = v16 + Ixy*Iz12
               v86 = v86 + Ixy*Iz22
               v26 = v26 + Iy22*Iz12
               v96 = v96 + Iy22*Iz22
               v36 = v36 + Iy12*Iz22
               v66 = v66 + Iy12*Iz32
               v46 = v46 + Ix31*Iy12*Iz12
               v56 = v56 + Iy32*Iz12
               v76 = v76 + Ix21*Iy22*Iz12

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(8,1) = v81
      esfs(2,1) = v21
      esfs(9,1) = v91
      esfs(3,1) = v31
      esfs(6,1) = v61
      esfs(4,1) = v41
      esfs(5,1) = v51
      esfs(7,1) = v71
      esfs(1,2) = v12
      esfs(8,2) = v82
      esfs(2,2) = v22
      esfs(9,2) = v92
      esfs(3,2) = v32
      esfs(6,2) = v62
      esfs(4,2) = v42
      esfs(5,2) = v52
      esfs(7,2) = v72
      esfs(1,3) = v13
      esfs(8,3) = v83
      esfs(2,3) = v23
      esfs(9,3) = v93
      esfs(3,3) = v33
      esfs(6,3) = v63
      esfs(4,3) = v43
      esfs(5,3) = v53
      esfs(7,3) = v73
      esfs(1,4) = v14
      esfs(8,4) = v84
      esfs(2,4) = v24
      esfs(9,4) = v94
      esfs(3,4) = v34
      esfs(6,4) = v64
      esfs(4,4) = v44
      esfs(5,4) = v54
      esfs(7,4) = v74
      esfs(1,5) = v15
      esfs(8,5) = v85
      esfs(2,5) = v25
      esfs(9,5) = v95
      esfs(3,5) = v35
      esfs(6,5) = v65
      esfs(4,5) = v45
      esfs(5,5) = v55
      esfs(7,5) = v75
      esfs(1,6) = v16
      esfs(8,6) = v86
      esfs(2,6) = v26
      esfs(9,6) = v96
      esfs(3,6) = v36
      esfs(6,6) = v66
      esfs(4,6) = v46
      esfs(5,6) = v56
      esfs(7,6) = v76

   end

   make_esfs_dd_pppp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      wt,t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ix33,Iy33,Iz33,Ix22_bb,Iy22_bb,Iz22_bb, Ixy :: REAL
      v11,v81,v18,v88,v21,v91,v28,v98,v31 :: REAL
      v61,v38,v68,v41,v48,v51,v58,v71,v78 :: REAL
      v12,v82,v19,v89,v22,v92,v29,v99,v32 :: REAL
      v62,v39,v69,v42,v49,v52,v59,v72,v79 :: REAL
      v13,v83,v16,v86,v23,v93,v26,v96,v33 :: REAL
      v63,v36,v66,v43,v46,v53,v56,v73,v76 :: REAL
      v14,v84,v24,v94,v34,v64,v44,v54,v74 :: REAL
      v15,v85,v25,v95,v35,v65,v45,v55,v75 :: REAL
      v17,v87,v27,v97,v37,v67,v47,v57,v77 :: REAL
      n_roots,n,j,k :: INT
      rys :: RYS*

      n_roots = 3
      rys.create(n_roots)

      v11 = ZERO; v81 = ZERO; v18 = ZERO; v88 = ZERO; v21 = ZERO; v91 = ZERO
      v28 = ZERO; v98 = ZERO; v31 = ZERO; v61 = ZERO; v38 = ZERO; v68 = ZERO
      v41 = ZERO; v48 = ZERO; v51 = ZERO; v58 = ZERO; v71 = ZERO; v78 = ZERO
      v12 = ZERO; v82 = ZERO; v19 = ZERO; v89 = ZERO; v22 = ZERO; v92 = ZERO
      v29 = ZERO; v99 = ZERO; v32 = ZERO; v62 = ZERO; v39 = ZERO; v69 = ZERO
      v42 = ZERO; v49 = ZERO; v52 = ZERO; v59 = ZERO; v72 = ZERO; v79 = ZERO
      v13 = ZERO; v83 = ZERO; v16 = ZERO; v86 = ZERO; v23 = ZERO; v93 = ZERO
      v26 = ZERO; v96 = ZERO; v33 = ZERO; v63 = ZERO; v36 = ZERO; v66 = ZERO
      v43 = ZERO; v46 = ZERO; v53 = ZERO; v56 = ZERO; v73 = ZERO; v76 = ZERO
      v14 = ZERO; v84 = ZERO; v24 = ZERO; v94 = ZERO; v34 = ZERO; v64 = ZERO
      v44 = ZERO; v54 = ZERO; v74 = ZERO; v15 = ZERO; v85 = ZERO; v25 = ZERO
      v95 = ZERO; v35 = ZERO; v65 = ZERO; v45 = ZERO; v55 = ZERO; v75 = ZERO
      v17 = ZERO; v87 = ZERO; v27 = ZERO; v97 = ZERO; v37 = ZERO; v67 = ZERO
      v47 = ZERO; v57 = ZERO; v77 = ZERO

      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             half_einv = HALF * einv
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               t2      = rys.root(n)
               wt      = rys.weight(n)

               t2_rz = t2 * rho_zinv
               Ix21 = PAx + t2_rz*QPx
               Iy21 = PAy + t2_rz*QPy
               Iz21 = PAz + t2_rz*QPz

               ce  = (ONE - t2_rz) * half_zinv
               Ix31 = Ix21*Ix21 + ce
               Iy31 = Iy21*Iy21 + ce
               Iz31 = Iz21*Iz21 + ce

               t2_re = t2 * rho_einv
               Ix12 = QCx - t2_re*QPx
               Iy12 = QCy - t2_re*QPy
               Iz12 = QCz - t2_re*QPz

               cf  = (ONE - t2_re) * half_einv
               Ix13 = Ix12*Ix12 + cf
               Iy13 = Iy12*Iy12 + cf
               Iz13 = Iz12*Iz12 + cf

               bb = t2_rz * half_einv
               Ix22 = Ix12*Ix21 + bb
               Iy22 = Iy12*Iy21 + bb
               Iz22 = Iz12*Iz21 + bb

               Ix22_bb = Ix22 + bb
               Iy22_bb = Iy22 + bb
               Iz22_bb = Iz22 + bb

               Ix23 = Ix12*Ix22_bb + cf*Ix21
               Iy23 = Iy12*Iy22_bb + cf*Iy21
               Iz23 = Iz12*Iz22_bb + cf*Iz21

               Ix32 = Ix21*Ix22_bb + ce*Ix12
               Iy32 = Iy21*Iy22_bb + ce*Iy12
               Iz32 = Iz21*Iz22_bb + ce*Iz12

               f1_bb = bb + bb
               Ix33 = Ix21*Ix23 + ce*Ix13 + f1_bb*Ix22
               Iy33 = Iy21*Iy23 + ce*Iy13 + f1_bb*Iy22
               Iz33 = Iz21*Iz23 + ce*Iz13 + f1_bb*Iz22

               Iz21 = Iz21*wt
               Iz31 = Iz31*wt
               Iz12 = Iz12*wt
               Iz13 = Iz13*wt
               Iz22 = Iz22*wt
               Iz23 = Iz23*wt
               Iz32 = Iz32*wt
               Iz33 = Iz33*wt

               v11 = v11 + Ix22*wt
               v81 = v81 + Ix22*Iz21
               v18 = v18 + Ix22*Iz12
               v88 = v88 + Ix22*Iz22
               Ixy = Ix12*Iy21
               v21 = v21 + Ixy*wt
               v91 = v91 + Ixy*Iz21
               v28 = v28 + Ixy*Iz12
               v98 = v98 + Ixy*Iz22
               v31 = v31 + Ix12*Iz21
               v61 = v61 + Ix12*Iz31
               v38 = v38 + Ix12*Iz22
               v68 = v68 + Ix12*Iz32
               v41 = v41 + Ix32*wt
               v48 = v48 + Ix32*Iz12
               Ixy = Ix12*Iy31
               v51 = v51 + Ixy*wt
               v58 = v58 + Ixy*Iz12
               Ixy = Ix22*Iy21
               v71 = v71 + Ixy*wt
               v78 = v78 + Ixy*Iz12
               Ixy = Ix21*Iy12
               v12 = v12 + Ixy*wt
               v82 = v82 + Ixy*Iz21
               v19 = v19 + Ixy*Iz12
               v89 = v89 + Ixy*Iz22
               v22 = v22 + Iy22*wt
               v92 = v92 + Iy22*Iz21
               v29 = v29 + Iy22*Iz12
               v99 = v99 + Iy22*Iz22
               v32 = v32 + Iy12*Iz21
               v62 = v62 + Iy12*Iz31
               v39 = v39 + Iy12*Iz22
               v69 = v69 + Iy12*Iz32
               Ixy = Ix31*Iy12
               v42 = v42 + Ixy*wt
               v49 = v49 + Ixy*Iz12
               v52 = v52 + Iy32*wt
               v59 = v59 + Iy32*Iz12
               Ixy = Ix21*Iy22
               v72 = v72 + Ixy*wt
               v79 = v79 + Ixy*Iz12
               v13 = v13 + Ix21*Iz12
               v83 = v83 + Ix21*Iz22
               v16 = v16 + Ix21*Iz13
               v86 = v86 + Ix21*Iz23
               v23 = v23 + Iy21*Iz12
               v93 = v93 + Iy21*Iz22
               v26 = v26 + Iy21*Iz13
               v96 = v96 + Iy21*Iz23
               v33 = v33 + Iz22
               v63 = v63 + Iz32
               v36 = v36 + Iz23
               v66 = v66 + Iz33
               v43 = v43 + Ix31*Iz12
               v46 = v46 + Ix31*Iz13
               v53 = v53 + Iy31*Iz12
               v56 = v56 + Iy31*Iz13
               Ixy = Ix21*Iy21
               v73 = v73 + Ixy*Iz12
               v76 = v76 + Ixy*Iz13
               v14 = v14 + Ix23*wt
               v84 = v84 + Ix23*Iz21
               Ixy = Ix13*Iy21
               v24 = v24 + Ixy*wt
               v94 = v94 + Ixy*Iz21
               v34 = v34 + Ix13*Iz21
               v64 = v64 + Ix13*Iz31
               v44 = v44 + Ix33*wt
               v54 = v54 + Ix13*Iy31*wt
               v74 = v74 + Ix23*Iy21*wt
               Ixy = Ix21*Iy13
               v15 = v15 + Ixy*wt
               v85 = v85 + Ixy*Iz21
               v25 = v25 + Iy23*wt
               v95 = v95 + Iy23*Iz21
               v35 = v35 + Iy13*Iz21
               v65 = v65 + Iy13*Iz31
               v45 = v45 + Ix31*Iy13*wt
               v55 = v55 + Iy33*wt
               v75 = v75 + Ix21*Iy23*wt
               Ixy = Ix22*Iy12
               v17 = v17 + Ixy*wt
               v87 = v87 + Ixy*Iz21
               Ixy = Ix12*Iy22
               v27 = v27 + Ixy*wt
               v97 = v97 + Ixy*Iz21
               Ixy = Ix12*Iy12
               v37 = v37 + Ixy*Iz21
               v67 = v67 + Ixy*Iz31
               v47 = v47 + Ix32*Iy12*wt
               v57 = v57 + Ix12*Iy32*wt
               v77 = v77 + Ix22*Iy22*wt

             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      ! .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))

      esfs(1,1) = v11
      esfs(8,1) = v81
      esfs(1,8) = v18
      esfs(8,8) = v88
      esfs(2,1) = v21
      esfs(9,1) = v91
      esfs(2,8) = v28
      esfs(9,8) = v98
      esfs(3,1) = v31
      esfs(6,1) = v61
      esfs(3,8) = v38
      esfs(6,8) = v68
      esfs(4,1) = v41
      esfs(4,8) = v48
      esfs(5,1) = v51
      esfs(5,8) = v58
      esfs(7,1) = v71
      esfs(7,8) = v78
      esfs(1,2) = v12
      esfs(8,2) = v82
      esfs(1,9) = v19
      esfs(8,9) = v89
      esfs(2,2) = v22
      esfs(9,2) = v92
      esfs(2,9) = v29
      esfs(9,9) = v99
      esfs(3,2) = v32
      esfs(6,2) = v62
      esfs(3,9) = v39
      esfs(6,9) = v69
      esfs(4,2) = v42
      esfs(4,9) = v49
      esfs(5,2) = v52
      esfs(5,9) = v59
      esfs(7,2) = v72
      esfs(7,9) = v79
      esfs(1,3) = v13
      esfs(8,3) = v83
      esfs(1,6) = v16
      esfs(8,6) = v86
      esfs(2,3) = v23
      esfs(9,3) = v93
      esfs(2,6) = v26
      esfs(9,6) = v96
      esfs(3,3) = v33
      esfs(6,3) = v63
      esfs(3,6) = v36
      esfs(6,6) = v66
      esfs(4,3) = v43
      esfs(4,6) = v46
      esfs(5,3) = v53
      esfs(5,6) = v56
      esfs(7,3) = v73
      esfs(7,6) = v76
      esfs(1,4) = v14
      esfs(8,4) = v84
      esfs(2,4) = v24
      esfs(9,4) = v94
      esfs(3,4) = v34
      esfs(6,4) = v64
      esfs(4,4) = v44
      esfs(5,4) = v54
      esfs(7,4) = v74
      esfs(1,5) = v15
      esfs(8,5) = v85
      esfs(2,5) = v25
      esfs(9,5) = v95
      esfs(3,5) = v35
      esfs(6,5) = v65
      esfs(4,5) = v45
      esfs(5,5) = v55
      esfs(7,5) = v75
      esfs(1,7) = v17
      esfs(8,7) = v87
      esfs(2,7) = v27
      esfs(9,7) = v97
      esfs(3,7) = v37
      esfs(6,7) = v67
      esfs(4,7) = v47
      esfs(5,7) = v57
      esfs(7,7) = v77

   end

   make_esfs_Xs(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_ab), OUT

      Ixa,Iya,Iza :: MAT{REAL}*
      Ix,Iy,Iz :: VEC{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,rho_zinv :: REAL
      t2,t2_rz,half_zinv :: REAL
      ce,ce1 :: REAL
      Ix21,Iy21,Iz21 :: REAL
      Ix31,Iy31,Iz31 :: REAL
      Ixe, Iye, Ize  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      ep1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1
      dim2 = .cd_l_sum + 1 ! This is 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1)
      Iya.create(n_sum,dim1)
      Iza.create(n_sum,dim1)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:)
               Iy => Iya(i,:)
               Iz => Iza(i,:)
               t2      = rys.root(n)
               Ix(1) = ONE
               Iy(1) = ONE
               Iz(1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3) = Iz31
                 Ixe = Ix31; Ixm1 = Ix21
                 Iye = Iy31; Iym1 = Iy21
                 Ize = Iz31; Izm1 = Iz21
                 ce1 = ce
                 do ep1 = 4,.ab_l_sum+1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esss(esfs,Ixa,Iya,Iza,Iza(:,1),n_sum)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_sX(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      Ixa,Iya,Iza :: MAT{REAL}*
      Ix,Iy,Iz :: VEC{REAL}*
      QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,einv,rho_einv :: REAL
      t2,t2_re,half_einv :: REAL
      cf,cf1 :: REAL
      Ix12,Iy12,Iz12 :: REAL
      Ix13,Iy13,Iz13 :: REAL
      Ixf, Iyf, Izf  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      fp1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1 ! This is 1
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim2)
      Iya.create(n_sum,dim2)
      Iza.create(n_sum,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:)
               Iy => Iya(i,:)
               Iz => Iza(i,:)
               t2      = rys.root(n)
               Ix(1) = ONE
               Iy(1) = ONE
               Iz(1) = ONE
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(3) = Iz13
                 Ixf = Ix13; Ixm1 = Ix12
                 Iyf = Iy13; Iym1 = Iy12
                 Izf = Iz13; Izm1 = Iz12
                 cf1 = cf
                 do fp1 = 4,.cd_l_sum+1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_ssfs(esfs,Ixa,Iya,Iza,Iza(:,1),n_sum)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_Xp(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv :: REAL
      ce,bb,ce1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31 :: REAL
      Ix32,Iy32,Iz32 :: REAL
      Ixe, Iye, Ize  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      e,ep1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1                            ! Space for 2D integrals
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)                     ! Allocate 2D integrals
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
                 Ixe = Ix31; Ixm1 = Ix21
                 Iye = Iy31; Iym1 = Iy21
                 Ize = Iz31; Izm1 = Iz21
                 ce1 = ce
                 do ep1 = 4,.ab_l_sum+1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1,1) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1,1) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1,1) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
                 Ixe = Ix32; Ixm1 = Ix22
                 Iye = Iy32; Iym1 = Iy22
                 Ize = Iz32; Izm1 = Iz22
                 ce1 = ce
                 do e = 3,.ab_l_sum
                   ep1 = e + 1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1 + bb*Ix(e,1); Ix(ep1,2) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1 + bb*Iy(e,1); Iy(ep1,2) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1 + bb*Iz(e,1); Iz(ep1,2) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_pX(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_einv :: REAL
      cf,bb,cf1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix13,Iy13,Iz13 :: REAL
      Ix23,Iy23,Iz23 :: REAL
      Ixf, Iyf, Izf  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      f,fp1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
                 Ixf = Ix13; Ixm1 = Ix12
                 Iyf = Iy13; Iym1 = Iy12
                 Izf = Iz13; Izm1 = Iz12
                 cf1 = cf
                 do fp1 = 4,.cd_l_sum+1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(1,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(1,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(1,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
                 Ixf = Ix23; Ixm1 = Ix22
                 Iyf = Iy23; Iym1 = Iy22
                 Izf = Iz23; Izm1 = Iz22
                 cf1 = cf
                 do f = 3,.cd_l_sum
                   fp1 = f + 1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1 + bb*Ix(1,f); Ix(2,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1 + bb*Iy(1,f); Iy(2,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1 + bb*Iz(1,f); Iz(2,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_Xd(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb,ce1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ixe, Iye, Ize  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      e,f,fm1,ep1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
                 Ixe = Ix31; Ixm1 = Ix21
                 Iye = Iy31; Iym1 = Iy21
                 Ize = Iz31; Izm1 = Iz21
                 ce1 = ce
                 do ep1 = 4,.ab_l_sum+1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1,1) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1,1) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1,1) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
                 Ixe = Ix32; Ixm1 = Ix22
                 Iye = Iy32; Iym1 = Iy22
                 Ize = Iz32; Izm1 = Iz22
                 ce1 = ce
                 do e = 3,.ab_l_sum
                   ep1 = e + 1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1 + bb*Ix(e,1); Ix(ep1,2) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1 + bb*Iy(e,1); Iy(ep1,2) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1 + bb*Iz(e,1); Iz(ep1,2) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 f1_bb = bb
                 do f = 3,.cd_l_sum+1
                   fm1 = f - 1
                   Ix_f => Ix(:,f)
                   Iy_f => Iy(:,f)
                   Iz_f => Iz(:,f)
                   Ix_1 => Ix(:,fm1)
                   Iy_1 => Iy(:,fm1)
                   Iz_1 => Iz(:,fm1)
                   Ixe = Ix_f(2); Ixm1 = Ix_f(1)
                   Iye = Iy_f(2); Iym1 = Iy_f(1)
                   Ize = Iz_f(2); Izm1 = Iz_f(1)
                   f1_bb = f1_bb + bb
                   ce1 = ZERO
                   do e = 2,.ab_l_sum
                     ep1 = e + 1
                     ce1 = ce1 + ce
                     Ixp1 = Ix21*Ixe + ce1*Ixm1 + f1_bb*Ix_1(e); Ix_f(ep1) = Ixp1
                     Iyp1 = Iy21*Iye + ce1*Iym1 + f1_bb*Iy_1(e); Iy_f(ep1) = Iyp1
                     Izp1 = Iz21*Ize + ce1*Izm1 + f1_bb*Iz_1(e); Iz_f(ep1) = Izp1
                     Ixm1 = Ixe; Ixe = Ixp1
                     Iym1 = Iye; Iye = Iyp1
                     Izm1 = Ize; Ize = Izp1
                   end
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_dX(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb,ce1,cf1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      e,f,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
                 Ixf = Ix13; Ixm1 = Ix12
                 Iyf = Iy13; Iym1 = Iy12
                 Izf = Iz13; Izm1 = Iz12
                 cf1 = cf
                 do fp1 = 4,.cd_l_sum+1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(1,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(1,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(1,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
                 Ixf = Ix23; Ixm1 = Ix22
                 Iyf = Iy23; Iym1 = Iy22
                 Izf = Iz23; Izm1 = Iz22
                 cf1 = cf
                 do f = 3,.cd_l_sum
                   fp1 = f + 1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1 + bb*Ix(1,f); Ix(2,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1 + bb*Iy(1,f); Iy(2,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1 + bb*Iz(1,f); Iz(2,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 f1_bb = bb
                 do f = 3,.cd_l_sum+1
                   fm1 = f - 1
                   Ix_f => Ix(:,f)
                   Iy_f => Iy(:,f)
                   Iz_f => Iz(:,f)
                   Ix_1 => Ix(:,fm1)
                   Iy_1 => Iy(:,fm1)
                   Iz_1 => Iz(:,fm1)
                   Ixe = Ix_f(2); Ixm1 = Ix_f(1)
                   Iye = Iy_f(2); Iym1 = Iy_f(1)
                   Ize = Iz_f(2); Izm1 = Iz_f(1)
                   f1_bb = f1_bb + bb
                   ce1 = ZERO
                   do e = 2,.ab_l_sum
                     ep1 = e + 1
                     ce1 = ce1 + ce
                     Ixp1 = Ix21*Ixe + ce1*Ixm1 + f1_bb*Ix_1(e); Ix_f(ep1) = Ixp1
                     Iyp1 = Iy21*Iye + ce1*Iym1 + f1_bb*Iy_1(e); Iy_f(ep1) = Iyp1
                     Izp1 = Iz21*Ize + ce1*Izm1 + f1_bb*Iz_1(e); Iz_f(ep1) = Izp1
                     Ixm1 = Ixe; Ixe = Ixp1
                     Iym1 = Iye; Iye = Iyp1
                     Izm1 = Ize; Ize = Izp1
                   end
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy
   end

   make_esfs_XX(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      Ix,Iy,Iz :: MAT{REAL}*
      Ix_f,Iy_f,Iz_f,Ix_1,Iy_1,Iz_1 :: VEC{REAL}*
      QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
      zeta,eta,xx,ab_cc,cd_cc,rho,zinv,einv,rho_zinv,rho_einv :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb :: REAL
      ce,cf,bb,ce1,cf1 :: REAL
      Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
      Ix31,Iy31,Iz31,Ix13,Iy13,Iz13 :: REAL
      Ix32,Iy32,Iz32,Ix23,Iy23,Iz23 :: REAL
      Ixe, Iye, Ize, Ixf, Iyf, Izf  :: REAL
      Ixm1,Iym1,Izm1,Ixp1,Iyp1,Izp1 :: REAL
      n_roots,dim1,dim2 :: INT
      e,f,fm1,ep1,fp1,n,i,j,k,n_sum :: INT
      rys :: RYS*

      dim1 = .ab_l_sum + 1                            ! Space for 2D integrals
      dim2 = .cd_l_sum + 1
      n_roots = (dim1+dim2)/2
      n_sum = n_roots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
      Ixa.create(n_sum,dim1,dim2)                     ! Allocate 2D integrals
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      rys.create(n_roots)

      i = 0
      do k = 1,.ab_n_gaussian_pairs
         ab_cc = .ab_contraction_prefactor(k)
         zeta = .ab_exponent_sum(k)
         zinv = .ab_exponent_inv(k)
         half_zinv = HALF * zinv
         ab_cc = ab_cc * TWOPI5ON2
         Px = .ab_pair_center(1,k)
         Py = .ab_pair_center(2,k)
         Pz = .ab_pair_center(3,k)
         PAx = .ab_center_diff(1,k)
         PAy = .ab_center_diff(2,k)
         PAz = .ab_center_diff(3,k)
         do j = 1,.cd_n_gaussian_pairs
             cd_cc = .cd_contraction_prefactor(j)
             eta  = .cd_exponent_sum(j)
             einv = .cd_exponent_inv(j)
             Qx = .cd_pair_center(1,j)
             Qy = .cd_pair_center(2,j)
             Qz = .cd_pair_center(3,j)
             QCx = .cd_center_diff(1,j)
             QCy = .cd_center_diff(2,j)
             QCz = .cd_center_diff(3,j)
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
             rys.get_weights(xx)
             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
             ! Now make the 2 dimensional integrals.
             do n = 1,n_roots
               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE
                 t2_rz = t2 * rho_zinv
                 Ix21 = PAx + t2_rz*QPx; Ix(2,1) = Ix21
                 Iy21 = PAy + t2_rz*QPy; Iy(2,1) = Iy21
                 Iz21 = PAz + t2_rz*QPz; Iz(2,1) = Iz21
                 ce  = (ONE - t2_rz) * half_zinv
                 Ix31 = Ix21*Ix21 + ce; Ix(3,1) = Ix31
                 Iy31 = Iy21*Iy21 + ce; Iy(3,1) = Iy31
                 Iz31 = Iz21*Iz21 + ce; Iz(3,1) = Iz31
                 Ixe = Ix31; Ixm1 = Ix21
                 Iye = Iy31; Iym1 = Iy21
                 Ize = Iz31; Izm1 = Iz21
                 ce1 = ce
                 do ep1 = 4,.ab_l_sum+1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1; Ix(ep1,1) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1; Iy(ep1,1) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1; Iz(ep1,1) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 t2_re = t2 * rho_einv
                 Ix12 = QCx - t2_re*QPx; Ix(1,2) = Ix12
                 Iy12 = QCy - t2_re*QPy; Iy(1,2) = Iy12
                 Iz12 = QCz - t2_re*QPz; Iz(1,2) = Iz12
                 cf  = (ONE - t2_re) * half_einv
                 Ix13 = Ix12*Ix12 + cf; Ix(1,3) = Ix13
                 Iy13 = Iy12*Iy12 + cf; Iy(1,3) = Iy13
                 Iz13 = Iz12*Iz12 + cf; Iz(1,3) = Iz13
                 Ixf = Ix13; Ixm1 = Ix12
                 Iyf = Iy13; Iym1 = Iy12
                 Izf = Iz13; Izm1 = Iz12
                 cf1 = cf
                 do fp1 = 4,.cd_l_sum+1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1; Ix(1,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1; Iy(1,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1; Iz(1,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 bb = t2_rz * half_einv
                 Ix22 = Ix12*Ix21 + bb; Ix(2,2) = Ix22
                 Iy22 = Iy12*Iy21 + bb; Iy(2,2) = Iy22
                 Iz22 = Iz12*Iz21 + bb; Iz(2,2) = Iz22
                 Ix23 = Ix12*Ix22 + cf*Ix21 + bb*Ix12; Ix(2,3) = Ix23
                 Iy23 = Iy12*Iy22 + cf*Iy21 + bb*Iy12; Iy(2,3) = Iy23
                 Iz23 = Iz12*Iz22 + cf*Iz21 + bb*Iz12; Iz(2,3) = Iz23
                 Ix32 = Ix21*Ix22 + ce*Ix12 + bb*Ix21; Ix(3,2) = Ix32
                 Iy32 = Iy21*Iy22 + ce*Iy12 + bb*Iy21; Iy(3,2) = Iy32
                 Iz32 = Iz21*Iz22 + ce*Iz12 + bb*Iz21; Iz(3,2) = Iz32
                 Ixf = Ix23; Ixm1 = Ix22
                 Iyf = Iy23; Iym1 = Iy22
                 Izf = Iz23; Izm1 = Iz22
                 cf1 = cf
                 do f = 3,.cd_l_sum
                   fp1 = f + 1
                   cf1 = cf1 + cf
                   Ixp1 = Ix12*Ixf + cf1*Ixm1 + bb*Ix(1,f); Ix(2,fp1) = Ixp1
                   Iyp1 = Iy12*Iyf + cf1*Iym1 + bb*Iy(1,f); Iy(2,fp1) = Iyp1
                   Izp1 = Iz12*Izf + cf1*Izm1 + bb*Iz(1,f); Iz(2,fp1) = Izp1
                   Ixm1 = Ixf; Ixf = Ixp1
                   Iym1 = Iyf; Iyf = Iyp1
                   Izm1 = Izf; Izf = Izp1
                 end
                 Ixe = Ix32; Ixm1 = Ix22
                 Iye = Iy32; Iym1 = Iy22
                 Ize = Iz32; Izm1 = Iz22
                 ce1 = ce
                 do e = 3,.ab_l_sum
                   ep1 = e + 1
                   ce1 = ce1 + ce
                   Ixp1 = Ix21*Ixe + ce1*Ixm1 + bb*Ix(e,1); Ix(ep1,2) = Ixp1
                   Iyp1 = Iy21*Iye + ce1*Iym1 + bb*Iy(e,1); Iy(ep1,2) = Iyp1
                   Izp1 = Iz21*Ize + ce1*Izm1 + bb*Iz(e,1); Iz(ep1,2) = Izp1
                   Ixm1 = Ixe; Ixe = Ixp1
                   Iym1 = Iye; Iye = Iyp1
                   Izm1 = Ize; Ize = Izp1
                 end
                 f1_bb = bb
                 do f = 3,.cd_l_sum+1
                   fm1 = f - 1
                   Ix_f => Ix(:,f)
                   Iy_f => Iy(:,f)
                   Iz_f => Iz(:,f)
                   Ix_1 => Ix(:,fm1)
                   Iy_1 => Iy(:,fm1)
                   Iz_1 => Iz(:,fm1)
                   Ixe = Ix_f(2); Ixm1 = Ix_f(1)
                   Iye = Iy_f(2); Iym1 = Iy_f(1)
                   Ize = Iz_f(2); Izm1 = Iz_f(1)
                   f1_bb = f1_bb + bb
                   ce1 = ZERO
                   do e = 2,.ab_l_sum
                     ep1 = e + 1
                     ce1 = ce1 + ce
                     Ixp1 = Ix21*Ixe + ce1*Ixm1 + f1_bb*Ix_1(e); Ix_f(ep1) = Ixp1
                     Iyp1 = Iy21*Iye + ce1*Iym1 + f1_bb*Iy_1(e); Iy_f(ep1) = Iyp1
                     Izp1 = Iz21*Ize + ce1*Izm1 + f1_bb*Iz_1(e); Iz_f(ep1) = Izp1
                     Ixm1 = Ixe; Ixe = Ixp1
                     Iym1 = Iye; Iye = Iyp1
                     Izm1 = Ize; Ize = Izp1
                   end
                 end
               Iz = Iz * rys.weight(n)
             end
         end     ! -- loops over c,d
      end         ! -- loops over a,b

      rys.destroy

      .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)

      Iza.destroy
      Iya.destroy
      Ixa.destroy

   end

!  ==========================================
!  Form (e0|f0) integrals as sum(Ix*Iy*Iz*wt)
!  ==========================================

   form_esfs(esfs,Ix,Iy,Iz,wt) ::: private
   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
   ! This version does not use the reduced multiplication scheme.
      esfs :: MAT{REAL}(.n_ab,.n_cd), OUT
      self :: IN

      Ix,Iy,Iz :: MAT3{REAL}, IN
      wt :: VEC{REAL}, IN

      ex,ey,ez :: VEC{INT}*
      fx,fy,fz :: VEC{INT}*
      fe,le,ff,lf,e,f,ze,ye,xe,zf,yf,xf :: INT

      if      (.ab_l_max==0 AND .cd_l_max==0) then
        esfs(1,1) = sum(wt)
      else
        fe = .ab_first_gaussian; le = .ab_last_gaussian
        ff = .cd_first_gaussian; lf = .cd_last_gaussian
        ex => GAUSSIAN_DATA::nx(fe:le); ey => GAUSSIAN_DATA::ny(fe:le); ez => GAUSSIAN_DATA::nz(fe:le)
        fx => GAUSSIAN_DATA::nx(ff:lf); fy => GAUSSIAN_DATA::ny(ff:lf); fz => GAUSSIAN_DATA::nz(ff:lf)
        do f = 1,esfs.dim2
           xf = fx(f); yf = fy(f); zf = fz(f)
           do e = 1,esfs.dim1
              xe = ex(e); ye = ey(e); ze = ez(e)
              esfs(e,f) = sum(Ix(:,xe,xf)*Iy(:,ye,yf)*Iz(:,ze,zf))
           end
        end
      end

   end

   form_esss(esfs,Ix,Iy,Iz,wt,n_sum) ::: private
   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
   ! This version does not use the reduced multiplication scheme.
      self :: IN
      esfs :: VEC{REAL}(.n_ab), OUT

      n_sum :: INT, IN
      Ix,Iy,Iz :: MAT{REAL}(n_sum,*), IN
      wt :: VEC{REAL}, IN

      ex,ey,ez :: VEC{INT}*
      fe,le,e,ze,ye,xe :: INT

!     Ixy :: VEC{REAL}*
!     exyz0,eyz0,exz0,exy0,ez0,ey0,ex0,en0,ea0,e0,erms :: VEC{INT}*
!     fxyz0,fyz0,fxz0,fxy0,fz0,fy0,fx0,fn0,fa0,f0,frms :: VEC{INT}*
!     er,fr :: RMS_INDICES*
!     ee,em :: INT

      if      (.ab_l_max==0 AND .cd_l_max==0) then

        esfs(1) = sum(wt)

      else

        fe = .ab_first_gaussian; le = .ab_last_gaussian
        ex => GAUSSIAN_DATA::nx(fe:le)
        ey => GAUSSIAN_DATA::ny(fe:le)
        ez => GAUSSIAN_DATA::nz(fe:le)
        do e = 1,esfs.dim
           xe = ex(e); ye = ey(e); ze = ez(e)
           esfs(e) = sum(Ix(:,xe)*Iy(:,ye)*Iz(:,ze))
        end

!        fe = .ab_first_gaussian; le = .ab_last_gaussian
!        ex => GAUSSIAN_DATA::nx(fe:le)
!        ey => GAUSSIAN_DATA::ny(fe:le)
!        ez => GAUSSIAN_DATA::nz(fe:le)
!        er => GAUSSIAN_DATA::rms_indices(.ab_l_max,.ab_l_min)
!        exyz0 => er.xyz0; en0 => er.n0
!        eyz0  => er.yz0; exz0 => er.xz0; exy0 => er.xy0
!        ez0   => er.z0;  ey0  => er.y0;  ex0  => er.x0
!        do ee = 1,exyz0.dim
!           e  = exyz0(ee)
!           esfs(e) = sum(wt)
!        end
!        do ee = 1,eyz0.dim
!           e  = eyz0(ee)
!           xe = ex(e)
!           esfs(e) = sum(Ix(:,xe)*wt)
!        end
!        do ee = 1,exz0.dim
!           e  = exz0(ee)
!           ye = ey(e)
!           esfs(e) = sum(Iy(:,ye)*wt)
!        end
!        do ee = 1,exy0.dim
!           e  = exy0(ee)
!           ze = ez(e)
!           esfs(e) = sum(Iz(:,ze)   )
!        end
!        do ee = 1,ez0.dim
!           e  = ez0(ee)
!           xe = ex(e)
!           ye = ey(e)
!           esfs(e) = sum(Ix(:,xe)*Iy(:,ye)*wt      )
!        end
!        do ee = 1,ey0.dim
!           e  = ey0(ee)
!           xe = ex(e)
!           ze = ez(e)
!           esfs(e) = sum(Ix(:,xe)         *Iz(:,ze))
!        end
!        do ee = 1,ex0.dim
!           e  = ex0(ee)
!           ye = ey(e)
!           ze = ez(e)
!           esfs(e) = sum(         Iy(:,ye)*Iz(:,ze))
!        end
!        exy_rms => er.xy_rms_n
!        if (exy_rms.dim==en0.dim) then
!           do ee = 1,en0.dim
!              e  = en0(ee)
!              xe = ex(e); ye = ey(e); ze = ez(e)
!              esfs(e) = sum(Ix(:,xe)*Iy(:,ye)*Iz(:,ze))
!           end
!        else if (exy_rms.dim>0) then
!           Ixy.create(Ix.dim1)
!           do ee = 1,exy_rms.dim                 ! Apply (e) RMS here
!              erms => exy_rms(ee).element
!              e  = en0(erms(1))
!              xe = ex(e)
!              ye = ey(e)
!              ze = ez(e)
!              Ixy = Ix(:,xe)*Iy(:,ye)
!              esfs(e) = sum(Ixy*Iz(:,ze))
!              do em = 2,erms.dim
!                 e = en0(erms(em))
!                 ze = ez(e)
!                 esfs(e) = sum(Ixy*Iz(:,ze))
!              end
!           end
!           Ixy.destroy
!        end

      end

   end

   form_ssfs(esfs,Ix,Iy,Iz,wt,n_sum) ::: private
   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
   ! This version does not use the reduced multiplication scheme.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), OUT

      n_sum :: INT, IN
      Ix,Iy,Iz :: MAT{REAL}(n_sum,*), IN
      wt :: VEC{REAL}, IN

      fx,fy,fz :: VEC{INT}*
      ff,lf,f,zf,yf,xf :: INT

!     Ixy :: VEC{REAL}*
!     fxyz0,fyz0,fxz0,fxy0,fz0,fy0,fx0,fn0,fa0,f0,frms :: VEC{INT}*
!     fr :: RMS_INDICES*
!     fxy_rms :: VEC{VEC_{INT}}*
!     fm :: INT

      if (.ab_l_max==0 AND .cd_l_max==0) then

        esfs(1) = sum(wt)

      else

        ff = .cd_first_gaussian; lf = .cd_last_gaussian
        fx => GAUSSIAN_DATA::nx(ff:lf)
        fy => GAUSSIAN_DATA::ny(ff:lf)
        fz => GAUSSIAN_DATA::nz(ff:lf)

        do f = 1,esfs.dim
           xf = fx(f); yf = fy(f); zf = fz(f)
           esfs(f) = sum(Ix(:,xf)*Iy(:,yf)*Iz(:,zf))
        end

!        ff = .cd_first_gaussian; lf = .cd_last_gaussian
!        fx => GAUSSIAN_DATA::nx(ff:lf)
!        fy => GAUSSIAN_DATA::ny(ff:lf)
!        fz => GAUSSIAN_DATA::nz(ff:lf)
!        fr => GAUSSIAN_DATA::rms_indices(.cd_l_max,.cd_l_min)
!        fxyz0 => fr.xyz0; fn0 => fr.n0
!        fyz0  => fr.yz0; fxz0 => fr.xz0; fxy0 => fr.xy0
!        fz0   => fr.z0;  fy0  => fr.y0;  fx0  => fr.x0
!        do ff = 1,fxyz0.dim
!           f  = fxyz0(ff)
!           esfs(f) = sum(wt)
!        end
!        do ff = 1,fyz0.dim
!           f  = fyz0(ff)
!           xf = fx(f)
!           esfs(f) = sum(Ix(:,xf)*wt)
!        end
!        do ff = 1,fxz0.dim
!           f  = fxz0(ff)
!           yf = fy(f)
!           esfs(f) = sum(Iy(:,yf)*wt)
!        end
!        do ff = 1,fxy0.dim
!           f  = fxy0(ff)
!           zf = fz(f)
!           esfs(f) = sum(Iz(:,zf)   )
!        end
!        do ff = 1,fz0.dim
!           f  = fz0(ff)
!           xf = fx(f)
!           yf = fy(f)
!           esfs(f) = sum(Ix(:,xf)*Iy(:,yf)*wt      )
!        end
!        do ff = 1,fy0.dim
!           f  = fy0(ff)
!           xf = fx(f)
!           zf = fz(f)
!           esfs(f) = sum(Ix(:,xf)         *Iz(:,zf))
!        end
!        do ff = 1,fx0.dim
!           f  = fx0(ff)
!           yf = fy(f)
!           zf = fz(f)
!           esfs(f) = sum(         Iy(:,yf)*Iz(:,zf))
!        end
!        fxy_rms => fr.xy_rms_n
!        if (fxy_rms.dim==fn0.dim) then
!           do ff = 1,fn0.dim
!              f  = fn0(ff)
!              xf = fx(f); yf = fy(f); zf = fz(f)
!              esfs(f) = sum(Ix(:,xf)*Iy(:,yf)*Iz(:,zf))
!           end
!        else if (fxy_rms.dim>0) then
!           Ixy.create(Ix.dim1)
!           do ff = 1,fxy_rms.dim                 ! Apply (f) RMS here
!              frms => fxy_rms(ff).element
!              f  = fn0(frms(1))
!              xf = fx(f)
!              yf = fy(f)
!              zf = fz(f)
!              Ixy = Ix(:,xf)*Iy(:,yf)
!              esfs(f) = sum(Ixy*Iz(:,zf))
!              do fm = 2,frms.dim
!                 f = fn0(frms(fm))
!                 zf = fz(f)
!                 esfs(f) = sum(Ixy*Iz(:,zf))
!              end
!           end
!           Ixy.destroy
!        end
      end
   end

!   form_esfs_rms2(esfs,Ix,Iy,Iz,wt,n_sum,dim1,dim2) ::: private
!   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
!   ! This version does not use the reduced multiplication scheme.
!      self :: IN
!      esfs :: VEC{REAL}(.n_ab*.n_cd), OUT
!      Ix,Iy :: MAT{REAL}(n_sum,dim1*dim2), target, IN
!      Iz :: MAT{REAL}(n_sum,dim1*dim2), IN
!      wt :: VEC{REAL}(n_sum), IN
!      n_sum,dim1,dim2 :: INT, IN
!
!      Ixy :: VEC{REAL}*
!      do_Ixy_is_x,do_Ixy_is_y,do_Ixy :: VEC{BIN}*
!      ef,efx,efy,efz :: VEC{INT}*
!      rms2 :: RMS2_INDICES*
!      i,n1,nx,ny,n :: INT
!
!      if (.ab_l_max==0 AND .cd_l_max==0) then
!
!        esfs(1) = sum(wt)
!
!      else
!
!      ! rms2 => GAUSSIAN_DATA::rms2_indices(.ab_l_max,.ab_l_min,.cd_l_max,.cd_l_min)
!        rms2 => GAUSSIAN_DATA::rms2_indices(.ab_l_tri,.cd_l_tri)
!        ef  => rms2.ef
!        efx => rms2.efx
!        efy => rms2.efy
!        efz => rms2.efz
!        do_Ixy_is_x => rms2.do_Ixy_is_x
!        do_Ixy_is_y => rms2.do_Ixy_is_y
!        do_Ixy      => rms2.do_Ixy
!        n1 = rms2.no_Ixy_is_1
!        nx = rms2.no_Ixy_is_x
!        ny = rms2.no_Ixy_is_y
!        n  = esfs.dim
!        do i = 1,n1
!           esfs(ef(i)) = sum(Iz(:,efz(i)))
!        end
!        do i = n1+1,nx
!           if (do_Ixy_is_x(i)) Ixy => Ix(:,efx(i))
!           esfs(ef(i)) = sum(Ixy*Iz(:,efz(i)))
!        end
!        do i = nx+1,ny
!           if (do_Ixy_is_y(i)) Ixy => Iy(:,efy(i))
!           esfs(ef(i)) = sum(Ixy*Iz(:,efz(i)))
!        end
!        Ixy.create(Ix.dim1)
!        do i = ny+1,n
!           if (do_Ixy(i)) Ixy = Ix(:,efx(i))*Iy(:,efy(i))
!           esfs(ef(i)) = sum(Ixy*Iz(:,efz(i)))
!        end
!        Ixy.destroy
!
!      end
!
!   end

!   form_esfs_rms2(esfs,Ix,Iy,Iz,wt,n_sum,dim1,dim2) ::: private
!   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
!   ! This version does not use the reduced multiplication scheme.
!     self :: IN
!     esfs :: MAT{REAL}(.n_ab,.n_cd), OUT
!     n_sum,dim1,dim2 :: INT, IN
!     Ix,Iy,Iz :: MAT3{REAL}(n_sum,dim1,dim2), target, IN
!     wt :: VEC{REAL}(n_sum), IN
!     Ixy :: VEC{REAL}*
!     Ixy_is_1,Ixy_is_x,Ixy_is_y,Ixy_is_p :: VEC{INT}*
!     ee,ex,ey,ez, ff,fx,fy,fz :: VEC{INT}*
!     rms2 :: RMS2_INDICES*
!     k,nr,i1,i2,ir,e,f,ze,ye,xe,zf,yf,xf :: INT
!     if      (.ab_l_max==0 AND .cd_l_max==0) then
!        esfs(1,1) = sum(wt)
!     else
!        rms2 => GAUSSIAN_DATA::rms2_indices(.ab_l_max,.ab_l_min,.cd_l_max,.cd_l_min)
!        ee => rms2.e;  ff => rms2.f
!        ex => rms2.ex; ey => rms2.ey; ez => rms2.ez
!        fx => rms2.fx; fy => rms2.fy; fz => rms2.fz
!        Ixy_is_1 => rms2.Ixy_is_1
!        Ixy_is_x => rms2.Ixy_is_x
!        Ixy_is_y => rms2.Ixy_is_y
!        Ixy_is_p => rms2.Ixy_is_p
!        i2 = 0
!        do k = 1,Ixy_is_1.dim1
!           nr = Ixy_is_1(k)
!           i1 = i2 + 1
!           i2 = i2 + nr
!           do ir = i1,i2
!              e  = ee(ir); f  = ff(ir)
!              ze = ez(ir)
!              zf = fz(ir)
!              esfs(e,f) = sum(Iz(:,ze,zf))
!           end
!        end
!        do k = 1,Ixy_is_x.dim1
!           nr = Ixy_is_x(k)
!           i1 = i2 + 1
!           i2 = i2 + nr
!           e  = ee(i1); f  = ff(i1)
!           xe = ex(i1); ze = ez(i1)
!           xf = fx(i1); zf = fz(i1)
!           Ixy => Ix(:,xe,xf)
!           esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           do ir = i1+1,i2
!              e  = ee(ir); f  = ff(ir)
!              ze = ez(ir)
!              zf = fz(ir)
!              esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           end
!        end
!        do k = 1,Ixy_is_y.dim
!           nr = Ixy_is_y(k)
!           i1 = i2 + 1
!           i2 = i2 + nr
!           e  = ee(i1); f  = ff(i1)
!           ye = ey(i1); ze = ez(i1)
!           yf = fy(i1); zf = fz(i1)
!           Ixy => Iy(:,ye,yf)
!           esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           do ir = i1+1,i2
!              e  = ee(ir); f  = ff(ir)
!              ze = ez(ir)
!              zf = fz(ir)
!              esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           end
!        end
!        Ixy.create(Ix.dim1)
!        do k = 1,Ixy_is_p.dim
!           nr = Ixy_is_p(k)
!           i1 = i2 + 1
!           i2 = i2 + nr
!           e  = ee(i1); f  = ff(i1)
!           xe = ex(i1); ye = ey(i1); ze = ez(i1)
!           xf = fx(i1); yf = fy(i1); zf = fz(i1)
!           Ixy = Ix(:,xe,xf)*Iy(:,ye,yf)
!           esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           do ir = i1+1,i2
!              e  = ee(ir); f  = ff(ir)
!              ze = ez(ir)
!              zf = fz(ir)
!              esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!           end
!        end
!        Ixy.destroy
!     end
!   end

!   form_esfs(esfs,Ix,Iy,Iz,wt) ::: private
!   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
!   ! This version does not use the reduced multiplication scheme.
!     esfs :: MAT{REAL}, OUT
!     self :: IN
!     Ix,Iy,Iz :: MAT3{REAL}, IN
!     wt :: VEC{REAL}, IN
!     Ixy :: VEC{REAL}*
!     ex,ey,ez, exyz0,eyz0,exz0,exy0,ez0,ey0,ex0,en0,ea0,e0,erms :: VEC{INT}*
!     fx,fy,fz, fxyz0,fyz0,fxz0,fxy0,fz0,fy0,fx0,fn0,fa0,f0,frms :: VEC{INT}*
!     fxy_rms,exy_rms :: VEC{VEC_{INT}}*
!     er,fr :: RMS_INDICES*
!     fe,le,ff,lf,e,f,ee,   ze,ye,xe,zf,yf,xf,fs,es,fm,em :: INT
!     xe1,ye1,xf1,yf1,xye1,xyf1,xy1 :: BIN
!     if      (.ab_l_max==0 AND .cd_l_max==0) then
!        esfs(1,1) = sum(wt)
!     else if (.ab_l_max==0) then
!        ff = .cd_first_gaussian; lf = .cd_last_gaussian
!        fx => GAUSSIAN_DATA::nx(ff:lf)
!        fy => GAUSSIAN_DATA::ny(ff:lf)
!        fz => GAUSSIAN_DATA::nz(ff:lf)
!        fr => GAUSSIAN_DATA::rms_indices(.cd_l_max,.cd_l_min)
!        fxyz0 => fr.xyz0; fn0 => fr.n0
!        fyz0  => fr.yz0; fxz0 => fr.xz0; fxy0 => fr.xy0
!        fz0   => fr.z0;  fy0  => fr.y0;  fx0  => fr.x0
!        do ff = 1,fxyz0.dim
!           f  = fxyz0(ff)
!           esfs(1,f) = sum(wt)
!        end
!        do ff = 1,fyz0.dim
!           f  = fyz0(ff)
!           xf = fx(f)
!           esfs(1,f) = sum(Ix(:,1,xf)*wt)
!        end
!        do ff = 1,fxz0.dim
!           f  = fxz0(ff)
!           yf = fy(f)
!           esfs(1,f) = sum(Iy(:,1,yf)*wt)
!        end
!        do ff = 1,fxy0.dim
!           f  = fxy0(ff)
!           zf = fz(f)
!           esfs(1,f) = sum(Iz(:,1,zf)   )
!        end
!        do ff = 1,fz0.dim
!           f  = fz0(ff)
!           xf = fx(f)
!           yf = fy(f)
!           esfs(1,f) = sum(Ix(:,1,xf)*Iy(:,1,yf)*wt      )
!        end
!        do ff = 1,fy0.dim
!           f  = fy0(ff)
!           xf = fx(f)
!           zf = fz(f)
!           esfs(1,f) = sum(Ix(:,1,xf)         *Iz(:,1,zf))
!        end
!        do ff = 1,fx0.dim
!           f  = fx0(ff)
!           yf = fy(f)
!           zf = fz(f)
!           esfs(1,f) = sum(         Iy(:,1,yf)*Iz(:,1,zf))
!        end
!        fxy_rms => fr.xy_rms_n
!        if (fxy_rms.dim==fn0.dim) then
!           do ff = 1,fn0.dim
!              f  = fn0(ff)
!              xf = fx(f); yf = fy(f); zf = fz(f)
!              esfs(1,f) = sum(Ix(:,1,xf)*Iy(:,1,yf)*Iz(:,1,zf))
!           end
!        else if (fxy_rms.dim>0) then
!           Ixy.create(Ix.dim1)
!           do ff = 1,fxy_rms.dim                 ! Apply (f) RMS here
!              frms => fxy_rms(ff).element
!              f  = fn0(frms(1))
!              xf = fx(f)
!              yf = fy(f)
!              zf = fz(f)
!              Ixy = Ix(:,1,xf)*Iy(:,1,yf)
!              esfs(1,f) = sum(Ixy*Iz(:,1,zf))
!              do fm = 2,frms.dim
!                 f = fn0(frms(fm))
!                 zf = fz(f)
!                 esfs(1,f) = sum(Ixy*Iz(:,1,zf))
!              end
!           end
!           Ixy.destroy
!        end
!     else if (.cd_l_max==0) then
!        fe = .ab_first_gaussian; le = .ab_last_gaussian
!        ex => GAUSSIAN_DATA::nx(fe:le)
!        ey => GAUSSIAN_DATA::ny(fe:le)
!        ez => GAUSSIAN_DATA::nz(fe:le)
!        er => rms_indices(.ab_l_max,.ab_l_min)
!        exyz0 => er.xyz0; en0 => er.n0
!        eyz0  => er.yz0; exz0 => er.xz0; exy0 => er.xy0
!        ez0   => er.z0;  ey0  => er.y0;  ex0  => er.x0
!        do ee = 1,exyz0.dim
!           e  = exyz0(ee)
!           esfs(e,1) = sum(wt)
!        end
!        do ee = 1,eyz0.dim
!           e  = eyz0(ee)
!           xe = ex(e)
!           esfs(e,1) = sum(Ix(:,xe,1)*wt)
!        end
!        do ee = 1,exz0.dim
!           e  = exz0(ee)
!           ye = ey(e)
!           esfs(e,1) = sum(Iy(:,ye,1)*wt)
!        end
!        do ee = 1,exy0.dim
!           e  = exy0(ee)
!           ze = ez(e)
!           esfs(e,1) = sum(Iz(:,ze,1)   )
!        end
!        do ee = 1,ez0.dim
!           e  = ez0(ee)
!           xe = ex(e)
!           ye = ey(e)
!           esfs(e,1) = sum(Ix(:,xe,1)*Iy(:,ye,1)*wt      )
!        end
!        do ee = 1,ey0.dim
!           e  = ey0(ee)
!           xe = ex(e)
!           ze = ez(e)
!           esfs(e,1) = sum(Ix(:,xe,1)         *Iz(:,ze,1))
!        end
!        do ee = 1,ex0.dim
!           e  = ex0(ee)
!           ye = ey(e)
!           ze = ez(e)
!           esfs(e,1) = sum(         Iy(:,ye,1)*Iz(:,ze,1))
!        end
!        exy_rms => er.xy_rms_n
!        if (exy_rms.dim==en0.dim) then
!           do ee = 1,en0.dim
!              e  = en0(ee)
!              xe = ex(e); ye = ey(e); ze = ez(e)
!              esfs(e,1) = sum(Ix(:,xe,1)*Iy(:,ye,1)*Iz(:,ze,1))
!           end
!        else if (exy_rms.dim>0) then
!           Ixy.create(Ix.dim1)
!           do ee = 1,exy_rms.dim                 ! Apply (e) RMS here
!              erms => exy_rms(ee).element
!              e  = en0(erms(1))
!              xe = ex(e)
!              ye = ey(e)
!              ze = ez(e)
!              Ixy = Ix(:,xe,1)*Iy(:,ye,1)
!              esfs(e,1) = sum(Ixy*Iz(:,ze,1))
!              do em = 2,erms.dim
!                 e = en0(erms(em))
!                 ze = ez(e)
!                 esfs(e,1) = sum(Ixy*Iz(:,ze,1))
!              end
!           end
!           Ixy.destroy
!        end
!     else
!        fe = .ab_first_gaussian; le = .ab_last_gaussian
!        ff = .cd_first_gaussian; lf = .cd_last_gaussian
!        ex => nx(fe:le); ey => ny(fe:le); ez => nz(fe:le)
!        fx => nx(ff:lf); fy => ny(ff:lf); fz => nz(ff:lf)
!        do f = 1,esfs.dim2
!           xf = fx(f); yf = fy(f); zf = fz(f)
!           do e = 1,esfs.dim1
!              xe = ex(e); ye = ey(e); ze = ez(e)
!              esfs(e,f) = sum(Ix(:,xe,xf)*Iy(:,ye,yf)*Iz(:,ze,zf))
!           end
!        end
!    return
!        er => GAUSSIAN_DATA::rms_indices(.ab_l_max,.ab_l_min)
!        fr => GAUSSIAN_DATA::rms_indices(.cd_l_max,.cd_l_min)
!        en0 => er.n0; ea0 => er.a0
!        fn0 => fr.n0; fa0 => fr.a0
!        fxy_rms => fr.xy_rms_n
!        exy_rms => er.xy_rms_n
!        f0 => fn0
!        e0 => en0
!        Ixy.create(Ix.dim1)
!        do fs = 1,fxy_rms.dim                            ! Apply (f) RMS here
!           frms => fxy_rms(fs).element
!           f = f0(frms(1))
!           xf  = fx(f); yf = fy(f)
!           do es = 1,exy_rms.dim                         ! Apply (e) RMS here
!              erms => exy_rms(es).element
!              e = e0(erms(1))
!              xe  = ex(e); ye  = ey(e)
!              Ixy = Ix(:,xe,xf)*Iy(:,ye,yf)
!              do fm = 1,frms.dim
!                 f = f0(frms(fm))
!                 zf = fz(f)
!                 do em = 1,erms.dim
!                    e = e0(erms(em))
!                    ze = ez(e)
!                    esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!                 end
!              end
!           end
!        end
!        fxy_rms => fr.xy_rms_a
!        exy_rms => er.xy_rms_n
!        f0 => fa0
!        e0 => en0
!        do fs = 1,fxy_rms.dim                            ! Apply (f) RMS here
!           frms => fxy_rms(fs).element
!           f = f0(frms(1))
!           xf  = fx(f); yf = fy(f)
!           do es = 1,exy_rms.dim                         ! Apply (e) RMS here
!              erms => exy_rms(es).element
!              e = e0(erms(1))
!              xe  = ex(e); ye  = ey(e)
!              Ixy = Ix(:,xe,xf)*Iy(:,ye,yf)
!              do fm = 1,frms.dim
!                 f = f0(frms(fm))
!                 zf = fz(f)
!                 do em = 1,erms.dim
!                    e = e0(erms(em))
!                    ze = ez(e)
!                    esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!                 end
!              end
!           end
!        end
!        fxy_rms => fr.xy_rms_n
!        exy_rms => er.xy_rms_a
!        f0 => fn0
!        e0 => ea0
!        do fs = 1,fxy_rms.dim                            ! Apply (f) RMS here
!           frms => fxy_rms(fs).element
!           f = f0(frms(1))
!           xf  = fx(f); yf = fy(f)
!           do es = 1,exy_rms.dim                         ! Apply (e) RMS here
!              erms => exy_rms(es).element
!              e = e0(erms(1))
!              xe  = ex(e); ye  = ey(e)
!              Ixy = Ix(:,xe,xf)*Iy(:,ye,yf)
!              do fm = 1,frms.dim
!                 f = f0(frms(fm))
!                 zf = fz(f)
!                 do em = 1,erms.dim
!                    e = e0(erms(em))
!                    ze = ez(e)
!                    esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!                 end
!              end
!           end
!        end
!        fxy_rms => fr.xy_rms_a
!        exy_rms => er.xy_rms_a
!        f0 => fa0
!        e0 => ea0
!        do fs = 1,fxy_rms.dim                            ! Apply (f) RMS here
!           frms => fxy_rms(fs).element
!           f = f0(frms(1))
!           xf  = fx(f); yf = fy(f)
!           xf1 = xf==1; yf1 = yf==1
!           xyf1 = xf1 AND yf1
!           do es = 1,exy_rms.dim                         ! Apply (e) RMS here
!              erms => exy_rms(es).element
!              e = e0(erms(1))
!              xe  = ex(e); ye  = ey(e)
!              xe1 = xe==1; ye1 = ye==1                   ! Eliminate unity factors
!              xye1 = xe1  AND ye1
!              xy1  = xyf1 AND xye1
!              if      (    xy1    ) then; ! both factors are one
!              else if (xe1 AND xf1) then; Ixy = Iy(:,ye,yf)
!              else if (ye1 AND yf1) then; Ixy = Ix(:,xe,xf)
!              else;                       Ixy = Ix(:,xe,xf) * Iy(:,ye,yf)
!              end
!              do fm = 1,frms.dim
!                 f = f0(frms(fm))
!                 zf = fz(f)
!                 do em = 1,erms.dim
!                    e = e0(erms(em))
!                    ze = ez(e)
!                    if (xy1) then; esfs(e,f) = sum(    Iz(:,ze,zf))
!                    else;          esfs(e,f) = sum(Ixy*Iz(:,ze,zf))
!                    end
!                 end
!              end
!           end
!        end
!        Ixy.destroy
!     end
!   end

!  ==================
!  Transfer relations
!  ==================

   transfer_cd(esfs,escd)
   ! Applies the transfer equation to (es|fs) to give (es|cd)
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

      if (.cd_same_center) then

        if (.c.l > .d.l) then; .transfer_l_c_same(esfs,escd)
        else;                  .transfer_l_d_same(esfs,escd)
        end

      else

        if (.c.l > .d.l) then; .transfer_l_c_high(esfs,escd)
        else;                  .transfer_l_d_high(esfs,escd)
        end

      end

   end

   transfer_l_c_same(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and c has high momentum.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      e,c,d,c1,c2,c3,cc,d1,l,ne,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,:,1) = esfs

        case (1)
           ne = esfs.dim1
           if (.c.l==1) then                      ! (es|pp) case
              do e = 1,ne
                 escd(e,1,1) = esfs(e,4)
                 escd(e,1,2) = esfs(e,7)
                 escd(e,1,3) = esfs(e,8)
                 escd(e,2,1) = esfs(e,7)
                 escd(e,2,2) = esfs(e,5)
                 escd(e,2,3) = esfs(e,9)
                 escd(e,3,1) = esfs(e,8)
                 escd(e,3,2) = esfs(e,9)
                 escd(e,3,3) = esfs(e,6)
              end
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                                        ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                 do e = 1,ne
                    escd(e,c,1) = esfs(e,c1)
                    escd(e,c,2) = esfs(e,c2)
                    escd(e,c,3) = esfs(e,c3)
                 end
              end
           end

        case default                              ! general (es|cd) case
           ne = esfs.dim1
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = esfs.dim2 - GAUSSIAN_DATA:n_comp(.cd_l_sum)     ! No. of c's in int_new goes down
           int_new.create(ne,nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                 do e = 1,ne
                    int_new(e,c,1) = esfs(e,c1)
                    int_new(e,c,2) = esfs(e,c2)
                    int_new(e,c,3) = esfs(e,c3)
                 end
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(ne,nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                    do e = 1,ne
                       int_new(e,c,d) = int_old(e,c1,d1)
                    end
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                    do e = 1,ne
                       escd(e,c,d) = int_old(e,c1,d1)
                    end
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_d_same(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and d has high momentum.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      e,c,d,c1,d1,d2,d3,dd,l,ne,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(:,1,:) = esfs

        case (1)
           ne = esfs.dim1
           if (.d.l==1) then                      ! (es|pp) case
              do e = 1,ne
                 escd(e,1,1) = esfs(e,4)
                 escd(e,2,1) = esfs(e,7)
                 escd(e,3,1) = esfs(e,8)
                 escd(e,1,2) = esfs(e,7)
                 escd(e,2,2) = esfs(e,5)
                 escd(e,3,2) = esfs(e,9)
                 escd(e,1,3) = esfs(e,8)
                 escd(e,2,3) = esfs(e,9)
                 escd(e,3,3) = esfs(e,6)
              end
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                                        ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                 do e = 1,ne
                    escd(e,1,d) = esfs(e,d1)
                    escd(e,2,d) = esfs(e,d2)
                    escd(e,3,d) = esfs(e,d3)
                 end
              end
           end

        case default                              ! general (es|cd) case
           ne = esfs.dim1
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = esfs.dim2 - GAUSSIAN_DATA:n_comp(.cd_l_sum)     ! No. of d's in int_new goes down
           int_new.create(ne,nd,3)                ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                 do e = 1,ne
                    int_new(e,d,1) = esfs(e,d1)
                    int_new(e,d,2) = esfs(e,d2)
                    int_new(e,d,3) = esfs(e,d3)
                 end
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(ne,nd,nc)            ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                    do e = 1,ne
                       int_new(e,d,c) = int_old(e,d1,c1)
                    end
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                    do e = 1,ne
                       escd(e,c,d) = int_old(e,d1,c1)
                    end
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_c_high(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell c has the higher
   ! angular momentum.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ec :: REAL
      e,c,d,c1,c2,c3,cc,d1,l,ne,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,:,1) = esfs

        case (1)
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           ne = esfs.dim1
           if (.c.l==1) then                      ! (es|pp) case
              do e = 1,ne
                 esfs_ec = esfs(e,1)
                 escd(e,1,1) = esfs(e,4) + R1*esfs_ec
                 escd(e,1,2) = esfs(e,7) + R2*esfs_ec
                 escd(e,1,3) = esfs(e,8) + R3*esfs_ec
                 esfs_ec = esfs(e,2)
                 escd(e,2,1) = esfs(e,7) + R1*esfs_ec
                 escd(e,2,2) = esfs(e,5) + R2*esfs_ec
                 escd(e,2,3) = esfs(e,9) + R3*esfs_ec
                 esfs_ec = esfs(e,3)
                 escd(e,3,1) = esfs(e,8) + R1*esfs_ec
                 escd(e,3,2) = esfs(e,9) + R2*esfs_ec
                 escd(e,3,3) = esfs(e,6) + R3*esfs_ec
              end
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                 do e = 1,ne
                    esfs_ec = esfs(e,c)
                    escd(e,c,1) = esfs(e,c1) + R1*esfs_ec
                    escd(e,c,2) = esfs(e,c2) + R2*esfs_ec
                    escd(e,c,3) = esfs(e,c3) + R3*esfs_ec
                 end
              end
           end

        case default                              ! general (es|cd) case
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           ne = esfs.dim1
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = esfs.dim2 - GAUSSIAN_DATA:n_comp(.cd_l_sum)     ! No. of c's in int_new goes down
           int_new.create(ne,nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                 do e = 1,ne
                    esfs_ec = esfs(e,c)
                    int_new(e,c,1) = esfs(e,c1) + R1*esfs_ec
                    int_new(e,c,2) = esfs(e,c2) + R2*esfs_ec
                    int_new(e,c,3) = esfs(e,c3) + R3*esfs_ec
                 end
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(ne,nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                    do e = 1,ne
                       int_new(e,c,d) = int_old(e,c1,d1) + Rt*int_old(e,c,d1)
                    end
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                    do e = 1,ne
                       escd(e,c,d) = int_old(e,c1,d1) + Rt*int_old(e,c,d1)
                    end
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_d_high(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell d has the higher
   ! angular momentum.
      self :: IN
      esfs :: MAT{REAL}(.n_ab,.n_cd), IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ed :: REAL
      e,c,d,c1,d1,d2,d3,dd,l,ne,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(:,1,:) = esfs

        case (1)
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           ne = esfs.dim1
           if (.d.l==1) then                      ! (es|pp) case
              do e = 1,ne
                 esfs_ed = esfs(e,1)
                 escd(e,1,1) = esfs(e,4) + R1*esfs_ed
                 escd(e,2,1) = esfs(e,7) + R2*esfs_ed
                 escd(e,3,1) = esfs(e,8) + R3*esfs_ed
                 esfs_ed = esfs(e,2)
                 escd(e,1,2) = esfs(e,7) + R1*esfs_ed
                 escd(e,2,2) = esfs(e,5) + R2*esfs_ed
                 escd(e,3,2) = esfs(e,9) + R3*esfs_ed
                 esfs_ed = esfs(e,3)
                 escd(e,1,3) = esfs(e,8) + R1*esfs_ed
                 escd(e,2,3) = esfs(e,9) + R2*esfs_ed
                 escd(e,3,3) = esfs(e,6) + R3*esfs_ed
              end
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                 do e = 1,ne
                    esfs_ed = esfs(e,d)
                    escd(e,1,d) = esfs(e,d1) + R1*esfs_ed
                    escd(e,2,d) = esfs(e,d2) + R2*esfs_ed
                    escd(e,3,d) = esfs(e,d3) + R3*esfs_ed
                 end
              end
           end

        case default                              ! general (es|cd) case
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           ne = esfs.dim1
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = esfs.dim2 - GAUSSIAN_DATA:n_comp(.cd_l_sum)     ! No. of d's in int_new goes down
           int_new.create(ne,nd,3)                ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                 do e = 1,ne
                    esfs_ed = esfs(e,d)
                    int_new(e,d,1) = esfs(e,d1) + R1*esfs_ed
                    int_new(e,d,2) = esfs(e,d2) + R2*esfs_ed
                    int_new(e,d,3) = esfs(e,d3) + R3*esfs_ed
                 end
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(ne,nd,nc)            ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                    do e = 1,ne
                       int_new(e,d,c) = int_old(e,d1,c1) + Rt*int_old(e,d,c1)
                    end
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                    do e = 1,ne
                       escd(e,c,d) = int_old(e,d1,c1) + Rt*int_old(e,d,c1)
                    end
                 end
               end
               int_old.destroy
        end ! case statement

   end


   transfer_cd_s(esfs,escd)
   ! Applies the transfer equation to (es|fs) to give (es|cd)
   ! in the case when e=s.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

      if (.cd_same_center) then

        if (.c.l > .d.l) then; .transfer_l_c_same_s(esfs,escd)
        else;                  .transfer_l_d_same_s(esfs,escd)
        end

      else

        if (.c.l > .d.l) then; .transfer_l_c_high_s(esfs,escd)
        else;                  .transfer_l_d_high_s(esfs,escd)
        end

      end

   end

   transfer_l_c_same_s(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and c has high momentum. This version is when .n_ab is 1.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      c,d,c1,c2,c3,cc,d1,l,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,1) = esfs

        case (1)
           if (.c.l==1) then                      ! (es|pp) case
                 escd(1,1) = esfs(4)
                 escd(1,2) = esfs(7)
                 escd(1,3) = esfs(8)
                 escd(2,1) = esfs(7)
                 escd(2,2) = esfs(5)
                 escd(2,3) = esfs(9)
                 escd(3,1) = esfs(8)
                 escd(3,2) = esfs(9)
                 escd(3,3) = esfs(6)
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    escd(c,1) = esfs(c1)
                    escd(c,2) = esfs(c2)
                    escd(c,3) = esfs(c3)
              end
           end

        case default                              ! general (es|cd) case
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of c's in int_new goes down
           int_new.create(nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    int_new(c,1) = esfs(c1)
                    int_new(c,2) = esfs(c2)
                    int_new(c,3) = esfs(c3)
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       int_new(c,d) = int_old(c1,d1)
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       escd(c,d) = int_old(c1,d1)
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_d_same_s(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and d has high momentum.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      c,d,c1,d1,d2,d3,dd,l,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(1,:) = esfs

        case (1)
           if (.d.l==1) then                      ! (es|pp) case
                 escd(1,1) = esfs(4)
                 escd(2,1) = esfs(7)
                 escd(3,1) = esfs(8)
                 escd(1,2) = esfs(7)
                 escd(2,2) = esfs(5)
                 escd(3,2) = esfs(9)
                 escd(1,3) = esfs(8)
                 escd(2,3) = esfs(9)
                 escd(3,3) = esfs(6)
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    escd(1,d) = esfs(d1)
                    escd(2,d) = esfs(d2)
                    escd(3,d) = esfs(d3)
              end
           end

        case default                              ! general (es|cd) case
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of d's in int_new goes down
           int_new.create(nd,3)                   ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    int_new(d,1) = esfs(d1)
                    int_new(d,2) = esfs(d2)
                    int_new(d,3) = esfs(d3)
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(nd,nc)               ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       int_new(d,c) = int_old(d1,c1)
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       escd(c,d) = int_old(d1,c1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_c_high_s(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell c has the higher
   ! angular momentum.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ec :: REAL
      c,d,c1,c2,c3,cc,d1,l,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,1) = esfs

        case (1)
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.c.l==1) then                      ! (es|pp) case
                 esfs_ec = esfs(1)
                 escd(1,1) = esfs(4) + R1*esfs_ec
                 escd(1,2) = esfs(7) + R2*esfs_ec
                 escd(1,3) = esfs(8) + R3*esfs_ec
                 esfs_ec = esfs(2)
                 escd(2,1) = esfs(7) + R1*esfs_ec
                 escd(2,2) = esfs(5) + R2*esfs_ec
                 escd(2,3) = esfs(9) + R3*esfs_ec
                 esfs_ec = esfs(3)
                 escd(3,1) = esfs(8) + R1*esfs_ec
                 escd(3,2) = esfs(9) + R2*esfs_ec
                 escd(3,3) = esfs(6) + R3*esfs_ec
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    esfs_ec = esfs(c)
                    escd(c,1) = esfs(c1) + R1*esfs_ec
                    escd(c,2) = esfs(c2) + R2*esfs_ec
                    escd(c,3) = esfs(c3) + R3*esfs_ec
              end
           end

        case default                              ! general (es|cd) case
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of c's in int_new goes down
           int_new.create(nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    esfs_ec = esfs(c)
                    int_new(c,1) = esfs(c1) + R1*esfs_ec
                    int_new(c,2) = esfs(c2) + R2*esfs_ec
                    int_new(c,3) = esfs(c3) + R3*esfs_ec
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       int_new(c,d) = int_old(c1,d1) + Rt*int_old(c,d1)
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       escd(c,d) = int_old(c1,d1) + Rt*int_old(c,d1)
                 end
              end
              int_old.destroy

        end ! case statement

   end

   transfer_l_d_high_s(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell d has the higher
   ! angular momentum.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ed :: REAL
      c,d,c1,d1,d2,d3,dd,l,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(1,:) = esfs

        case (1)
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.d.l==1) then                      ! (es|pp) case
                 esfs_ed = esfs(1)
                 escd(1,1) = esfs(4) + R1*esfs_ed
                 escd(2,1) = esfs(7) + R2*esfs_ed
                 escd(3,1) = esfs(8) + R3*esfs_ed
                 esfs_ed = esfs(2)
                 escd(1,2) = esfs(7) + R1*esfs_ed
                 escd(2,2) = esfs(5) + R2*esfs_ed
                 escd(3,2) = esfs(9) + R3*esfs_ed
                 esfs_ed = esfs(3)
                 escd(1,3) = esfs(8) + R1*esfs_ed
                 escd(2,3) = esfs(9) + R2*esfs_ed
                 escd(3,3) = esfs(6) + R3*esfs_ed
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    esfs_ed = esfs(d)
                    escd(1,d) = esfs(d1) + R1*esfs_ed
                    escd(2,d) = esfs(d2) + R2*esfs_ed
                    escd(3,d) = esfs(d3) + R3*esfs_ed
              end
           end

        case default                              ! general (es|cd) case
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of d's in int_new goes down
           int_new.create(nd,3)                   ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    esfs_ed = esfs(d)
                    int_new(d,1) = esfs(d1) + R1*esfs_ed
                    int_new(d,2) = esfs(d2) + R2*esfs_ed
                    int_new(d,3) = esfs(d3) + R3*esfs_ed
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(nd,nc)               ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       int_new(d,c) = int_old(d1,c1) + Rt*int_old(d,c1)
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       escd(c,d) = int_old(d1,c1) + Rt*int_old(d,c1)
                 end
               end
               int_old.destroy

        end ! case statement

   end


   transfer_cd_s_add(esfs,escd)
   ! Applies the transfer equation to (es|fs) to give (es|cd)
   ! in the case when e=s. This version accumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

      if (.cd_same_center) then

        if (.c.l > .d.l) then; .transfer_l_c_same_s_add(esfs,escd)
        else;                  .transfer_l_d_same_s_add(esfs,escd)
        end

      else

        if (.c.l > .d.l) then; .transfer_l_c_high_s_add(esfs,escd)
        else;                  .transfer_l_d_high_s_add(esfs,escd)
        end

      end

   end

   transfer_l_c_same_s_add(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and c has high momentum. This version accumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT
   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")

 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      c,d,c1,c2,c3,cc,d1,l,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,1) = escd(:,1) + esfs

        case (1)
           if (.c.l==1) then                      ! (es|pp) case
                 escd(1,1) = escd(1,1) + esfs(4)
                 escd(1,2) = escd(1,2) + esfs(7)
                 escd(1,3) = escd(1,3) + esfs(8)
                 escd(2,1) = escd(2,1) + esfs(7)
                 escd(2,2) = escd(2,2) + esfs(5)
                 escd(2,3) = escd(2,3) + esfs(9)
                 escd(3,1) = escd(3,1) + esfs(8)
                 escd(3,2) = escd(3,2) + esfs(9)
                 escd(3,3) = escd(3,3) + esfs(6)
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    escd(c,1) = escd(c,1) + esfs(c1)
                    escd(c,2) = escd(c,2) + esfs(c2)
                    escd(c,3) = escd(c,3) + esfs(c3)
              end
           end

        case default                              ! general (es|cd) case
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of c's in int_new goes down
           int_new.create(nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    int_new(c,1) = esfs(c1)
                    int_new(c,2) = esfs(c2)
                    int_new(c,3) = esfs(c3)
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       int_new(c,d) = int_old(c1,d1)
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       escd(c,d) = escd(c,d) + int_old(c1,d1)
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_d_same_s_add(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where c and d have
   ! the same center and d has high momentum. This version accumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      c,d,c1,d1,d2,d3,dd,l,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(1,:) = escd(1,:) + esfs

        case (1)
           if (.d.l==1) then                      ! (es|pp) case
                 escd(1,1) = escd(1,1) + esfs(4)
                 escd(2,1) = escd(2,1) + esfs(7)
                 escd(3,1) = escd(3,1) + esfs(8)
                 escd(1,2) = escd(1,2) + esfs(7)
                 escd(2,2) = escd(2,2) + esfs(5)
                 escd(3,2) = escd(3,2) + esfs(9)
                 escd(1,3) = escd(1,3) + esfs(8)
                 escd(2,3) = escd(2,3) + esfs(9)
                 escd(3,3) = escd(3,3) + esfs(6)
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    escd(1,d) = escd(1,d) + esfs(d1)
                    escd(2,d) = escd(2,d) + esfs(d2)
                    escd(3,d) = escd(3,d) + esfs(d3)
              end
           end

        case default                              ! general (es|cd) case
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of d's in int_new goes down
           int_new.create(nd,3)                   ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    int_new(d,1) = esfs(d1)
                    int_new(d,2) = esfs(d2)
                    int_new(d,3) = esfs(d3)
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(nd,nc)               ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       int_new(d,c) = int_old(d1,c1)
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       escd(c,d) = escd(c,d) + int_old(d1,c1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_c_high_s_add(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell c has the higher
   ! angular momentum. This version acumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.c.l>=.d.l,"shell c must have higher momentum than d")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ec :: REAL
      c,d,c1,c2,c3,cc,d1,l,nc,fc,nd,fd,pd,dd,t :: INT

      select case (.d.l)

        case (0)                                  ! (es|cs) case
           escd(:,1) = escd(:,1) + esfs

        case (1)
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.c.l==1) then                      ! (es|pp) case
                 esfs_ec = esfs(1)
                 escd(1,1) = escd(1,1) + esfs(4) + R1*esfs_ec
                 escd(1,2) = escd(1,2) + esfs(7) + R2*esfs_ec
                 escd(1,3) = escd(1,3) + esfs(8) + R3*esfs_ec
                 esfs_ec = esfs(2)
                 escd(2,1) = escd(2,1) + esfs(7) + R1*esfs_ec
                 escd(2,2) = escd(2,2) + esfs(5) + R2*esfs_ec
                 escd(2,3) = escd(2,3) + esfs(9) + R3*esfs_ec
                 esfs_ec = esfs(3)
                 escd(3,1) = escd(3,1) + esfs(8) + R1*esfs_ec
                 escd(3,2) = escd(3,2) + esfs(9) + R2*esfs_ec
                 escd(3,3) = escd(3,3) + esfs(6) + R3*esfs_ec
           else                                   ! (es|cp) case
              nc = .c.n_comp
              fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)           ! Offset into the index array
              do c = 1,nc                         ! Put (es|fs) straight to (es|cd)
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    esfs_ec = esfs(c)
                    escd(c,1) = escd(c,1) + esfs(c1) + R1*esfs_ec
                    escd(c,2) = escd(c,2) + esfs(c2) + R2*esfs_ec
                    escd(c,3) = escd(c,3) + esfs(c3) + R3*esfs_ec
              end
           end

        case default                              ! general (es|cd) case
           R  = .c.position - .d.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fc = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)              ! Offset into the index array
           nc = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of c's in int_new goes down
           int_new.create(nc,3)
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_p1(cc,1) - fc
                 c2 = GAUSSIAN_DATA::index_p1(cc,2) - fc
                 c3 = GAUSSIAN_DATA::index_p1(cc,3) - fc
                    esfs_ec = esfs(c)
                    int_new(c,1) = esfs(c1) + R1*esfs_ec
                    int_new(c,2) = esfs(c2) + R2*esfs_ec
                    int_new(c,3) = esfs(c3) + R3*esfs_ec
              end
           fd = 1
           nd = 3
           do l = 2,.d.l-1
              nc = nc - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of c's in int_new goes down
              pd = fd                             ! Previous offset for d, in int_old
              fd = fd + nd                        ! Offset into index arrays
              nd = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed d's
              int_old => int_new
              int_new.create(nc,nd)
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(dd)           ! Transfer component
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       int_new(c,d) = int_old(c1,d1) + Rt*int_old(c,d1)
                 end
              end
              int_old.destroy
           end
              nc = .c.n_comp                      ! Final transfer into (es|cd)
              pd = fd
              fd = fd + nd
              nd = .d.n_comp
              int_old => int_new
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_m1(dd) - pd
                 t = GAUSSIAN_DATA::first_nonzero(dd)
                 Rt = R(t)
                 do c = 1,nc
                    c1 = GAUSSIAN_DATA::index_p1(c+fc,t) - fc
                       escd(c,d) = escd(c,d) + int_old(c1,d1) + Rt*int_old(c,d1)
                 end
              end
              int_old.destroy

        end ! case statement

   end

   transfer_l_d_high_s_add(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd) where shell d has the higher
   ! angular momentum. This version accumulates.
      self :: IN
      esfs :: VEC{REAL}(.n_cd), IN
      escd :: MAT{REAL}(.c.n_comp,.d.n_comp), OUT

   ENSURE(.d.l>=.c.l,"shell d must have higher momentum than c")
 ! ENSURE(.n_ab==1,"n_ab must be 1")
 ! ENSURE(esfs.dim1==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, esfs")
 ! ENSURE(esfs.dim2==(GAUSSIAN_DATA:n_comp_up_to(.cd_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.cd_l_max-1)),"wrong 2nd dimension, esfs")
 ! ENSURE(escd.dim1==esfs.dim1,"wrong 1st dimension, escd")
 ! ENSURE(escd.dim2==.c.n_comp,"wrong 2nd dimension, escd")
 ! ENSURE(escd.dim3==.d.n_comp,"wrong 3rd dimension, escd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,esfs_ed :: REAL
      c,d,c1,d1,d2,d3,dd,l,nd,fd,nc,fc,pc,cc,t :: INT

      select case (.c.l)

        case (0)                                  ! (es|sd) case
           escd(1,:) = escd(1,:) + esfs

        case (1)
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.d.l==1) then                      ! (es|pp) case
                 esfs_ed = esfs(1)
                 escd(1,1) = escd(1,1) + esfs(4) + R1*esfs_ed
                 escd(2,1) = escd(2,1) + esfs(7) + R2*esfs_ed
                 escd(3,1) = escd(3,1) + esfs(8) + R3*esfs_ed
                 esfs_ed = esfs(2)
                 escd(1,2) = escd(1,2) + esfs(7) + R1*esfs_ed
                 escd(2,2) = escd(2,2) + esfs(5) + R2*esfs_ed
                 escd(3,2) = escd(3,2) + esfs(9) + R3*esfs_ed
                 esfs_ed = esfs(3)
                 escd(1,3) = escd(1,3) + esfs(8) + R1*esfs_ed
                 escd(2,3) = escd(2,3) + esfs(9) + R2*esfs_ed
                 escd(3,3) = escd(3,3) + esfs(6) + R3*esfs_ed
           else                                   ! (es|pd) case
              nd = .d.n_comp
              fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)           ! Offset into the index array
              do d = 1,nd                         ! Put (es|fs) straight to (es|cd)
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    esfs_ed = esfs(d)
                    escd(1,d) = escd(1,d) + esfs(d1) + R1*esfs_ed
                    escd(2,d) = escd(2,d) + esfs(d2) + R2*esfs_ed
                    escd(3,d) = escd(3,d) + esfs(d3) + R3*esfs_ed
              end
           end

        case default                              ! general (es|cd) case
           R  = .d.position - .c.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fd = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)              ! Offset into the index array
           nd = .n_cd - GAUSSIAN_DATA:n_comp(.cd_l_sum)         ! No. of d's in int_new goes down
           int_new.create(nd,3)                   ! NOTE: d is transposed relative to c
              do d = 1,nd
                 dd = d+fd
                 d1 = GAUSSIAN_DATA::index_p1(dd,1) - fd
                 d2 = GAUSSIAN_DATA::index_p1(dd,2) - fd
                 d3 = GAUSSIAN_DATA::index_p1(dd,3) - fd
                    esfs_ed = esfs(d)
                    int_new(d,1) = esfs(d1) + R1*esfs_ed
                    int_new(d,2) = esfs(d2) + R2*esfs_ed
                    int_new(d,3) = esfs(d3) + R3*esfs_ed
              end
           fc = 1
           nc = 3
           do l = 2,.c.l-1
              nd = nd - GAUSSIAN_DATA:n_comp(.cd_l_sum-l+1)     ! No. of d's in int_new goes down
              pc = fc                             ! Previous offset for c, in int_old
              fc = fc + nc                        ! Offset into index arrays
              nc = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(nd,nc)               ! TRANSPOSED
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc           ! d1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(cc)           ! Transfer component
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       int_new(d,c) = int_old(d1,c1) + Rt*int_old(d,c1)
                 end
              end
              int_old.destroy
           end
              nd = .d.n_comp                      ! Final transfer into (es|cd)
              pc = fc
              fc = fc + nc
              nc = .c.n_comp
              int_old => int_new
              do c = 1,nc
                 cc = c+fc
                 c1 = GAUSSIAN_DATA::index_m1(cc) - pc
                 t = GAUSSIAN_DATA::first_nonzero(cc)
                 Rt = R(t)
                 do d = 1,nd
                    d1 = GAUSSIAN_DATA::index_p1(d+fd,t) - fd
                       escd(c,d) = escd(c,d) + int_old(d1,c1) + Rt*int_old(d,c1)
                 end
               end
               int_old.destroy

        end ! case statement

   end


   transfer_ab(escd,abcd)
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
      self :: IN
      escd :: MAT3{REAL}(.n_ab,.c.n_comp,.d.n_comp), IN
      abcd :: MAT4{REAL}(.a.n_comp,.b.n_comp,.c.n_comp,.d.n_comp), OUT

      if (.ab_same_center) then

        if (.a.l > .b.l) then; SHELL1QUARTET::transfer_l_a_same(self,escd,abcd)
        else;                  SHELL1QUARTET::transfer_l_b_same(self,escd,abcd)
        end

      else

        if (.a.l > .b.l) then; SHELL1QUARTET::transfer_l_a_high(self,escd,abcd)
        else;                  SHELL1QUARTET::transfer_l_b_high(self,escd,abcd)
        end

      end

   end

   transfer_l_a_same(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell a has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
      self :: IN
      escd :: MAT{REAL}(.n_ab,*), IN
      abcd :: MAT3{REAL}(.a.n_comp,.b.n_comp,*), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      ncd,cd,a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT
      ncd = .c.n_comp*.d.n_comp

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           do cd = 1,ncd
           do a = 1,.a.n_comp
              abcd(a,1,cd) = escd(a,cd)
           end
           end

        case (1)
           if (.a.l==1) then                      ! (pp|cd) case
              do cd = 1,ncd
                 abcd(1,1,cd) = escd(4,cd)
                 abcd(1,2,cd) = escd(7,cd)
                 abcd(1,3,cd) = escd(8,cd)
                 abcd(2,1,cd) = escd(7,cd)
                 abcd(2,2,cd) = escd(5,cd)
                 abcd(2,3,cd) = escd(9,cd)
                 abcd(3,1,cd) = escd(8,cd)
                 abcd(3,2,cd) = escd(9,cd)
                 abcd(3,3,cd) = escd(6,cd)
              end
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 do cd = 1,ncd
                    abcd(a,1,cd) = escd(a1,cd)
                    abcd(a,2,cd) = escd(a2,cd)
                    abcd(a,3,cd) = escd(a3,cd)
                 end
              end
           end

        case default                              ! general (ab|cd) case
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(ncd,na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 do cd = 1,ncd
                    int_new(cd,a,1) = escd(a1,cd)
                    int_new(cd,a,2) = escd(a2,cd)
                    int_new(cd,a,3) = escd(a3,cd)
                 end
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(ncd,na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    do cd = 1,ncd
                       int_new(cd,a,b) = int_old(cd,a1,b1)
                    end
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    do cd = 1,ncd
                       abcd(a,b,cd) = int_old(cd,a1,b1)
                    end
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_same(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell b has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
      self :: IN
      escd :: MAT{REAL}(.n_ab,*), IN
      abcd :: MAT3{REAL}(.a.n_comp,.b.n_comp,*), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      ncd,cd,a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT
      ncd = .c.n_comp*.d.n_comp

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
           do cd = 1,ncd
           do b = 1,.b.n_comp
              abcd(1,b,cd) = escd(b,cd)
           end
           end

        case (1)
           if (.b.l==1) then                      ! (pp|cd) case
              do cd = 1,ncd
                 abcd(1,1,cd) = escd(4,cd)
                 abcd(2,1,cd) = escd(7,cd)
                 abcd(3,1,cd) = escd(8,cd)
                 abcd(1,2,cd) = escd(7,cd)
                 abcd(2,2,cd) = escd(5,cd)
                 abcd(3,2,cd) = escd(9,cd)
                 abcd(1,3,cd) = escd(8,cd)
                 abcd(2,3,cd) = escd(9,cd)
                 abcd(3,3,cd) = escd(6,cd)
              end
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 do cd = 1,ncd
                    abcd(1,b,cd) = escd(b1,cd)
                    abcd(2,b,cd) = escd(b2,cd)
                    abcd(3,b,cd) = escd(b3,cd)
                 end
              end
           end

        case default                              ! general (ab|cd) case
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(ncd,nb,3)               ! TRANSPOSED
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 do cd = 1,ncd
                    int_new(cd,b,1) = escd(b1,cd)
                    int_new(cd,b,2) = escd(b2,cd)
                    int_new(cd,b,3) = escd(b3,cd)
                 end
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(ncd,nb,na)           ! TRANSPOSED
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    do cd = 1,ncd
                       int_new(cd,b,a) = int_old(cd,b1,a1)
                    end
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    do cd = 1,ncd
                       abcd(a,b,cd) = int_old(cd,b1,a1)
                    end
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_a_high(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell a has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd".
      self :: IN
      escd :: MAT{REAL}(.n_ab,*), IN
      abcd :: MAT3{REAL}(.a.n_comp,.b.n_comp,*), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_acd :: REAL
      ncd,cd,a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT
      ncd = .c.n_comp*.d.n_comp

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           do cd = 1,ncd
           do a = 1,.a.n_comp
              abcd(a,1,cd) = escd(a,cd)
           end
           end

        case (1)
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                      ! (pp|cd) case
              do cd = 1,ncd
                 escd_acd = escd(1,cd)
                 abcd(1,1,cd) = escd(4,cd) + R1*escd_acd
                 abcd(1,2,cd) = escd(7,cd) + R2*escd_acd
                 abcd(1,3,cd) = escd(8,cd) + R3*escd_acd
                 escd_acd = escd(2,cd)
                 abcd(2,1,cd) = escd(7,cd) + R1*escd_acd
                 abcd(2,2,cd) = escd(5,cd) + R2*escd_acd
                 abcd(2,3,cd) = escd(9,cd) + R3*escd_acd
                 escd_acd = escd(3,cd)
                 abcd(3,1,cd) = escd(8,cd) + R1*escd_acd
                 abcd(3,2,cd) = escd(9,cd) + R2*escd_acd
                 abcd(3,3,cd) = escd(6,cd) + R3*escd_acd
              end
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 do cd = 1,ncd
                    escd_acd = escd(a,cd)
                    abcd(a,1,cd) = escd(a1,cd) + R1*escd_acd
                    abcd(a,2,cd) = escd(a2,cd) + R2*escd_acd
                    abcd(a,3,cd) = escd(a3,cd) + R3*escd_acd
                 end
              end
           end

        case default                              ! general (ab|cd) case
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(ncd,na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 do cd = 1,ncd
                    escd_acd = escd(a,cd)
                    int_new(cd,a,1) = escd(a1,cd) + R1*escd_acd
                    int_new(cd,a,2) = escd(a2,cd) + R2*escd_acd
                    int_new(cd,a,3) = escd(a3,cd) + R3*escd_acd
                 end
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(ncd,na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    do cd = 1,ncd
                       int_new(cd,a,b) = int_old(cd,a1,b1) + Rt*int_old(cd,a,b1)
                    end
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    do cd = 1,ncd
                       abcd(a,b,cd) = int_old(cd,a1,b1) + Rt*int_old(cd,a,b1)
                    end
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_high(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell b has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd".
      self :: IN
      escd :: MAT{REAL}(.n_ab,*), IN
      abcd :: MAT3{REAL}(.a.n_comp,.b.n_comp,*), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT3{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_bcd :: REAL
      ncd,cd,a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT
      ncd = .c.n_comp*.d.n_comp

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
           do cd = 1,ncd
           do b = 1,.b.n_comp
              abcd(1,b,cd) = escd(b,cd)
           end
           end

        case (1)
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                      ! (pp|cd) case
              do cd = 1,ncd
                 escd_bcd = escd(1,cd)
                 abcd(1,1,cd) = escd(4,cd) + R1*escd_bcd
                 abcd(2,1,cd) = escd(7,cd) + R2*escd_bcd
                 abcd(3,1,cd) = escd(8,cd) + R3*escd_bcd
                 escd_bcd = escd(2,cd)
                 abcd(1,2,cd) = escd(7,cd) + R1*escd_bcd
                 abcd(2,2,cd) = escd(5,cd) + R2*escd_bcd
                 abcd(3,2,cd) = escd(9,cd) + R3*escd_bcd
                 escd_bcd = escd(3,cd)
                 abcd(1,3,cd) = escd(8,cd) + R1*escd_bcd
                 abcd(2,3,cd) = escd(9,cd) + R2*escd_bcd
                 abcd(3,3,cd) = escd(6,cd) + R3*escd_bcd
              end
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 do cd = 1,ncd
                    escd_bcd = escd(b,cd)
                    abcd(1,b,cd) = escd(b1,cd) + R1*escd_bcd
                    abcd(2,b,cd) = escd(b2,cd) + R2*escd_bcd
                    abcd(3,b,cd) = escd(b3,cd) + R3*escd_bcd
                 end
              end
           end

        case default                              ! general (ab|cd) case
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(ncd,nb,3)               ! TRANSPOSED
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 do cd = 1,ncd
                    escd_bcd = escd(b,cd)
                    int_new(cd,b,1) = escd(b1,cd) + R1*escd_bcd
                    int_new(cd,b,2) = escd(b2,cd) + R2*escd_bcd
                    int_new(cd,b,3) = escd(b3,cd) + R3*escd_bcd
                 end
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(ncd,nb,na)           ! TRANSPOSED
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    do cd = 1,ncd
                       int_new(cd,b,a) = int_old(cd,b1,a1) + Rt*int_old(cd,b,a1)
                    end
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    do cd = 1,ncd
                       abcd(a,b,cd) = int_old(cd,b1,a1) + Rt*int_old(cd,b,a1)
                    end
                 end
               end
               int_old.destroy

        end ! case statement

   end


   transfer_ab_s(escd,abcd)
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
   ! in the case when f=s.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

      if (.ab_same_center) then

        if (.a.l > .b.l) then; .transfer_l_a_same_s(escd,abcd)
        else;                  .transfer_l_b_same_s(escd,abcd)
        end

      else

        if (.a.l > .b.l) then; .transfer_l_a_high_s(escd,abcd)
        else;                  .transfer_l_b_high_s(escd,abcd)
        end

      end

   end

   transfer_l_a_same_s(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell a has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
   ! NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT
   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")

 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           abcd(:,1) = escd

        case (1)
           if (.a.l==1) then                      ! (pp|cd) case
                 abcd(1,1) = escd(4)
                 abcd(1,2) = escd(7)
                 abcd(1,3) = escd(8)
                 abcd(2,1) = escd(7)
                 abcd(2,2) = escd(5)
                 abcd(2,3) = escd(9)
                 abcd(3,1) = escd(8)
                 abcd(3,2) = escd(9)
                 abcd(3,3) = escd(6)
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    abcd(a,1) = escd(a1)
                    abcd(a,2) = escd(a2)
                    abcd(a,3) = escd(a3)
              end
           end

        case default                              ! general (ab|cd) case
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    int_new(a,1) = escd(a1)
                    int_new(a,2) = escd(a2)
                    int_new(a,3) = escd(a3)
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       int_new(a,b) = int_old(a1,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       abcd(a,b) = int_old(a1,b1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_same_s(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell b has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
   ! NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
              abcd(1,:) = escd

        case (1)
           if (.b.l==1) then                      ! (pp|cd) case
                 abcd(1,1) = escd(4)
                 abcd(2,1) = escd(7)
                 abcd(3,1) = escd(8)
                 abcd(1,2) = escd(7)
                 abcd(2,2) = escd(5)
                 abcd(3,2) = escd(9)
                 abcd(1,3) = escd(8)
                 abcd(2,3) = escd(9)
                 abcd(3,3) = escd(6)
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    abcd(1,b) = escd(b1)
                    abcd(2,b) = escd(b2)
                    abcd(3,b) = escd(b3)
              end
           end

        case default                              ! general (ab|cd) case
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(nb,3)                   ! TRANSPOSED
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    int_new(b,1) = escd(b1)
                    int_new(b,2) = escd(b2)
                    int_new(b,3) = escd(b3)
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       int_new(b,a) = int_old(b1,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       abcd(a,b) = int_old(b1,a1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_a_high_s(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell a has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd". NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_acd :: REAL
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           abcd(:,1) = escd

        case (1)
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                      ! (pp|cd) case
                 escd_acd = escd(1)
                 abcd(1,1) = escd(4) + R1*escd_acd
                 abcd(1,2) = escd(7) + R2*escd_acd
                 abcd(1,3) = escd(8) + R3*escd_acd
                 escd_acd = escd(2)
                 abcd(2,1) = escd(7) + R1*escd_acd
                 abcd(2,2) = escd(5) + R2*escd_acd
                 abcd(2,3) = escd(9) + R3*escd_acd
                 escd_acd = escd(3)
                 abcd(3,1) = escd(8) + R1*escd_acd
                 abcd(3,2) = escd(9) + R2*escd_acd
                 abcd(3,3) = escd(6) + R3*escd_acd
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    escd_acd = escd(a)
                    abcd(a,1) = escd(a1) + R1*escd_acd
                    abcd(a,2) = escd(a2) + R2*escd_acd
                    abcd(a,3) = escd(a3) + R3*escd_acd
              end
           end

        case default                              ! general (ab|cd) case
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    escd_acd = escd(a)
                    int_new(a,1) = escd(a1) + R1*escd_acd
                    int_new(a,2) = escd(a2) + R2*escd_acd
                    int_new(a,3) = escd(a3) + R3*escd_acd
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       int_new(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       abcd(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_high_s(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell b has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd". NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_bcd :: REAL
      a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
           abcd(1,:) = escd

        case (1)
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                      ! (pp|cd) case
                 escd_bcd = escd(1)
                 abcd(1,1) = escd(4) + R1*escd_bcd
                 abcd(2,1) = escd(7) + R2*escd_bcd
                 abcd(3,1) = escd(8) + R3*escd_bcd
                 escd_bcd = escd(2)
                 abcd(1,2) = escd(7) + R1*escd_bcd
                 abcd(2,2) = escd(5) + R2*escd_bcd
                 abcd(3,2) = escd(9) + R3*escd_bcd
                 escd_bcd = escd(3)
                 abcd(1,3) = escd(8) + R1*escd_bcd
                 abcd(2,3) = escd(9) + R2*escd_bcd
                 abcd(3,3) = escd(6) + R3*escd_bcd
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    escd_bcd = escd(b)
                    abcd(1,b) = escd(b1) + R1*escd_bcd
                    abcd(2,b) = escd(b2) + R2*escd_bcd
                    abcd(3,b) = escd(b3) + R3*escd_bcd
              end
           end

        case default                              ! general (ab|cd) case
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(nb,3)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    escd_bcd = escd(b)
                    int_new(b,1) = escd(b1) + R1*escd_bcd
                    int_new(b,2) = escd(b2) + R2*escd_bcd
                    int_new(b,3) = escd(b3) + R3*escd_bcd
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       int_new(b,a) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       abcd(a,b) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
               end
               int_old.destroy

        end ! case statement

   end


   transfer_ab_s_add(escd,abcd)
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
   ! in the case when f=s. This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

      if (.ab_same_center) then

        if (.a.l > .b.l) then; .transfer_l_a_same_s_add(escd,abcd)
        else;                  .transfer_l_b_same_s_add(escd,abcd)
        end

      else

        if (.a.l > .b.l) then; .transfer_l_a_high_s_add(escd,abcd)
        else;                  .transfer_l_b_high_s_add(escd,abcd)
        end

      end

   end

   transfer_l_a_same_s_add(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell a has the higher angular momentum. NOTE:
   ! this routine treats the cd indices as compressed together, with size "ncd".
   ! This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           abcd(:,1) = abcd(:,1) + escd

        case (1)
           if (.a.l==1) then                      ! (pp|cd) case
                 abcd(1,1) = abcd(1,1) + escd(4)
                 abcd(1,2) = abcd(1,2) + escd(7)
                 abcd(1,3) = abcd(1,3) + escd(8)
                 abcd(2,1) = abcd(2,1) + escd(7)
                 abcd(2,2) = abcd(2,2) + escd(5)
                 abcd(2,3) = abcd(2,3) + escd(9)
                 abcd(3,1) = abcd(3,1) + escd(8)
                 abcd(3,2) = abcd(3,2) + escd(9)
                 abcd(3,3) = abcd(3,3) + escd(6)
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    abcd(a,1) = abcd(a,1) + escd(a1)
                    abcd(a,2) = abcd(a,2) + escd(a2)
                    abcd(a,3) = abcd(a,3) + escd(a3)
              end
           end

        case default                              ! general (ab|cd) case
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    int_new(a,1) = escd(a1)
                    int_new(a,2) = escd(a2)
                    int_new(a,3) = escd(a3)
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       int_new(a,b) = int_old(a1,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       abcd(a,b) = abcd(a,b) + int_old(a1,b1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_same_s_add(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where a and b have
   ! the same center and where shell b has the higher angular momentum. NOTE:
   ! this routine treats the cd indices an compressed together, with size "ncd".
   ! This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
              abcd(1,:) = abcd(1,:) + escd

        case (1)
           if (.b.l==1) then                      ! (pp|cd) case
                 abcd(1,1) = abcd(1,1) + escd(4)
                 abcd(2,1) = abcd(2,1) + escd(7)
                 abcd(3,1) = abcd(3,1) + escd(8)
                 abcd(1,2) = abcd(1,2) + escd(7)
                 abcd(2,2) = abcd(2,2) + escd(5)
                 abcd(3,2) = abcd(3,2) + escd(9)
                 abcd(1,3) = abcd(1,3) + escd(8)
                 abcd(2,3) = abcd(2,3) + escd(9)
                 abcd(3,3) = abcd(3,3) + escd(6)
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    abcd(1,b) = abcd(1,b) + escd(b1)
                    abcd(2,b) = abcd(2,b) + escd(b2)
                    abcd(3,b) = abcd(3,b) + escd(b3)
              end
           end

        case default                              ! general (ab|cd) case
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(nb,3)                   ! TRANSPOSED
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    int_new(b,1) = escd(b1)
                    int_new(b,2) = escd(b2)
                    int_new(b,3) = escd(b3)
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       int_new(b,a) = int_old(b1,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       abcd(a,b) = abcd(a,b) + int_old(b1,a1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_a_high_s_add(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell a has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd". This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_acd :: REAL
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,bb,t :: INT

      select case (.b.l)

        case (0)                                  ! (as|cd) case
           abcd(:,1) = abcd(:,1) + escd

        case (1)
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                      ! (pp|cd) case
                 escd_acd = escd(1)
                 abcd(1,1) = abcd(1,1) + escd(4) + R1*escd_acd
                 abcd(1,2) = abcd(1,2) + escd(7) + R2*escd_acd
                 abcd(1,3) = abcd(1,3) + escd(8) + R3*escd_acd
                 escd_acd = escd(2)
                 abcd(2,1) = abcd(2,1) + escd(7) + R1*escd_acd
                 abcd(2,2) = abcd(2,2) + escd(5) + R2*escd_acd
                 abcd(2,3) = abcd(2,3) + escd(9) + R3*escd_acd
                 escd_acd = escd(3)
                 abcd(3,1) = abcd(3,1) + escd(8) + R1*escd_acd
                 abcd(3,2) = abcd(3,2) + escd(9) + R2*escd_acd
                 abcd(3,3) = abcd(3,3) + escd(6) + R3*escd_acd
           else                                   ! (ap|cd) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
              do a = 1,na                         ! Put (es|cd) straight to (ap|cd)
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    escd_acd = escd(a)
                    abcd(a,1) = abcd(a,1) + escd(a1) + R1*escd_acd
                    abcd(a,2) = abcd(a,2) + escd(a2) + R2*escd_acd
                    abcd(a,3) = abcd(a,3) + escd(a3) + R3*escd_acd
              end
           end

        case default                              ! general (ab|cd) case
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)              ! Offset into the index array
           na = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                    escd_acd = escd(a)
                    int_new(a,1) = escd(a1) + R1*escd_acd
                    int_new(a,2) = escd(a2) + R2*escd_acd
                    int_new(a,3) = escd(a3) + R3*escd_acd
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                             ! Previous offset for b, in int_old
              fb = fb + nb                        ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb           ! b1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(bb)           ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       int_new(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                      ! Final transfer into (ab|cd)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_m1(bb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(bb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                       abcd(a,b) = abcd(a,b) + int_old(a1,b1) + Rt*int_old(a,b1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

   transfer_l_b_high_s_add(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd) where shell b has the higher
   ! angular momentum. NOTE: this routine treats the cd indices an compressed
   ! together, with size "ncd". This version accumulates.
      self :: IN
      escd :: VEC{REAL}(.n_ab), IN
      abcd :: MAT{REAL}(.a.n_comp,.b.n_comp), OUT

   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
 ! ENSURE(.n_cd==1,"n_cd must be 1")
 ! ENSURE(ne==(GAUSSIAN_DATA:n_comp_up_to(.ab_l_sum)-GAUSSIAN_DATA:n_comp_up_to(.ab_l_max-1)),"wrong 1st dimension, escd")
 ! ENSURE(ncd==.c.n_comp*.d.n_comp,"wrong last dimension, escd and abcd")
   ENSURE(GAUSSIAN_DATA::first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,escd_bcd :: REAL
      a,a1,b,b1,b2,b3,bb,l,nb,fb,na,fa,pa,aa,t :: INT

      select case (.a.l)

        case (0)                                  ! (sb|cd) case
           abcd(1,:) = abcd(1,:) + escd

        case (1)
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                      ! (pp|cd) case
                 escd_bcd = escd(1)
                 abcd(1,1) = abcd(1,1) + escd(4) + R1*escd_bcd
                 abcd(2,1) = abcd(2,1) + escd(7) + R2*escd_bcd
                 abcd(3,1) = abcd(3,1) + escd(8) + R3*escd_bcd
                 escd_bcd = escd(2)
                 abcd(1,2) = abcd(1,2) + escd(7) + R1*escd_bcd
                 abcd(2,2) = abcd(2,2) + escd(5) + R2*escd_bcd
                 abcd(3,2) = abcd(3,2) + escd(9) + R3*escd_bcd
                 escd_bcd = escd(3)
                 abcd(1,3) = abcd(1,3) + escd(8) + R1*escd_bcd
                 abcd(2,3) = abcd(2,3) + escd(9) + R2*escd_bcd
                 abcd(3,3) = abcd(3,3) + escd(6) + R3*escd_bcd
           else                                   ! (pb|cd) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
              do b = 1,nb                         ! Put (es|cd) straight to (pb|cd)
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    escd_bcd = escd(b)
                    abcd(1,b) = abcd(1,b) + escd(b1) + R1*escd_bcd
                    abcd(2,b) = abcd(2,b) + escd(b2) + R2*escd_bcd
                    abcd(3,b) = abcd(3,b) + escd(b3) + R3*escd_bcd
              end
           end

        case default                              ! general (ab|cd) case
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)              ! Offset into the index array
           nb = .n_ab - GAUSSIAN_DATA:n_comp(.ab_l_sum)         ! No. of b's in int_new goes down
           int_new.create(nb,3)
              do b = 1,nb
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                    escd_bcd = escd(b)
                    int_new(b,1) = escd(b1) + R1*escd_bcd
                    int_new(b,2) = escd(b2) + R2*escd_bcd
                    int_new(b,3) = escd(b3) + R3*escd_bcd
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.ab_l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                      ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa           ! a1 relative to int_old
                 t  = GAUSSIAN_DATA::first_nonzero(aa)           ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       int_new(b,a) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                      ! Final transfer into (ab|cd)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_m1(aa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(aa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                       abcd(a,b) = abcd(a,b) + int_old(b1,a1) + Rt*int_old(b,a1)
                 end
               end
               int_old.destroy

        end ! case statement

   end

!  =============
!  Ishida scheme
!  =============

!   make_e0f0(e0f0) ::: private
!   ! Makes the (g0|00) integrals then the (e0|f0) from them
!     self :: IN
!     e0f0 :: MAT{REAL}(.n_ab,.n_cd), OUT
!
!     Ixa,Iya,Iza :: MAT3{REAL}*
!     Ix,Iy,Iz :: MAT{REAL}*
!     QPx,QPy,QPz,PAx,PAy,PAz,Px,Py,Pz :: REAL
!     ce,cf,bb,ce1,cf1 :: REAL
!     n_roots,n,i,j,k :: INT
!     rys :: RYS*
!     ss :: BIN
!
!     ss = .ab_l_max==0 AND .cd_l_max==0
!     l_sum = .ab_l_sum +.cd_l_sum
!     l_sp1 = l_sum + 1
!
!     gdim = GAUSSIAN_DATA:n_comp_up_to(l_sum)
!     Ix.create(gdim)                     ! Allocate 2D integrals
!     Iy.create(gdim)
!     Iz.create(gdim)
!
!     gx => GAUSSIAN_DATA::nx(:gdim)
!     gy => GAUSSIAN_DATA::ny(:gdim)
!     gz => GAUSSIAN_DATA::nz(:gdim)
!
!     n_roots = (l_sum+2)/2
!     rys.create(n_roots)
!
!     do k = 1,.ab_n_gaussian_pairs
!
!         ab_cc = TWOPI5ON2 * .ab_contraction_prefactor(k)
!         sigma1 = HALF*.ab_exponent_inv(k)
!         PAx = .ab_center_diff(1,k)
!         PAy = .ab_center_diff(2,k)
!         PAz = .ab_center_diff(3,k)
!
!         do j = 1,.cd_n_gaussian_pairs
!
!             cd_cc = .cd_contraction_prefactor(j)
!             sigma2 = HALF*.cd_exponent_inv(j)
!             sigma12 = ONE/(sigma1+sigma2)
!
!             rho  = HALF*sigma12
!             QPx = Qx - Px;   QPy = Qy - Py;   QPz = Qz - Pz
!             xx  = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
!             rys.get_weights(xx,only_weight=ss)
!             rys.weight = rys.weight * ab_cc * cd_cc * sqrt(rho)
!
!             rho1 = sigma1*sigma12
!             px = rho1*QPx
!             py = rho1*QPy
!             pz = rho1*QPz
!             rho1 = sigma1*rho1
!
!             ! Now make the 2 dimensional integrals.
!             do n = 1,n_roots
!
!               t2 = rys.root(n)
!               ax = PAx + px*t2
!               ay = PAy + py*t2
!               az = PAz + pz*t2
!               s1 = sigma1 - rho1*t2
!
!               Ix(1) = ONE
!               Iy(1) = ONE
!               Iz(1) = ONE
!
!               if (l_sum==0) cycle
!
!               Ix(2) = ax
!               Iy(2) = ay
!               Iz(2) = az
!
!               if (l_sum==1) cycle
!
!               sl = ZERO
!               do i = 2,l_sp1
!                  sl = sl + s1
!                  Ix(i+1) = ax*Ix(i) + sl*Ix(i-1)
!                  Iy(i+1) = ay*Iy(i) + sl*Iy(i-1)
!                  Iz(i+1) = az*Iz(i) + sl*Iz(i-1)
!               end
!
!               Iz = Iz * rys.weight(n)
!
!               g000 = Ix(gx)*Iy(gy)*Iz(gz)
!
!             end
!         end     ! -- loops over c,d
!     end         ! -- loops over a,b
!
!     rys.destroy
!
!     .form_esfs(esfs,Ixa,Iya,Iza,Iza(:,1,1))
!   ! SHELL1QUARTET::form_esfs_rms2(self,esfs,Ixa,Iya,Iza,Iza(:,1,1),n_sum,dim1,dim2)
!
!     Iza.destroy
!     Iya.destroy
!     Ixa.destroy
!   end

!  ================================================================
!  Make only the J contributions from the shell4 and density matrix
!  ================================================================

   make_r_J(J,Pab,Pcd,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Makes the J matrix directly from the (es|fs) integrals.
   ! This is a J matrix engine.
      self :: IN
      J :: MAT{REAL}
      Pab,Pcd :: VEC{REAL}
      factor :: REAL, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, IN

   ENSURE(.n_ab==Pab.dim,"size of Pab wrong")
   ENSURE(.n_cd==Pcd.dim,"size of Pcd wrong")

      esfs,Jab,Jcd :: MAT{REAL}*
      evfv,ev,fv :: VEC{REAL}*
      ssss :: REAL

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then

        .make_esfs_ss_0000(ssss)
        ssss = factor*ssss
        J(fa,fb) = J(fa,fb) + ssss*Pcd(1)
        J(fc,fd) = J(fc,fd) + ssss*Pab(1)

      else if (.ab_l_sum==0) then

        Jcd.create(.c.n_comp,.d.n_comp)
        evfv.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals
        J(fa,fb) = J(fa,fb) + factor*sum(evfv*Pcd)
        evfv = evfv*Pab(1)
        SHELL1QUARTET::transfer_cd_s(self,evfv,Jcd)
        evfv.destroy
        J(fc:lc,fd:ld) = J(fc:lc,fd:ld) + factor*Jcd
        Jcd.destroy

      else if (.cd_l_sum==0) then

        Jab.create(.a.n_comp,.b.n_comp)
        evfv.create(.n_ab)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals
        J(fc,fd) = J(fc,fd) + factor*sum(evfv*Pab)
        evfv = evfv*Pcd(1)
        SHELL1QUARTET::transfer_ab_s(self,evfv,Jab)
        evfv.destroy
        J(fa:la,fb:lb) = J(fa:la,fb:lb) + factor*Jab
        Jab.destroy

      else

        Jab.create(.a.n_comp,.b.n_comp)
        Jcd.create(.c.n_comp,.d.n_comp)
        esfs.create(.n_ab,.n_cd)
        ev.create(.n_ab)
        fv.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        ev.to_product_of(esfs,Pcd)
        fv.to_product_of(esfs,Pab,transpose_a=TRUE)
        SHELL1QUARTET::transfer_cd_s(self,fv,Jcd)
        SHELL1QUARTET::transfer_ab_s(self,ev,Jab)
        fv.destroy; ev.destroy
        esfs.destroy
        J(fa:la,fb:lb) = J(fa:la,fb:lb) + factor*Jab
        J(fc:lc,fd:ld) = J(fc:lc,fd:ld) + factor*Jcd
        Jcd.destroy
        Jab.destroy

      end

   end

   make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,same)
   ! Makes the J matrix directly from the (es|fs) integrals.
   ! This is a J matrix engine.
      self :: IN
      Jab,Jcd :: VEC{REAL}
      Pab,Pcd :: VEC{REAL}, IN
      factor :: REAL, IN
      same :: BIN, IN

   ENSURE(.n_ab==Jab.dim,"size of Jab wrong")
   ENSURE(.n_cd==Jcd.dim,"size of Jcd wrong")
   ENSURE(.n_ab==Pab.dim,"size of Pab wrong")
   ENSURE(.n_cd==Pcd.dim,"size of Pcd wrong")

      esfs :: MAT{REAL}*
      evfv,ev,fv :: VEC{REAL}*
      ssss,fac :: REAL

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then

        .make_esfs_ss_0000(ssss)
        ssss = factor*ssss
        if (same) then
           ssss = TWO*ssss
           Jab(1) = Jab(1) + ssss*Pcd(1)
        else
           Jab(1) = Jab(1) + ssss*Pcd(1)
           Jcd(1) = Jcd(1) + ssss*Pab(1)
        end

      else if (.ab_l_sum==0) then

        evfv.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals
        fac = factor*Pab(1)
        Jab(1) = Jab(1) + factor*sum(evfv*Pcd)
        Jcd    = Jcd    + fac*evfv
        evfv.destroy

      else if (.cd_l_sum==0) then

        evfv.create(.n_ab)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals
        fac = factor*Pcd(1)
        Jcd(1) = Jcd(1) + factor*sum(evfv*Pab)
        Jab    = Jab    + fac*evfv
        evfv.destroy

      else

        ev.create(.n_ab)
        fv.create(.n_cd)
        esfs.create(.n_ab,.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        ev.to_product_of(esfs,Pcd)
        fv.to_product_of(esfs,Pab,transpose_a=TRUE)
        esfs.destroy
        if (same) then
           fac = TWO*factor
           Jab = Jab + fac*ev
        else
           Jab = Jab + factor*ev
           Jcd = Jcd + factor*fv
        end
        fv.destroy; ev.destroy

      end

   end

   make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,same,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Makes the J matrix directly from the (es|fs) integrals (J matrix engine).
   ! Makes the K matrix normally. There are independent skips for each.
      self :: IN
      Jab,Jcd :: VEC{REAL}
      Pab,Pcd :: VEC{REAL}, IN
      K :: MAT{REAL}
      P :: MAT{REAL}, IN
      skip_J,skip_K,same :: BIN, IN
      factor :: REAL, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, IN

 ! ENSURE(NOT .is_spherical,"not implemented")
 ! ENSURE(.n_ab==Jab.dim,"size of Jab wrong")
 ! ENSURE(.n_cd==Jcd.dim,"size of Jcd wrong")
 ! ENSURE(.n_ab==Pab.dim,"size of Pab wrong")
 ! ENSURE(.n_cd==Pcd.dim,"size of Pcd wrong")

      esfs :: MAT{REAL}*
      evfv,ev,fv,I,escd :: VEC{REAL}*
      ssss,fac,I_abcd :: REAL
      a,b,c,d,abcd :: INT

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then       ! Make (ss|ss) integrals

        .make_esfs_ss_0000(ssss)
        ssss = factor*ssss
        if (NOT skip_J) then
           if (same) then
              Jab(1) = Jab(1) + TWO*ssss*Pcd(1)
           else
              Jab(1) = Jab(1) + ssss*Pcd(1)
              Jcd(1) = Jcd(1) + ssss*Pab(1)
           end
        end
        if (NOT skip_K) then
           K(fa,fc) = K(fa,fc) + ssss*P(fd,fb)
           K(fa,fd) = K(fa,fd) + ssss*P(fc,fb)
           K(fb,fc) = K(fb,fc) + ssss*P(fd,fa)
           K(fb,fd) = K(fb,fd) + ssss*P(fc,fa)
        end

      else if (.ab_l_sum==0) then

        evfv.create(.n_cd)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals
        if (NOT skip_J) then
           fac = factor*Pab(1)
           Jab(1) = Jab(1) + factor*sum(evfv*Pcd)
           Jcd    = Jcd    + fac*evfv
        end
        if (NOT skip_K) then
           I.create(.cd_n_comp_pairs)
           SHELL1QUARTET::transfer_cd_s(self,evfv,I)   ! Transfer, ab = ss
           abcd = 0
           do d = fd,ld
           do c = fc,lc
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              K(fa,c) = K(fa,c) + I_abcd*P(d,fb)
              K(fa,d) = K(fa,d) + I_abcd*P(c,fb)
              K(fb,c) = K(fb,c) + I_abcd*P(d,fa)
              K(fb,d) = K(fb,d) + I_abcd*P(c,fa)
           end
           end
           I.destroy
        end
        evfv.destroy

      else if (.cd_l_sum==0) then

        evfv.create(.n_ab)
        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals
        if (NOT skip_J) then
           fac = factor*Pcd(1)
           Jcd(1) = Jcd(1) + factor*sum(evfv*Pab)
           Jab    = Jab    + fac*evfv
        end
        if (NOT skip_K) then
           I.create(.ab_n_comp_pairs)
           SHELL1QUARTET::transfer_ab_s(self,evfv,I)   ! Transfer, cd = ss
           abcd = 0
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              K(a,fc) = K(a,fc) + I_abcd*P(fd,b)
              K(a,fd) = K(a,fd) + I_abcd*P(fc,b)
              K(b,fc) = K(b,fc) + I_abcd*P(fd,a)
              K(b,fd) = K(b,fd) + I_abcd*P(fc,a)
           end
           end
           I.destroy
        end
        evfv.destroy

      else

        esfs.create(.n_ab,.n_cd)
        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals
        if (NOT skip_J) then
           ev.create(.n_ab)
           fv.create(.n_cd)
           ev.to_product_of(esfs,Pcd)
           fv.to_product_of(esfs,Pab,transpose_a=TRUE)
           if (same) then
              fac = TWO*factor
              Jab = Jab + fac*ev
           else
              Jab = Jab + factor*ev
              Jcd = Jcd + factor*fv
           end
           fv.destroy; ev.destroy
        end
        if (NOT skip_K) then
           I.create(.ab_n_comp_pairs*.cd_n_comp_pairs)
           escd.create(.n_ab*.c.n_comp*.d.n_comp)
           SHELL1QUARTET::transfer_cd(self,esfs,escd)     ! Transfer relations
           SHELL1QUARTET::transfer_ab(self,escd,I)
           escd.destroy
           abcd = 0
           do d = fd,ld
           do c = fc,lc
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              K(a,c) = K(a,c) + I_abcd*P(d,b)
              K(a,d) = K(a,d) + I_abcd*P(c,b)
              K(b,c) = K(b,c) + I_abcd*P(d,a)
              K(b,d) = K(b,d) + I_abcd*P(c,a)
           end
           end
           end
           end
           I.destroy
        end
        esfs.destroy

      end

   end

   make_r_JK_engine(JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd,Ka,Kb,Pa,Pb,sJ,sK,same,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Makes the alpha and beta J matrix directly from the (es|fs) integrals (J matrix engine).
   ! Makes the alpha and beta K matrix normally. There are independent skips for each.
      self :: IN
      JAab,JBab,JAcd,JBcd :: VEC{REAL}
      PAab,PBab,PAcd,PBcd :: VEC{REAL}, IN
      Ka,Kb :: MAT{REAL}
      Pa,Pb :: MAT{REAL}, IN
      sJ,sK,same :: BIN, IN ! skip_J, skip_K, same
      factor :: REAL, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, IN

      esfs :: MAT{REAL}*
      evfv,ev,fv,I,escd :: VEC{REAL}*
      ssss,fac,I_abcd :: REAL
      a,b,c,d,abcd :: INT

      if      (.ab_l_sum==0 AND .cd_l_sum==0) then       ! Make (ss|ss) integrals

        .make_esfs_ss_0000(ssss)
        ssss = factor*ssss

        if (NOT sJ) then
           if (same) then
              JAab(1) = JAab(1) + TWO*ssss*PAcd(1)
              JBab(1) = JBab(1) + TWO*ssss*PBcd(1)
           else
              JAab(1) = JAab(1) + ssss*PAcd(1)
              JAcd(1) = JAcd(1) + ssss*PAab(1)
              JBab(1) = JBab(1) + ssss*PBcd(1)
              JBcd(1) = JBcd(1) + ssss*PBab(1)
           end
        end

        if (NOT sK) then
           Ka(fa,fc) = Ka(fa,fc) + ssss*Pa(fd,fb)
           Ka(fa,fd) = Ka(fa,fd) + ssss*Pa(fc,fb)
           Ka(fb,fc) = Ka(fb,fc) + ssss*Pa(fd,fa)
           Ka(fb,fd) = Ka(fb,fd) + ssss*Pa(fc,fa)
           Kb(fa,fc) = Kb(fa,fc) + ssss*Pb(fd,fb)
           Kb(fa,fd) = Kb(fa,fd) + ssss*Pb(fc,fb)
           Kb(fb,fc) = Kb(fb,fc) + ssss*Pb(fd,fa)
           Kb(fb,fd) = Kb(fb,fd) + ssss*Pb(fc,fa)
        end

      else if (.ab_l_sum==0) then

        evfv.create(.n_cd)

        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (ss|fs) integrals

        if (NOT sJ) then
           fac = factor*PAab(1)
           JAab(1) = JAab(1) + factor*sum(evfv*PAcd)
           JAcd    = JAcd    + fac*evfv
           fac = factor*PBab(1)
           JBab(1) = JBab(1) + factor*sum(evfv*PBcd)
           JBcd    = JBcd    + fac*evfv
        end

        if (NOT sK) then
           I.create(.cd_n_comp_pairs)
           SHELL1QUARTET::transfer_cd_s(self,evfv,I)   ! Transfer, ab = ss
           abcd = 0
           do d = fd,ld
           do c = fc,lc
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              Ka(fa,c) = Ka(fa,c) + I_abcd*Pa(d,fb)
              Ka(fa,d) = Ka(fa,d) + I_abcd*Pa(c,fb)
              Ka(fb,c) = Ka(fb,c) + I_abcd*Pa(d,fa)
              Ka(fb,d) = Ka(fb,d) + I_abcd*Pa(c,fa)
              Kb(fa,c) = Kb(fa,c) + I_abcd*Pb(d,fb)
              Kb(fa,d) = Kb(fa,d) + I_abcd*Pb(c,fb)
              Kb(fb,c) = Kb(fb,c) + I_abcd*Pb(d,fa)
              Kb(fb,d) = Kb(fb,d) + I_abcd*Pb(c,fa)
           end
           end
           I.destroy
        end

        evfv.destroy

      else if (.cd_l_sum==0) then

        evfv.create(.n_ab)

        SHELL1QUARTET::make_esfs(self,evfv)            ! Make (es|ss) integrals

        if (NOT sJ) then
           fac = factor*PAcd(1)
           JAcd(1) = JAcd(1) + factor*sum(evfv*PAab)
           JAab    = JAab    + fac*evfv
           fac = factor*PBcd(1)
           JBcd(1) = JBcd(1) + factor*sum(evfv*PBab)
           JBab    = JBab    + fac*evfv
        end

        if (NOT sK) then
           I.create(.ab_n_comp_pairs)
           SHELL1QUARTET::transfer_ab_s(self,evfv,I)   ! Transfer, cd = ss
           abcd = 0
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              Ka(a,fc) = Ka(a,fc) + I_abcd*Pa(fd,b)
              Ka(a,fd) = Ka(a,fd) + I_abcd*Pa(fc,b)
              Ka(b,fc) = Ka(b,fc) + I_abcd*Pa(fd,a)
              Ka(b,fd) = Ka(b,fd) + I_abcd*Pa(fc,a)
              Kb(a,fc) = Kb(a,fc) + I_abcd*Pb(fd,b)
              Kb(a,fd) = Kb(a,fd) + I_abcd*Pb(fc,b)
              Kb(b,fc) = Kb(b,fc) + I_abcd*Pb(fd,a)
              Kb(b,fd) = Kb(b,fd) + I_abcd*Pb(fc,a)
           end
           end
           I.destroy
        end

        evfv.destroy

      else

        esfs.create(.n_ab,.n_cd)

        SHELL1QUARTET::make_esfs(self,esfs)            ! Make (es|fs) integrals

        if (NOT sJ) then
           ev.create(.n_ab)
           fv.create(.n_cd)
           ev.to_product_of(esfs,PAcd)
           fv.to_product_of(esfs,PAab,transpose_a=TRUE)
           if (same) then
              fac = TWO*factor
              JAab = JAab + fac*ev
           else
              JAab = JAab + factor*ev
              JAcd = JAcd + factor*fv
           end
           ev.to_product_of(esfs,PBcd)
           fv.to_product_of(esfs,PBab,transpose_a=TRUE)
           if (same) then
              fac = TWO*factor
              JBab = JBab + fac*ev
           else
              JBab = JBab + factor*ev
              JBcd = JBcd + factor*fv
           end
           fv.destroy; ev.destroy
        end

        if (NOT sK) then
           I.create(.ab_n_comp_pairs*.cd_n_comp_pairs)
           escd.create(.n_ab*.c.n_comp*.d.n_comp)
           SHELL1QUARTET::transfer_cd(self,esfs,escd)     ! Transfer relations
           SHELL1QUARTET::transfer_ab(self,escd,I)
           escd.destroy
           abcd = 0
           do d = fd,ld
           do c = fc,lc
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              Ka(a,c) = Ka(a,c) + I_abcd*Pa(d,b)
              Ka(a,d) = Ka(a,d) + I_abcd*Pa(c,b)
              Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
              Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
              Kb(a,c) = Kb(a,c) + I_abcd*Pb(d,b)
              Kb(a,d) = Kb(a,d) + I_abcd*Pb(c,b)
              Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
              Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
           end
           end
           end
           end
           I.destroy
        end

        esfs.destroy

      end

   end

!  ===============
!  Output Routines
!  ===============

   put
   ! Put the shell4 information to file "out"

      n_cc,i :: INT

      stdout.flush
      stdout.show("A shell l quantum number =",.a.l)
      stdout.show("B shell l quantum number =",.b.l)
      stdout.show("C shell l quantum number =",.c.l)
      stdout.show("D shell l quantum number =",.d.l)
      stdout.show("A position               =",.a.position)
      stdout.show("B position               =",.b.position)
      stdout.show("C position               =",.c.position)
      stdout.show("D position               =",.d.position)
      stdout.flush
      stdout.dash(int_fields=1,real_fields=8)
      stdout.put("N", int_width=TRUE)
      stdout.put("ex_a")
      stdout.put("cc_a")
      stdout.put("ex_b")
      stdout.put("cc_b")
      stdout.put("ex_c")
      stdout.put("cc_c")
      stdout.put("ex_d")
      stdout.put("cc_d")
      stdout.flush

      stdout.dash(int_fields=1,real_fields=8)

      n_cc = max(.a.n_cc,.b.n_cc,.c.n_cc,.d.n_cc)
      do i = 1,n_cc
        stdout.put(i)
        if (i<=.a.n_cc) then
        stdout.put( .a.exponent(i))
        stdout.put( .a.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.b.n_cc) then
        stdout.put( .b.exponent(i))
        stdout.put( .b.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.c.n_cc) then
        stdout.put( .c.exponent(i))
        stdout.put( .c.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.d.n_cc) then
        stdout.put( .d.exponent(i))
        stdout.put( .d.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        stdout.flush
      end

      stdout.dash(int_fields=1,real_fields=8)

   end

end
