!-------------------------------------------------------------------------------
!
! PAULI_BLOCK_GEMINALS
!
! Copyright (C) Patrick Cassam-Chenai and Thomas Perez, 2018
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module PAULI_BLOCK_GEMINALS

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!===============================================================================
!                             Create and Destroy Routines
!===============================================================================

   create ::: leaky
   ! Create a pauli_block_geminals
      self :: PTR
      nullify(self)
      allocate(self)
   !   .nullify_ptr_part
   end

   create(vec,n_geminals) ::: leaky
   ! Create a set of PBT
     vec :: VEC{PAULI_BLOCK_TENSOR}*
     n_geminals :: INT

     nullify(vec)
     allocate(vec(n_geminals))

   end


 
!tempcc  destroy ::: get_from(OBJECT), leaky
!tempcc  ! Destroy an object
!tempcc  end
!tempcc
!tempcc  destroy_ptr_part ::: get_from(OBJECT), leaky
!tempcc  ! Destroy the pointer parts of self
!tempcc  end
!tempcc 
!tempcc    destroy_ptr_part  ::: leaky
!tempcc    ! Destroy the pointer parts of self
!tempcc       .bra.destroy
!tempcc       .ket.destroy
!tempcc       .special_ket.destroy
!tempcc    end
!tempcc 
!tempcc    create_copy(b) ::: leaky
!tempcc    ! Create a copy of "b".
!tempcc      self :: PTR
!tempcc      b :: GEMINAL_MF_SPECTRUM, IN
!tempcc 
!tempcc      .create(b.name,b.nuclear_repulsion_energy,b.n_geminals,b.i_geminals,b.n_bf)
!tempcc      .copy(b)
!tempcc 
!tempcc    end
!tempcc 
!tempcc    copy(b) ::: leaky
!tempcc    ! Copy a basis "b" to "self". Make sure pointer parts are first
!tempcc    ! destroyed or nullified, as you want.
!tempcc       b :: GEMINAL_MF_SPECTRUM, IN
!tempcc       self = b
!tempcc       if (b.bra.created) .bra.create_copy(b.bra)
!tempcc       if (b.ket.created) .ket.create_copy(b.ket)
!tempcc       if (b.special_ket.created) .special_ket.create_copy(b.special_ket)
!tempcc       if (b.contraction_wfs.created) .contraction_wfs.create_copy(b.contraction_wfs)
!tempcc       if (b.contraction_energies.created) .contraction_energies.create_copy(b.contraction_energies)
!tempcc    end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

!  ===========
!  Set methods
!  ===========

   set_defaults(n_geminals,n_blocks,mat_size,mol_name,bra_is_ket,spin_restricted) ::: leaky
   ! Create sets of geminals for bra and ket
      self :: PTR
      n_geminals,n_blocks,mat_size :: INT, optional
      mol_name :: STR, optional
      bra_is_ket :: BIN, optional
      spin_restricted :: BIN, optional
      .bra_is_ket = TRUE
      .spin_restricted = TRUE
      if (present(n_geminals)) .n_geminals = n_geminals
      if (present(n_blocks)) .n_blocks=n_blocks
      if (present(mat_size)) .mat_size=mat_size
      if (present(mol_name)) .name = mol_name
      if (present(bra_is_ket)) .bra_is_ket = bra_is_ket
      if (present(spin_restricted)) .spin_restricted = spin_restricted
      
   end
      

   set_matrix_form
   ! make matrix form from coef and block types for bra_set and ket_set if different
     .make_matrix_form(.bra_set)
     if (NOT .bra_is_ket) then
       .make_matrix_form(.ket_set)
     end
   end
      
!tempcc 
!tempcc    set_to_zero_energies
!tempcc    ! set to zero contraction_energies
!tempcc      .contraction_energies = ZERO
!tempcc    end

!  ===============
!  INPUT Routines
!  ===============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

!pcc   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
!pcc   ! Read in and process list-based keywords from "stdin". List-based keywords
!pcc   ! are those that are intended to apply to each individual element of the list
!pcc   ! through a list of "keys" stored in the associated list-element type module.
!pcc   ! NOTE: this routine will create the list, if required.
!pcc      self :: PTR  
!pcc   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
 !      case ("do_overlap              "); .do_overlap
 !      case ("do_hamiltonian          "); .do_hamiltonian
       case ("junk=                   "); .read_junk
 !      case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       case ("units=                  "); .read_units
       case ("n_geminals=             "); .read_n_geminals
       case ("n_blocks=               "); .read_n_blocks
       case ("bra_is_ket=             "); .read_bra_is_ket
       case ("bra_set=                "); .read_bra_set
       case ("ket_set=                "); .read_ket_set
       case ("set_matrix_form         "); .set_matrix_form
       case ("spin_restricted=        "); .read_spin_restricted
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_n_geminals
   ! Read number of geminals
   !  self :: PTR
     n_geminals :: INT
     stdin.read(n_geminals)
     .n_geminals=n_geminals
   end

   read_n_blocks
   ! Read number of blocks
   !  self :: PTR
     n_blocks :: INT
     stdin.read(n_blocks)
     .n_blocks=n_blocks
   end 

   read_bra_is_ket
   ! Read TRUE if the bra and the ket have the same geminals, else read FALSE
   !  self :: PTR
     bra_is_ket :: BIN
     stdin.read(bra_is_ket)
     .bra_is_ket=bra_is_ket
   end 

   read_bra_set ::: leaky
   ! Read all the blocks of the geminals of the bra
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i,j,counter :: INT
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.bra_set.vec(.n_geminals))
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       .bra_set.vec(i).block_type.create(.n_blocks)
       .bra_set.vec(i).block_dim.create(.n_blocks)
       .bra_set.vec(i).block_dim=2
       .bra_set.vec(i).coef.create(.n_blocks)
       .bra_set.vec(i).block_type=blocks
       .bra_set.vec(i).coef=coeffs
       counter=0
       do j=1,.n_blocks
         if(blocks(j)=='ID1') then
           .bra_set.vec(i).block_dim(j)=1
           counter=counter+1
         end
       end
       .bra_set.vec(i).n_blocks(1)=counter
       .bra_set.vec(i).n_blocks(2)=.n_blocks-counter
     end
   end

   read_ket_set ::: leaky
   ! Read all the blocks of the geminals of the ket
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i,j,counter :: INT
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.ket_set.vec(.n_geminals))
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       if (.bra_is_ket) then
         stdout.text("WARNING: .bra_is_ket has been set to TRUE !")
         stdout.show("For ket ", i)
         stdout.text("read in information will be ignored")
       else
         .ket_set.vec(i).block_type.create(.n_blocks)
         .ket_set.vec(i).block_dim.create(.n_blocks)
         .ket_set.vec(i).block_dim=2
         .ket_set.vec(i).coef.create(.n_blocks)
         .ket_set.vec(i).block_type=blocks
         .ket_set.vec(i).coef=coeffs
         counter=0
         do j=1,.n_blocks
           if(blocks(j)=='ID1') then
             .ket_set.vec(i).block_dim(j)=1
             counter=counter+1
           end
         end
         .ket_set.vec(i).n_blocks(1)=counter
         .ket_set.vec(i).n_blocks(2)=.n_blocks-counter
       end
     end
   end

   read_spin_restricted
   ! Read TRUE if the spin-restricted approach is selected, else read FALSE
   !  self :: PTR
     spin_restricted :: BIN
     stdin.read(spin_restricted)
     .spin_restricted=spin_restricted
   end 

!tempcc    read_geminal(j,mat) ::: private, leaky
!tempcc    ! Read in a new value of ".n_bf", which must be smaller than the initial
!tempcc    ! basis set size. Truncate the coefficient matrices.
!tempcc      j :: INT
!tempcc      mat :: MAT{REAL}*
!tempcc !     ENSURE(.bra.created,"no bra")
!tempcc !     ENSURE(.bra(1).element.created,"no bra elements")
!tempcc !     ENSURE(.ket.created,"no ket")
!tempcc !     ENSURE(.ket(1).element.created,"no ket elements")
!tempcc !     ENSURE(.contraction_wfs.created,"no contraction_wfs")
!tempcc !     ENSURE(.contraction_wfs(1).element.created,"no contraction_wfs elements")
!tempcc      in :: TEXTFILE*
!tempcc      i,k,n,m :: INT
!tempcc      name :: STR
!tempcc 
!tempcc      if (FALSE) self = self
!tempcc 
!tempcc      name="readin_geminal_"//j.to_str.trim
!tempcc      in.create(name)
!tempcc      in.open_for("read")
!tempcc      in.read(n)
!tempcc 
!tempcc      mat = ZERO
!tempcc      do m=1,n
!tempcc        in.read(i)
!tempcc        in.read(k)
!tempcc        in.read(mat(i,k))
!tempcc        !if (in.end_of_file) exit
!tempcc      end
!tempcc 
!tempcc      in.close  
!tempcc      in.destroy
!tempcc 
!tempcc    end
!tempcc 
!tempcc    get_wfs ::: leaky
!tempcc    ! get wave functions from an archive file
!tempcc      wfs_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      j :: INT
!tempcc      
!tempcc      name="wfs_"//.i_geminals.to_str.trim
!tempcc      wfs_archive.set(.name,name)
!tempcc      .get_max_bas
!tempcc      if(.contraction_energies.created) then
!tempcc        .contraction_energies.destroy
!tempcc        .contraction_wfs.destroy
!tempcc      end
!tempcc      .contraction_energies.create(.n_bas)
!tempcc      .set_to_zero_energies
!tempcc      .contraction_wfs.create(.n_bas)
!tempcc      do j=1,.n_bas
!tempcc        .contraction_wfs(j).element.create(.n_bf,.n_bf)
!tempcc      end
!tempcc      wfs_archive.read(.contraction_wfs)
!tempcc    end
!tempcc 
!tempcc    get_ground_state
!tempcc    ! get ground state wave function from an archive file
!tempcc      ground_state_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="ground_state_"//.i_geminals.to_str.trim
!tempcc      ground_state_archive.set(.name,name)
!tempcc      ground_state_archive.read(.bra(.i_geminals).element)
!tempcc      .ket(.i_geminals).element=.bra(.i_geminals).element
!tempcc    end
!tempcc 
!tempcc    get_max_bas
!tempcc    ! get number of basis functions from an archive file
!tempcc      max_bas_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="max_bas_"//.i_geminals.to_str.trim
!tempcc      max_bas_archive.set(.name,name)
!tempcc      max_bas_archive.read(.n_bas)
!tempcc    end

!  ===============
!  other Routines
!  ===============

   make_matrix_form(mat_set)
   ! make matrix form from coef and block types
     mat_set :: PAULI_BLOCK_TENSOR_SET
     i,j,last :: INT
     do i=1,.n_geminals
       allocate(mat_set.vec(i).matrix_form(.mat_size,.mat_size))
       mat_set.vec(i).matrix_form=ZERO
       last=0
       do j=1,.n_blocks         
         select case (mat_set.vec(i).block_type(j))
           case ("ID1");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("ID2");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("SX");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(last,last-1)=mat_set.vec(i).coef(j)
           case ("ISY");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(last,last-1)=-mat_set.vec(i).coef(j)
           case ("SZ");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=-mat_set.vec(i).coef(j)
           case ("E11");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last-1)=mat_set.vec(i).coef(j)
           case ("E22");
             last=last+2
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("S+");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
           case ("S-");
             last=last+2
             mat_set.vec(i).matrix_form(last,last-1)=mat_set.vec(i).coef(j)
           case  default ; stdout.text("unknown matrix type")
             stop
         end
       end
     end           
   end


   make_type_numbers(subset) ::: leaky
   ! make type_numbers for each block of a subset of pauli_block_tensor
     subset :: PAULI_BLOCK_TENSOR_SET
     n_gem,i :: INT
     n_blocks,j :: INT

     n_gem=subset.vec.dim
     n_blocks=subset.vec(1).block_type.dim
     
     if(NOT subset.type_nb.created) then
       subset.type_nb.create(n_blocks)
     end
     do j=1,n_blocks
       subset.type_nb(j).element.create(9)
       subset.type_nb(j).element=0
     end
     
     do i=1,n_gem
       do j=1,n_blocks
         select case (subset.vec(i).block_type(j))       
         case("ID1"); 
           subset.type_nb(j).element(1)=subset.type_nb(j).element(1)+1     
         case("ID2");                                               
           subset.type_nb(j).element(2)=subset.type_nb(j).element(2)+1     
         case("E11");                                              
           subset.type_nb(j).element(3)=subset.type_nb(j).element(3)+1     
         case("E22");                                              
           subset.type_nb(j).element(4)=subset.type_nb(j).element(4)+1     
         case("S+");                                               
           subset.type_nb(j).element(5)=subset.type_nb(j).element(5)+1
         case("S-");                                               
           subset.type_nb(j).element(6)=subset.type_nb(j).element(6)+1
         case("SX");                                               
           subset.type_nb(j).element(7)=subset.type_nb(j).element(7)+1     
         case("ISY");                                              
           subset.type_nb(j).element(8)=subset.type_nb(j).element(8)+1     
         case("SZ"); 
           subset.type_nb(j).element(9)=subset.type_nb(j).element(9)+1
         case default ;
         end
       end
     end
   end


   make_type_numbers(bra_subset,ket_subset)
   ! make type_numbers for a pair of bra subset and ket subset
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks,j :: INT
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
     .make_type_numbers(bra_subset)
     .make_type_numbers(ket_subset)
     stdout.text("bra type numbers")
     do j=1,n_blocks
       stdout.show("j",j)
       stdout.put(bra_subset.type_nb(j).element)
     end
     stdout.text("ket type numbers")
     do j=1,n_blocks
       stdout.show("j",j)
       stdout.put(ket_subset.type_nb(j).element)
     end
   end


! davide: 26-10-2018
   check_size
   ! check if the size of the geminal matrices is equal to the sum of
   ! the pauli block sizes
     stdout.text(" ")
     stdout.text("Checking size of bra set of geminals")
     .check_size(.bra_set,.mat_size)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking size of ket set of geminals")
      ! stdout.text("checking ket set of geminals")
       .check_size(.ket_set,.mat_size)
     end
   end

   check_size(pb_tensor_set,pb_mat_size)
   ! check if, for each pauli_block_matrix, the sum of block 
   ! sizes is equal to the matrix size
     pb_tensor_set :: PAULI_BLOCK_TENSOR_SET
     pb_mat_size :: INT
     i :: INT
     do i=1,.n_geminals
      stdout.show("geminal", i)
      .check_size(pb_tensor_set.vec(i),pb_mat_size) 
     end
   end

   check_size(pb_tensor,pb_mat_size)
   ! check if, for each pauli_block_matrix, the sum of block 
   ! sizes is equal to the matrix size
   pb_tensor :: PAULI_BLOCK_TENSOR
   pb_mat_size :: INT
   nb1, nb2, chk_size :: INT
     nb1 = pb_tensor.n_blocks(1) 
     nb2 = pb_tensor.n_blocks(2) 
     chk_size = nb1 + nb2*2
     if (chk_size == pb_mat_size) then 
        stdout.text("passed")
     else
        stdout.text("not passed")
     end
   end
! de

! davide: 26-10-2018
   check_block_sizes
   ! check if geminal matrices have the same block sizes
     stdout.text(" ")
     stdout.text("Checking block sizes of bra set of geminals")
     .check_block_sizes(.bra_set,.n_blocks)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking block sizes of ket set of geminals")
       .check_block_sizes(.ket_set,.n_blocks)
       stdout.text(" ")
       stdout.text("checking block sizes homogeneity of ket and bra 1st geminals")
       .check_block_sizes(.bra_set.vec(1),.ket_set.vec(1),.n_blocks)
     end
   end

   check_block_sizes(pb_tensor_set,nb)
   !
     pb_tensor_set :: PAULI_BLOCK_TENSOR_SET
     nb :: INT
     i :: INT
     do i=2,.n_geminals
       stdout.show("geminals 1 and", i)
       .check_block_sizes(pb_tensor_set.vec(1),pb_tensor_set.vec(i),nb)
     end
   end

   check_block_sizes(pbt1,pbt2,nb)
   !
     pbt1, pbt2 :: PAULI_BLOCK_TENSOR
     nb :: INT
     i :: INT
     chk_bsize :: BIN 
     chk_bsize = pbt1.block_dim.equals(pbt2.block_dim)
     if(chk_bsize) then
       stdout.text("passed")
     else
       stdout.text("not passed for blocks:")
       do i=1,nb 
         if ( pbt1.block_dim(i) /= pbt2.block_dim(i) ) then
           stdout.show(" ", i)
         end
       end
     end
   end
! de

! davide: 12-11-2018
 check_blocks_order
 ! check if in each PBT the blocks are ordered in this way:
 ! first the blocks of size 1, then the blocks of size 2
   stdout.text(" ")
   stdout.text("Checking blocks order in bra set of geminals")
   .check_blocks_order(.bra_set)
   if (NOT .bra_is_ket) then
     stdout.text(" ")
     stdout.text("Checking blocks order in ket set of geminals")
     .check_blocks_order(.ket_set)
   end
 end

 check_blocks_order(pbt_set)
 ! call to the routine checking the order of blocks in each PBT
 pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
 ng, i :: INT
   ng = size(pbt_set.vec)
   do i=1,ng
     stdout.show("geminal", i)
     .check_blocks_order(pbt_set.vec(i))
   end
 end

 check_blocks_order(pbt)
 ! check if in the PBT the blocks are ordered in this way:
 ! first the blocks of size 1, then the blocks of size 2
 pbt :: PAULI_BLOCK_TENSOR, IN
 i :: INT
 test :: BIN 
   test = TRUE
   do i=1,pbt.n_blocks(1)
     if (pbt.block_dim(i) /= 1) then
       test = FALSE
       exit
     end
   end
   if (test) then
     do i=pbt.n_blocks(1)+1,pbt.n_blocks(2)
       if (pbt.block_dim(i) /= 2) then
         test = FALSE
         exit
       end
     end
   end
   if (NOT test) then
     stdout.text("not passed")
   else
     stdout.text("passed")
   end
 end
! de

! davide: 12-11-2018
 check_size1_blocks
 ! check if in the i-th PBT among the blocks of size 1
 ! only the i-th block has a nonzero coefficient
   stdout.text(" ")
   stdout.text("Checking blocks of size 1 in bra set of geminals")
   .check_size1_blocks(.bra_set)
   if (NOT .bra_is_ket) then
     stdout.text(" ")
     stdout.text("Checking blocks of size 1 in ket set of geminals")
     .check_size1_blocks(.ket_set)
   end
 end

 check_size1_blocks(pbt_set)
 ! call to the routine which checks the blocks 
 ! of size 1 in each PBT
 pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
 ng, i :: INT
   ng = size(pbt_set.vec)
   do i=1,ng
     stdout.show("geminal", i)
     .check_size1_blocks(pbt_set.vec(i),i)
   end
 end

 check_size1_blocks(pbt,ind)
 ! check if in the PBT among the blocks of size 1
 ! only the ind-th block has a nonzero coefficient
 pbt :: PAULI_BLOCK_TENSOR, IN
 ind :: INT, IN
 nb, j, check_ind, counter :: INT
   nb = size(pbt.block_dim)
   counter = 0
   do j=1,nb
     if (pbt.block_dim(j) == 1 AND abs(pbt.coef(j)) > TOL(15)) then
       counter = counter + 1
       check_ind = j
     end
   end
   if (counter == 1 AND check_ind == ind) then
     stdout.text("passed")
   else
     stdout.text("not passed")
   end
 end
! de

! davide: 01-11-2018
   check_ortho
   ! check if geminals satisfy 1-orthogonality and 2-orthogonality 
     stdout.text(" ")
     stdout.text("Checking 1- and 2-orthogonality on bra set")
     !.check_ortho(.bra_set,.n_geminals,.n_blocks)
     .check_ortho(.bra_set)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking 1- and 2-orthogonality on ket set")
      ! .check_ortho(.ket_set,.n_geminals,.n_blocks)
       .check_ortho(.ket_set)
     end
   end

   check_ortho(pbt_set)
   ! call to the routines which check the 1- and 2-orthogonality
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   ng, nb :: INT
   i, j :: INT
     ng = size(pbt_set.vec)
     nb = size(pbt_set.type_nb)
     do i=1,ng-1
       do j=i+1,ng
         stdout.text("geminals:")
         stdout.show(" ", i)
         stdout.show(" ", j)
        ! stdout.text("checking 1-orthogonality for blocks of size 1")
        ! .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb, TRUE)
         !stdout.text("checking 1-orthogonality")
         stdout.text("1-orthogonality test")
         .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb)
         !stdout.text("checking 2-orthogonality")
         stdout.text("2-orthogonality test")
         .check_2ortho(pbt_set.vec(i), pbt_set.vec(j), nb)
       end
     end
   end

   check_1ortho(pbt1,pbt2,nb,only_b1_arg)
   ! check 1-orthogonality
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
   nb :: INT
   only_b1_arg :: BIN, optional
   i, counter :: INT
   bb :: VEC{INT}*
   only_b1 :: BIN

     if (present(only_b1_arg)) then
       only_b1 = only_b1_arg
     else
       only_b1 = FALSE
     end

     counter = 0
     allocate(bb(nb))
     if (only_b1) then
       do i=1,nb
         if (pbt1.block_dim(i) == 1) then
           if (abs(pbt1.coef(i)) > TOL(15) AND abs(pbt2.coef(i)) > TOL(15)) then
             counter = counter + 1
             bb(counter) = i
           end
         end
       end
     else
       do i=1,nb
         if (abs(pbt1.coef(i)) > TOL(15) AND abs(pbt2.coef(i)) > TOL(15)) then
           counter = counter + 1
           bb(counter) = i
         end
       end
     end

     if (counter == 0) then
       stdout.text("passed")
     else
       stdout.text("not passed for blocks:")
       do i=1,counter
         stdout.show(" ", bb(i))
       end
     end
     deallocate(bb)
   end

!   check_1ortho(pbt1,pbt2,nb)
!   ! check 1-orthogonality for blocks of size 1
!   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
!   nb :: INT
!   i, counter :: INT
!   bb :: VEC{INT}*
!   counter = 0
!   allocate( bb(pbt1.n_blocks(1)) )
!     do i=1,nb
!       if (pbt1.block_dim(i) == 1) then
!         if (abs(pbt1.coef(i)) > TOL(15) AND abs(pbt2.coef(i)) > TOL(15)) then
!           counter = counter + 1
!           bb(counter) = i
!         end
!       end
!     end
!     if (counter == 0) then
!       stdout.text("passed")
!     else
!       stdout.text("not passed for blocks:")
!!       bb.shrink(counter)
!       do i=1,counter
!         stdout.show(" ", bb(i))
!       end
!     end
!   deallocate(bb)
!   end

!   check_1ortho(pbt1,pbt2,nb)
!   ! check 1-orthogonality
!   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
!   nb :: INT
!   i :: INT
!   check :: REAL
!     check = ZERO
!     do i=1,nb
!       check = check + pbt1.coef(i)*pbt2.coef(i)
!     end
!     if (check < TOL(15)) then
!       stdout.text("1-orthogonality test passed")
!     else
!       stdout.text("1-orthogonality test not passed for blocks:")
!     end
!   end
! de

! davide: 03-11-2018
  check_2ortho(pbt1, pbt2, nb)
  ! check 2-orthogonality
  pbt1, pbt2 :: PAULI_BLOCK_TENSOR
  nb :: INT
  i :: INT
  check, tr :: REAL
    check = ZERO
    do i=1,nb
      if (pbt1.block_dim(i) == 1) then
        check = check + pbt1.coef(i)*pbt2.coef(i)  
      else
        tr = .calc_tr( pbt1.block_type(i), pbt2.block_type(i) )
        check = check + pbt1.coef(i)*pbt2.coef(i)*tr  
      end
    end
    if (abs(check) < TOL(15)) then
      stdout.text("passed")
    else
      stdout.text("not passed")
    end
  end

  calc_tr(bty1, bty2) result (tr)
  ! compute trace of product of two blocks
  ! of type ID2, E11, E22, S+, S-, SX, ISY or SZ
  bty1, bty2 :: STR, IN
  tr :: REAL
    if (bty1 == bty2) then
      if (bty1=="ID2" OR bty1=="SX" OR bty1=="ISY" OR bty1=="SZ") then
        tr = TWO
      else if (bty1=="E11" OR bty1=="E22" OR bty1=="S+" OR bty1=="S-") then
        tr = ONE 
      else
        stdout.text("unknown block type in calc_tr")
        stop
      end
    else
      if (bty1=="ID2" AND (bty2=="E11" OR bty2=="E22")) then 
        tr = ONE
      else if (bty2=="ID2" AND (bty1=="E11" OR bty1=="E22")) then 
        tr = ONE
      else if (bty1=="SX" AND (bty2=="S+" OR bty2=="S-")) then
        tr = ONE
      else if (bty2=="SX" AND (bty1=="S+" OR bty1=="S-")) then
        tr = ONE
      else if ((bty1=="ISY" AND bty2=="S+") OR (bty2=="ISY" AND bty1=="S+")) then
        tr = ONE
      else if ((bty1=="ISY" AND bty2=="S-") OR (bty2=="ISY" AND bty1=="S-")) then
        tr = -ONE
      else if ((bty1=="SZ" AND bty2=="E11") OR (bty2=="SZ" AND bty1=="E11")) then
        tr = ONE
      else if ((bty1=="SZ" AND bty2=="E22") OR (bty2=="SZ" AND bty1=="E22")) then
        tr = -ONE
      else
        tr = ZERO
      end
    end
  end
! de

! davide: 08-11-2018
  check_bra_ket_homogeneity
  ! check if the i-th bra and ket geminals
  ! have the same block structure and zero coefficients
  ! for the same blocks
  i :: INT
    .homogeneous = TRUE
    stdout.text(" ")
    stdout.text("Checking homogeneity of bra and ket sets")
    do i=1,.n_geminals
      stdout.show("bra and ket geminals", i)
      stdout.text("block structure test")
      .check_block_structure(.bra_set.vec(i), .ket_set.vec(i),.homogeneous)
      stdout.text("zero coefficients test")
      .check_nonzero_coef(.bra_set.vec(i), .ket_set.vec(i),.homogeneous)
    end
  end

  check_block_structure(pbt1,pbt2,hom)
  ! check if the two geminals (pbt) have the same block structure,
  ! i.e. the same block types in the same positions
  pbt1, pbt2 :: PAULI_BLOCK_TENSOR, IN
  hom :: BIN
  i, nb :: INT
  passed :: BIN
    passed= TRUE
    nb = size(pbt1.block_dim)
    do i=1,nb
      if (pbt1.block_type(i) /= pbt2.block_type(i)) then
        stdout.show("block structure test not passed for block:",i)
        passed= FALSE
        hom= FALSE
      end
    end
    if (passed) stdout.text("passed")
  end

  check_nonzero_coef(pbt1,pbt2,hom)
  ! check if the two geminals have zero coefficients in the same
  ! positions, i.e. for the same blocks 
  pbt1, pbt2 :: PAULI_BLOCK_TENSOR, IN
  hom :: BIN
  i, nb :: INT
  passed, test1, test2 :: BIN
    passed = TRUE
    nb = size(pbt1.block_dim)
    do i=1,nb
     ! if (abs(pbt1.coef(i)) < TOL(15) AND abs(pbt2.coef(i)) > TOL(15) &
     ! & OR abs(pbt1.coef(i)) > TOL(15)  AND abs(pbt2.coef(i)) < TOL(15)) then
      test1 = FALSE
      test2 = FALSE
      if (abs(pbt2.coef(i))>TOL(15) AND abs(pbt1.coef(i))<TOL(15)) then
         test1 = TRUE 
      end
      if (abs(pbt1.coef(i))>TOL(15) AND abs(pbt2.coef(i))<TOL(15)) then
         test2 = TRUE 
      end
      if (test1 OR test2) then
        stdout.show("not passed for block:",i)
        passed = FALSE
        hom = FALSE
      end
    end
    if (passed) stdout.text("passed")
  end
! de

! davide: 03-11-2018
   check_model_constraints
   ! check if geminals satisfy the constraints of the model 
     .pbt_constraints = TRUE
     stdout.text(" ")
     stdout.text("Checking model constraints on bra set")
     .check_model_constraints(.bra_set)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking model constraints on ket set")
       !.check_model_constraints(.ket_set,.n_geminals,.n_blocks)
       .check_model_constraints(.ket_set)
       .check_bra_ket_homogeneity
       if (NOT .homogeneous) then
         stdout.text("bra and ket not homogeneous")
         stop
       end
     end
   end

   check_model_constraints(pbt_set)
   ! call to the routine which check the model constraints
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   ng, nb :: INT
   i, j :: INT
     ng = size(pbt_set.vec)
     nb = size(pbt_set.type_nb)
     do i=1,ng-1
       do j=i+1,ng
         stdout.text("geminals:")
         stdout.show(" ", i)
         stdout.show(" ", j)
         .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb)
       end
     end
   end

   check_model_constraints(pbt1,pbt2,nb)
   ! check model constraints
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
   nb :: INT
   i, counter :: INT
   bb :: VEC{INT}*
   counter = 0
  ! allocate( bb(pbt1.n_blocks(2)) )
   allocate( bb(nb) )
     do i=1,nb
      ! if (pbt1.block_dim(i) == 2  AND  pbt1.block_type(i) == pbt2.block_type(i)) then
       if (pbt1.block_type(i) == pbt2.block_type(i)) then
         if (abs(pbt1.coef(i)) > TOL(15)  AND  abs(pbt2.coef(i)) > TOL(15)) then
           counter = counter + 1
           bb(counter) = i
         end
       end
     end
     if (counter == 0) then
       stdout.text("passed")
     else
       stdout.text("not passed for blocks:")
       do i=1,counter
         stdout.show(" ", bb(i))
       end
     end
   deallocate(bb)
   end
! de

! davide: 30-10-2018
   norm_gem
   ! normalization of geminals
     stdout.text(" ")
     stdout.text("Normalization of bra set of geminals")
     stdout.text("Normalized geminals - coefficients:")
     .norm_gem(.bra_set,.n_blocks)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Normalization of ket set of geminals")
       stdout.text("Normalized geminals - coefficients:")
       .norm_gem(.ket_set,.n_blocks)
     end
   end

   norm_gem(pbt_set,nb)
   ! call to the normalization routine for each geminal
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   nb :: INT
   i :: INT
     do i=1,.n_geminals
       stdout.show("geminal", i)
       .norm_gem(pbt_set.vec(i),nb)
     end
   end

   norm_gem(pbt,nb)
   ! normalization of one geminal
   pbt :: PAULI_BLOCK_TENSOR
   nb :: INT
   i :: INT
   bty :: STR
   norm :: REAL
   norm = ZERO
     do i=1,nb 
       bty = pbt.block_type(i)
       if (bty=="ID1" OR bty=="S+" OR bty=="S-" OR bty=="E11" OR bty=="E22") then
         norm = norm + pbt.coef(i)*pbt.coef(i)
       else if (bty=="ID2" OR bty=="SX" OR bty=="ISY" OR bty=="SZ") then
         norm = norm + pbt.coef(i)*pbt.coef(i)*2
       else
         stdout.text("unknown block type in norm_gem(pbt,nb)")
         stop
       end
     end
     norm = sqrt(norm)
     pbt.coef = pbt.coef/norm
     stdout.put(pbt.coef)
   end
! de

! davide: 31-10-2018
   find_nonzero_coef
   ! identification of nonzero coefficients in each geminal 
     stdout.text(" ")
     stdout.text("Bra set of geminals - blocks with nonzero coefficient")
     .find_nonzero_coef(.bra_set)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Ket set of geminals - blocks with nonzero coefficient")
       .find_nonzero_coef(.ket_set)
     end
   end

   find_nonzero_coef(pbt_set)
   ! call to the routine for identification of nonzero coefficients
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   i, ng, nb :: INT
     ng = size(pbt_set.vec)
     nb = size(pbt_set.type_nb)
     do i=1,ng
       stdout.show("geminal", i)
       .find_nonzero_coef(pbt_set.vec(i),nb,ng)
     end
   end

   find_nonzero_coef(pbt,nb,ng)
   ! identification of nonzero coefficients in one geminal 
   pbt :: PAULI_BLOCK_TENSOR
   nb, ng :: INT
   i, counter, nn :: INT
   w_vec :: VEC{REAL}*
     allocate(pbt.nonzero_coef(nb))
     allocate(w_vec(0:nb))
    ! allocate(pbt.red_coef(nb))
     !pbt.red_coef = ZERO
     counter = 0
     do i=1,nb 
       !if (pbt.coef(i) /= ZERO) then
       if (abs(pbt.coef(i)) > TOL(15)) then
         counter = counter + 1
         if (pbt.block_dim(i) == 1) then
           pbt.nonzero_coef(counter) = 0
           w_vec(0) = pbt.coef(i)
         else
           nn = i - ng
           pbt.nonzero_coef(counter) = nn
           w_vec(nn) = pbt.coef(i)
         end
       end
     end
     pbt.nonzero_coef.shrink(counter)
     allocate(pbt.red_coef(0:counter-1))
     pbt.red_coef(0:counter-1) = w_vec(0:counter-1) 
     deallocate(w_vec)
     !pbt.red_coef.resize(counter)
     do i=1,counter
       stdout.show( "index =", pbt.nonzero_coef(i) )
       stdout.show( "coef. =", pbt.red_coef(i-1) )
     end
   end
! de

! davide: 09-11-2018
 prep_nonzero_coef_ind
 ! prepare lists of block indices with nonzero coefficients
 ! (one list for each geminal)
  i, siz, j :: INT
   .nonzero_coef_ind.create(.n_geminals)
   stdout.text(" ")
   stdout.text("Indeces of blocks with nonzero coefficient:")
   !stdout.text("(nonzero_coef_ind vectors)")
   do i=1,.n_geminals
     siz = size(.bra_set.vec(i).nonzero_coef)
     .nonzero_coef_ind(i).element.create(siz)
     .nonzero_coef_ind(i).element = .bra_set.vec(i).nonzero_coef
     stdout.show("bra and ket geminals", i)
     do j=1,siz
       stdout.show(" ",.nonzero_coef_ind(i).element(j))
     end
   end
 end
! de

! make_int_term_list
! ! make the list of non zero block indices combinations for integral
! ! formula relevant to the standard PBT model
!   list1 :: VEC_INT_LIST*
!   list2 :: VEC_INT_LIST*
!   i :: INT
!
! .check_bra_ket_homogeneity
! if (NOT .homogeneous) then
!   stdout.text("bra and ket not homogeneous")
!   stop
! end
!
! .check_model_constraints
! if (NOT .pbt_constraints ) then
!   stdout.text("PBT constraints not enforced")
!   stop
! end
! nullify(list1)
! allocate(list1)
!
! ! The construction of combinations is initialized:
! ! the first index of the initial combinations is set 
! ! equal to one element of the first list of indices.
! allocate(list1.item(.n_geminals))
! !list1.item(1)= v(1)%ind(1)
! list1.item(1) = .nonzero_coef_ind(1).element(1)
! nullify(list1.next)
! !do i=2,size(v(1)%ind)
! do i=2,size(.nonzero_coef_ind(1).element)
!   nullify(list2)
!   allocate(list2)
!   allocate(list2.item(.n_geminals))
!   !list2.item(1)= v(1)%ind(i)
!   list2.item(1) = .nonzero_coef_ind(1).element(i)
!   list2.next => list1
!   list1 => list2
! end 
!!
! stdout.text(" ")
! stdout.text("Initialized combinations of indices:")
! do
!   if(NOT associated(list1.next)) then
!      stdout.put(list1.item)
!     exit
!   end
!   stdout.put(list1.item)
!   list1=>list1.next
! end
!
!! stdout.text(" ")
!! stdout.text("nonzero_coef_ind vector sizes:")
!! do i=1,.n_geminals
!!    stdout.show(" ",size(.nonzero_coef_ind(i).element))
!! end
!
!! nc = size(v(1)%ind) ! nc = number of initialized combinations (allocated)
!!                     !      nc = the number of indices in the first list
!! do k=1,nl-1
!!    counter = 0  ! for each value of k, it counts the number of
!!                 ! combinations produced 
!!    do i=1,nc    ! nc = number of combinations (of k indices) already produced
!!Nextgem:       do j=1,size(v(k+1)%ind)
!!          do l=1,k
!!             if (comb(i)%ind(l) == v(k+1)%ind(j) .and. comb(i)%ind(l) /= 0) cycle nextgem
!!          end 
!!          counter = counter + 1
!!          if (.not. allocated(w_vec(counter)%ind)) then
!!             allocate(w_vec(counter)%ind(nl))
!!          end
!!          do ll=1,k
!!             w_vec(counter)%ind(ll) = comb(i)%ind(ll)  
!!          end
!!          w_vec(counter)%ind(k+1) = v(k+1)%ind(j)
!!       end 
!!    end 
!!    do kk = 1,counter
!!       if (.not. allocated(comb(kk)%ind)) then
!!          allocate(comb(kk)%ind(nl))
!!       end 
!!       comb(kk)%ind = w_vec(kk)%ind
!!    end 
!!    nc = counter  ! number of selected combinations at iteration k 
!!    if (debug) then
!!       write(6,'(/,a,i5)') &
!!       & " Selected combinations of indices at iteration", k
!!       do kk = 1,nc 
!!          write(6,'(a,i5,a)') " combination", kk, ":"
!!          write(6,*) (comb(kk)%ind(ii), ii=1,k+1)
!!       end 
!!    end 
!! end 
! end

! davide: 11-11-2018/12-11-2018
 make_int_term_list
 ! make the list of non zero block indices combinations for integral
 ! formula relevant to the standard PBT model
   current_list :: VEC_INT_LIST*
   new_item :: VEC_INT_LIST*
   new_list :: VEC_INT_LIST*
   i, j, k :: INT
   siz :: INT
   parity :: INT
   list_ind :: VEC{INT}*

   .check_model_constraints
   if (NOT .pbt_constraints ) then
     stdout.text("PBT constraints not enforced")
     stop
   end

    .prep_nonzero_coef_ind

!   .n_geminals = 4
!   .nonzero_coef_ind.create(.n_geminals)
!   .nonzero_coef_ind(1).element.create(4)
!   .nonzero_coef_ind(1).element(1) = 0
!   .nonzero_coef_ind(1).element(2) = 1
!   .nonzero_coef_ind(1).element(3) = 3
!   .nonzero_coef_ind(1).element(4) = 4
!   .nonzero_coef_ind(2).element.create(3)
!   .nonzero_coef_ind(2).element(1) = 0
!   .nonzero_coef_ind(2).element(2) = 2
!   .nonzero_coef_ind(2).element(3) = 4
!   .nonzero_coef_ind(3).element.create(3)
!   .nonzero_coef_ind(3).element(1) = 0
!   .nonzero_coef_ind(3).element(2) = 1
!   .nonzero_coef_ind(3).element(3) = 3
!   .nonzero_coef_ind(4).element.create(3)
!   .nonzero_coef_ind(4).element(1) = 0
!   .nonzero_coef_ind(4).element(2) = 2
!   .nonzero_coef_ind(4).element(3) = 3
  
   ! initialize combinations
   nullify(current_list)
   nullify(new_item)
   do i=1,size(.nonzero_coef_ind(1).element)
     allocate(new_item)
     allocate(new_item.item(.n_geminals))
     new_item.item(1) = .nonzero_coef_ind(1).element(i)
     new_item.next => current_list
     current_list => new_item
   end
  
! produce combinations
   parity = 1
   do j=2,.n_geminals
     nullify(new_list)
     siz = size(.nonzero_coef_ind(j).element)
     allocate(list_ind(siz))
     list_ind = .nonzero_coef_ind(j).element(1:siz)
     do
       if (NOT associated(current_list)) exit
       if (parity == -1) then
! taking advantage of the fact that in the model
!there is always a non zero coefficient for
! block 0 which appears as the first element of list_ind
         allocate(new_item)
         allocate(new_item.item(.n_geminals))
         new_item.item(1:j-1) = current_list.item(1:j-1)
         new_item.item(j) = list_ind(1)
         new_item.next => new_list
         new_list => new_item
         do i=2,siz
           if (any(current_list.item(1:j-1) == list_ind(i))) cycle
           allocate(new_item)
           allocate(new_item.item(.n_geminals))
           new_item.item(1:j-1) = current_list.item(1:j-1)
           new_item.item(j) = list_ind(i)
           new_item.next => new_list
           new_list => new_item
         end
       else
         do i=siz,2,-1
           if (any(current_list.item(1:j-1) == list_ind(i))) cycle
           allocate(new_item)
           allocate(new_item.item(.n_geminals))
           new_item.item(1:j-1) = current_list.item(1:j-1)
           new_item.item(j) = list_ind(i)
           new_item.next => new_list
           new_list => new_item
         end
! taking advantage of the fact that in the model
!there is always a non zero coefficient for
! block 0 which appears as the first element of list_ind
         allocate(new_item)
         allocate(new_item.item(.n_geminals))
         new_item.item(1:j-1) = current_list.item(1:j-1)
         new_item.item(j) = list_ind(1)
         new_item.next => new_list
         new_list => new_item
       end
! deallocating the previous list
       new_item=>current_list
       current_list => current_list.next
       deallocate(new_item.item)
       deallocate(new_item)
     end
     current_list => new_list
     parity = -parity
     deallocate(list_ind)
   end

   nullify(.int_term_ind)
   .int_term_ind => current_list
  
   ! write combinations produced
   stdout.text(" ")
   stdout.text("List of block indices combinations for integral")
   stdout.text("formula relevant to the standard PBT model:")
   i = 0
   current_list => .int_term_ind
   do
      if (NOT associated(current_list)) exit
      i = i + 1
      stdout.show("Combination", i)
      stdout.put(current_list.item)
      current_list => current_list.next 
   end

!   stop 

 end


!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

!tempcc !  ===============
!tempcc !  Inquiry methods
!tempcc !  ===============
!tempcc 
!tempcc !   same_as(b) result(res) 
!tempcc !   ! Return TRUE if the basis set "self" is the same as "b". Only the
!tempcc !   ! shell vector is compared to see if they are "really" the same.
!tempcc !      self :: IN
!tempcc !      b :: GEMINAL_MF_SPECTRUM, IN
!tempcc !      res :: BIN
!tempcc !      res = FALSE
!tempcc !   end
!tempcc 
!  ==============
!  Output methods
!  ==============

   put
   ! Print out the object
      n_geminals :: INT
      i :: INT
      bra_is_ket :: BIN
      bra_set :: PAULI_BLOCK_TENSOR_SET

      n_geminals=.n_geminals
      stdout.text(" ")
      stdout.text(" ")
      stdout.text("PBG info:")
      stdout.text(" ")
      stdout.show("number of geminals :",.n_geminals)
      stdout.text(" ")
      stdout.show("number of blocks in each geminal :",.n_blocks)
      stdout.text(" ")
      stdout.show("bra=ket :",.bra_is_ket)
      stdout.text(" ")
      stdout.text(" ")
      do i=1,n_geminals
        stdout.show("block type of bra :",i)
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text(" ")
        stdout.show("block coef. of bra :",i)
        stdout.put(.bra_set.vec(i).coef)
        stdout.text(" ")
        stdout.show("block sizes of bra :",i)
        stdout.put(.bra_set.vec(i).block_dim)
        stdout.text(" ")
        stdout.show("block numbers of bra :",i)
        stdout.put(.bra_set.vec(i).n_blocks)
        stdout.text(" ")
        stdout.show("matrix form of bra :",i)
        stdout.put(.bra_set.vec(i).matrix_form)
        stdout.text(" ")
        stdout.text(" ")
      end
      if(NOT .bra_is_ket) then
        do i=1,n_geminals
          stdout.show("block type of ket :",i)
          stdout.put(.ket_set.vec(i).block_type)
          stdout.text(" ")
          stdout.show("block coef. of ket :",i)
          stdout.put(.ket_set.vec(i).coef)
          stdout.text(" ")
          stdout.show("block sizes of ket :",i)
          stdout.put(.ket_set.vec(i).block_dim)
          stdout.text(" ")
          stdout.show("block numbers of ket :",i)
          stdout.put(.ket_set.vec(i).n_blocks)
          stdout.text(" ")
          stdout.show("matrix form of ket :",i)
          stdout.put(.ket_set.vec(i).matrix_form)
          stdout.text(" ")
          stdout.text(" ")
        end
        .make_type_numbers(.bra_set,.ket_set)
        .make_pauli_trace(.bra_set,.ket_set)
      else
        .make_type_numbers(.bra_set,.bra_set)
        .make_pauli_trace(.bra_set,.bra_set)
      end     
   end


!  ================
!  Integral methods
!  ================

!   make_theorem
!   ! make the formula of our general theorem
!   
!   end


   make_pauli_trace(bra_subset,ket_subset)
   ! make trace of a product of blocks
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks, n_block1, j :: INT
     pauli_trace :: REAL
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
     n_block1=bra_subset.vec(1).n_blocks(1)
     pauli_trace = ZERO
     .make_type_numbers(bra_subset)
     .make_type_numbers(ket_subset)
     select case (n_gem)
       case(1);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
           end
         end
         pauli_trace = 2*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
         end
       case(2);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
           end
         end
         pauli_trace = 8*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
         end
       case(3);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
           end
         end
         pauli_trace = 48*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
         end
       case(4);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
           end
         end
         pauli_trace = 384*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
         end
       case default ;
     end
     stdout.show("trace of product of bra and ket geminals :",pauli_trace)
   end


!  ====================
!  geminal MFCI methods
!  ====================

end
