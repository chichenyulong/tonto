!-------------------------------------------------------------------------------
!
! PAULI_BLOCK_GEMINALS
!
! Copyright (C) Patrick Cassam-Chenai and Thomas Perez, 2018
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id:  $
!
!-------------------------------------------------------------------------------

module PAULI_BLOCK_GEMINALS

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!===============================================================================
!                             Create and Destroy Routines
!===============================================================================

   create(n_geminals,n_bf,mol_name) ::: leaky
   ! Create sets of geminals for bra and ket
      self :: PTR
      mol_name :: STR
      n_geminals,n_bf :: INT
      i :: INT

      nullify(self)
      allocate(self)
      .name=mol_name
      .n_geminals=n_geminals
      .n_block=int((n_bf+1)/2)
      nullify(.bra_set.vec)
      nullify(.ket_set.vec)
      nullify(.bra_set.type_nb)
      nullify(.ket_set.type_nb)
      allocate(.bra_set.vec(n_geminals))
      allocate(.ket_set.vec(n_geminals))
      allocate(.bra_set.type_nb(.n_block))
      allocate(.ket_set.type_nb(.n_block))
      do i=1,.n_block
        nullify(.bra_set.vec(i).block_type)
        nullify(.ket_set.vec(i).block_type)
        nullify(.bra_set.vec(i).coef)
        nullify(.ket_set.vec(i).coef)
        nullify(.bra_set.vec(i).matrix_form)
        nullify(.ket_set.vec(i).matrix_form)
        allocate(.bra_set.vec(i).block_type(.n_block))
        allocate(.ket_set.vec(i).block_type(.n_block))
        allocate(.bra_set.vec(i).coef(.n_block))
        allocate(.ket_set.vec(i).coef(.n_block))
        allocate(.bra_set.vec(i).matrix_form(.n_block*2,.n_block*2))
        allocate(.ket_set.vec(i).matrix_form(.n_block*2,.n_block*2))
      end

   end
!tempcc 
!tempcc    destroy ::: get_from(OBJECT), leaky
!tempcc    ! Destroy an object
!tempcc    end
!tempcc 
!tempcc 
!tempcc    destroy_ptr_part  ::: leaky
!tempcc    ! Destroy the pointer parts of self
!tempcc       .bra.destroy
!tempcc       .ket.destroy
!tempcc       .special_ket.destroy
!tempcc    end
!tempcc 
!tempcc    create_copy(b) ::: leaky
!tempcc    ! Create a copy of "b".
!tempcc      self :: PTR
!tempcc      b :: GEMINAL_MF_SPECTRUM, IN
!tempcc 
!tempcc      .create(b.name,b.nuclear_repulsion_energy,b.n_geminals,b.i_geminals,b.n_bf)
!tempcc      .copy(b)
!tempcc 
!tempcc    end
!tempcc 
!tempcc    copy(b) ::: leaky
!tempcc    ! Copy a basis "b" to "self". Make sure pointer parts are first
!tempcc    ! destroyed or nullified, as you want.
!tempcc       b :: GEMINAL_MF_SPECTRUM, IN
!tempcc       self = b
!tempcc       if (b.bra.created) .bra.create_copy(b.bra)
!tempcc       if (b.ket.created) .ket.create_copy(b.ket)
!tempcc       if (b.special_ket.created) .special_ket.create_copy(b.special_ket)
!tempcc       if (b.contraction_wfs.created) .contraction_wfs.create_copy(b.contraction_wfs)
!tempcc       if (b.contraction_energies.created) .contraction_energies.create_copy(b.contraction_energies)
!tempcc    end
!tempcc 
!tempcc    created result (res) ::: get_from(OBJECT), inlined_by_foo
!tempcc    ! Returns true if self has been created
!tempcc    end
!tempcc 
!tempcc    destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
!tempcc    ! Returns true if self has *not* been created
!tempcc    end

!  ===========
!  Set methods
!  ===========
      set_example
      !set a geminal product example
        self :: PTR
        mol_name :: STR
        n_geminals,n_bf :: INT

        n_bf=6
        mol_name="Be"
        n_geminals=2
        self.create(n_geminals,n_bf,mol_name)
        .bra_set.vec(1).block_type(1)="ID"
        .ket_set.vec(1).block_type(1)="ID"
        .bra_set.vec(1).coef(1)=1.0d0
        .ket_set.vec(1).coef(1)=1.0d0
        .bra_set.vec(2).block_type(1)="SX"
        .ket_set.vec(2).block_type(1)="SX"
        .bra_set.vec(2).coef(1)=2.0d0
        .ket_set.vec(2).coef(1)=2.0d0
        .bra_set.vec(1).block_type(2)="ID"
        .ket_set.vec(1).block_type(2)="ID"
        .bra_set.vec(1).coef(2)=2.0d0
        .ket_set.vec(1).coef(2)=2.0d0
        .bra_set.vec(2).block_type(2)="SX"
        .ket_set.vec(2).block_type(2)="SX"
        .bra_set.vec(2).coef(2)=2.0d0
        .ket_set.vec(2).coef(2)=2.0d0
        .bra_set.vec(1).block_type(3)="ID"
        .ket_set.vec(1).block_type(3)="ID"
        .bra_set.vec(1).coef(3)=2.0d0
        .ket_set.vec(1).coef(3)=2.0d0
        .bra_set.vec(2).block_type(3)="SX"
        .ket_set.vec(2).block_type(3)="SX"
        .bra_set.vec(2).coef(3)=2.0d0
        .ket_set.vec(2).coef(3)=2.0d0

      end
!tempcc    set_defaults(n_geminals,i_geminals,n_bf,name,nuclear_repulsion_energy,n_bas) 
!tempcc    ! Set values to a geminal_mf_spectrum object.
!tempcc      n_geminals,i_geminals,n_bf,n_bas :: INT, optional
!tempcc      name :: STR, optional
!tempcc      nuclear_repulsion_energy :: REAL, optional
!tempcc 
!tempcc      if (present(n_geminals)) .n_geminals = n_geminals
!tempcc      if (present(i_geminals)) .i_geminals = i_geminals
!tempcc      if (present(n_bf)) .n_bf = n_bf
!tempcc      if (present(name)) .name = name
!tempcc      if (present(nuclear_repulsion_energy)) .nuclear_repulsion_energy = nuclear_repulsion_energy
!tempcc      if (present(n_bas)) .n_bas = n_bas
!tempcc 
!tempcc    end
!tempcc 
!tempcc 
!tempcc    set_to_zero_energies
!tempcc    ! set to zero contraction_energies
!tempcc      .contraction_energies = ZERO
!tempcc    end
!tempcc 
!tempcc !  ===============
!tempcc !  INPUT Routines
!tempcc !  ===============
!tempcc 
!tempcc    read_keywords ::: get_from(OBJECT), recursive, leaky
!tempcc    ! Read data from "stdin" using keyword style input.
!tempcc    end
!tempcc 
!tempcc    process_keyword(keyword) ::: leaky
!tempcc    ! Process command "keyword". Any required data needed by the "keyword" is
!tempcc    ! inputted from "stdin".
!tempcc      keyword :: STR, IN
!tempcc      word :: STR
!tempcc      word = keyword
!tempcc      word.to_lower_case
!tempcc      select case (word)
!tempcc        case ("-- Regular options --   ")
!tempcc        case ("}                       "); ! exit surrounding loop
!tempcc        case ("do_overlap              "); .do_overlap
!tempcc        case ("do_hamiltonian          "); .do_hamiltonian
!tempcc        case ("junk=                   "); .read_junk
!tempcc    !    case ("n_bf=                   "); .read_n_bf
!tempcc        case ("put                     "); .put
!tempcc        case ("units=                  "); .read_units
!tempcc        ! These are only for making custom tables for the list type
!tempcc        case ("-- Options for tables --")
!tempcc        case  default ;      UNKNOWN(word)
!tempcc      end
!tempcc    end
!tempcc 
!tempcc    read_units ::: get_from(OBJECT), private
!tempcc    ! Read a string which describes the units to be used
!tempcc    end
!tempcc 
!tempcc    read_junk ::: get_from(OBJECT), private
!tempcc    ! Read in a junk string, useful for ignoring a field
!tempcc    end
!tempcc 
!tempcc    read_geminal(j,mat) ::: private, leaky
!tempcc    ! Read in a new value of ".n_bf", which must be smaller than the initial
!tempcc    ! basis set size. Truncate the coefficient matrices.
!tempcc      j :: INT
!tempcc      mat :: MAT{REAL}*
!tempcc !     ENSURE(.bra.created,"no bra")
!tempcc !     ENSURE(.bra(1).element.created,"no bra elements")
!tempcc !     ENSURE(.ket.created,"no ket")
!tempcc !     ENSURE(.ket(1).element.created,"no ket elements")
!tempcc !     ENSURE(.contraction_wfs.created,"no contraction_wfs")
!tempcc !     ENSURE(.contraction_wfs(1).element.created,"no contraction_wfs elements")
!tempcc      in :: TEXTFILE*
!tempcc      i,k,n,m :: INT
!tempcc      name :: STR
!tempcc 
!tempcc      if (FALSE) self = self
!tempcc 
!tempcc      name="readin_geminal_"//j.to_str.trim
!tempcc      in.create(name)
!tempcc      in.open_for("read")
!tempcc      in.read(n)
!tempcc 
!tempcc      mat = ZERO
!tempcc      do m=1,n
!tempcc        in.read(i)
!tempcc        in.read(k)
!tempcc        in.read(mat(i,k))
!tempcc        !if (in.end_of_file) exit
!tempcc      end
!tempcc 
!tempcc      in.close  
!tempcc      in.destroy
!tempcc 
!tempcc    end
!tempcc 
!tempcc    get_wfs ::: leaky
!tempcc    ! get wave functions from an archive file
!tempcc      wfs_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      j :: INT
!tempcc      
!tempcc      name="wfs_"//.i_geminals.to_str.trim
!tempcc      wfs_archive.set(.name,name)
!tempcc      .get_max_bas
!tempcc      if(.contraction_energies.created) then
!tempcc        .contraction_energies.destroy
!tempcc        .contraction_wfs.destroy
!tempcc      end
!tempcc      .contraction_energies.create(.n_bas)
!tempcc      .set_to_zero_energies
!tempcc      .contraction_wfs.create(.n_bas)
!tempcc      do j=1,.n_bas
!tempcc        .contraction_wfs(j).element.create(.n_bf,.n_bf)
!tempcc      end
!tempcc      wfs_archive.read(.contraction_wfs)
!tempcc    end
!tempcc 
!tempcc    get_ground_state
!tempcc    ! get ground state wave function from an archive file
!tempcc      ground_state_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="ground_state_"//.i_geminals.to_str.trim
!tempcc      ground_state_archive.set(.name,name)
!tempcc      ground_state_archive.read(.bra(.i_geminals).element)
!tempcc      .ket(.i_geminals).element=.bra(.i_geminals).element
!tempcc    end
!tempcc 
!tempcc    get_max_bas
!tempcc    ! get number of basis functions from an archive file
!tempcc      max_bas_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="max_bas_"//.i_geminals.to_str.trim
!tempcc      max_bas_archive.set(.name,name)
!tempcc      max_bas_archive.read(.n_bas)
!tempcc    end

!  ===============
!  other Routines
!  ===============

   make_matrix_form
   ! make matrix form from coef and block types
     temp :: MAT{REAL}*
     
   end

!tempcc !  ====================
!tempcc !  Key related routines
!tempcc !  ====================
!tempcc 
!tempcc    read_keys ::: get_from(OBJECT), leaky
!tempcc    ! Read the "keys".
!tempcc    end
!tempcc 
!tempcc    process_keys ::: get_from(OBJECT), leaky
!tempcc    ! Process each of the words in the "keys" list.
!tempcc    end
!tempcc 
!tempcc    keys_created result (res) ::: get_from(OBJECT)
!tempcc    ! Return TRUE if the list-element keys are created.
!tempcc    end
!tempcc 
!tempcc    set_keys(the_keys) ::: get_from(OBJECT)
!tempcc    ! This is for setting the "keys" externally.
!tempcc    end
!tempcc 
!tempcc    clear_keys ::: get_from(OBJECT), leaky
!tempcc    ! This is for destroying the "keys" externally.
!tempcc    end
!tempcc 
!tempcc !  ===============
!tempcc !  Inquiry methods
!tempcc !  ===============
!tempcc 
!tempcc !   same_as(b) result(res) 
!tempcc !   ! Return TRUE if the basis set "self" is the same as "b". Only the
!tempcc !   ! shell vector is compared to see if they are "really" the same.
!tempcc !      self :: IN
!tempcc !      b :: GEMINAL_MF_SPECTRUM, IN
!tempcc !      res :: BIN
!tempcc !      res = FALSE
!tempcc !   end
!tempcc 
!tempcc !  ==============
!tempcc !  Output methods
!tempcc !  ==============
!tempcc 
!tempcc    put
!tempcc    ! Print out the object
!tempcc       i,j,k :: INT
!tempcc       stdout.text("GEMINAL_MF_SPECTRUM:")
!tempcc       stdout.text(" ")
!tempcc       stdout.show("i_geminals =",.i_geminals)
!tempcc !      stdout.show("n_bf       =",.n_bf)
!tempcc       stdout.show("n_bas       =",.n_bas)
!tempcc       stdout.text(" ")
!tempcc       stdout.text("Bra:")
!tempcc       do i = 2,.n_geminals
!tempcc          stdout.text("Bra "//i.to_str.trim//" non zero elements")
!tempcc !         stdout.put(.bra(i).element)
!tempcc ! could use a while loop
!tempcc         do j=1,.n_bf
!tempcc         do k=1,.n_bf
!tempcc           if (NOT .bra(i)[j,k].is_zero) then
!tempcc             write(6,*)"j,k,element:",j,k,.bra(i)[j,k]
!tempcc             !stdout.show("j,k,element:",[j,k,.bra(i)[j,k]])
!tempcc           end
!tempcc         end
!tempcc         end
!tempcc       end
!tempcc       stdout.text("Ket:")
!tempcc       do i = 2,.n_geminals
!tempcc          stdout.text("Special ket "//i.to_str.trim)
!tempcc          stdout.put(.special_ket(i).element)
!tempcc          stdout.text("Ket "//i.to_str.trim//" non zero elements")
!tempcc !         stdout.put(.ket(i).element)
!tempcc         do j=1,.n_bf
!tempcc         do k=1,.n_bf
!tempcc           if (NOT .ket(i)[j,k].is_zero) then
!tempcc             write(6,*)"j,k,element:",j,k,.ket(i)[j,k]
!tempcc             !stdout.show("j,k,element:",[j,k,.ket(i)[j,k]])
!tempcc           end
!tempcc         end
!tempcc         end
!tempcc       end
!tempcc       stdout.text("Contraction 1:")
!tempcc       do i = 1,.n_bas
!tempcc         stdout.text("Wave function "//i.to_str.trim//" non zero elements")
!tempcc         do j=1,.n_bf
!tempcc         do k=1,.n_bf
!tempcc           if (NOT .contraction_wfs(i)[j,k].is_zero) then
!tempcc             write(6,*)"j,k,element:",j,k,.contraction_wfs(i)[j,k]
!tempcc             !stdout.show("j,k,element:",[j,k,.contraction_wfs(i)[j,k]])
!tempcc           end
!tempcc         end
!tempcc         end
!tempcc       end
!tempcc    end
!tempcc 
!tempcc    put_ground_state_geminals
!tempcc    ! Print out the object
!tempcc       i,j,k :: INT
!tempcc       stdout.text("ground state geminals:")
!tempcc       stdout.text(" ")
!tempcc       stdout.show("i_geminals =",.i_geminals)
!tempcc       stdout.text(" ")
!tempcc       stdout.text("Spectators:")
!tempcc       do i = 2,.n_geminals
!tempcc          stdout.text("Spectator"//i.to_str.trim//" non zero elements")
!tempcc ! could use a while loop
!tempcc         do j=1,.n_bf
!tempcc         do k=1,.n_bf
!tempcc           if (NOT .bra(i)[j,k].is_zero) then
!tempcc             write(6,*)"j,k,element:",j,k,.bra(i)[j,k]
!tempcc             !stdout.show("j,k,element:",[j,k,.bra(i)[j,k]])
!tempcc           end
!tempcc         end
!tempcc         end
!tempcc       end
!tempcc       stdout.text("Active:")
!tempcc       do j=1,.n_bf
!tempcc       do k=1,.n_bf
!tempcc         if (NOT .contraction_wfs(1)[j,k].is_zero) then
!tempcc           write(6,*)"j,k,element:",j,k,.contraction_wfs(1)[j,k]
!tempcc         end
!tempcc       end
!tempcc       end
!tempcc       stdout.text(" ")
!tempcc    end
!tempcc 
!tempcc    put_wfs
!tempcc    ! save wave functions in an archive file
!tempcc      wfs_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="wfs_"//.i_geminals.to_str.trim
!tempcc      wfs_archive.set(.name,name)
!tempcc      wfs_archive.write(.contraction_wfs(1:.n_bas))
!tempcc      .put_max_bas
!tempcc    end
!tempcc 
!tempcc    put_ground_state
!tempcc    ! save ground state wave function in an archive file
!tempcc      ground_state_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="ground_state_"//.i_geminals.to_str.trim
!tempcc      ground_state_archive.set(.name,name)
!tempcc      ground_state_archive.write(.contraction_wfs(1).element)
!tempcc    end
!tempcc 
!tempcc    put_max_bas
!tempcc    ! save number of basis functions in an archive file
!tempcc      max_bas_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="max_bas_"//.i_geminals.to_str.trim
!tempcc      max_bas_archive.set(.name,name)
!tempcc      max_bas_archive.write(.n_bas)
!tempcc    end
!tempcc 
!tempcc !  ===============
!tempcc !  Integral methods
!tempcc !  ===============
!tempcc 
!tempcc !todolater   do_2rdm(ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l)
!tempcc !todolater   ! Evaluate the 2 electron density matrix element in a geminal induced basis set
!tempcc !todolater   ! built over orthonormal orbitals
!tempcc !todolater     ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l :: INT
!tempcc !todolater     res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc !todolater   !debug   write(*,*) ".n_bas",.n_bas,".n_bf",.n_bf
!tempcc !todolater      res = .two_rdm(ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l)
!tempcc !todolater      stdout.text("The 2 electron density matrix element is ")
!tempcc !todolater      stdout.put(res)
!tempcc !todolater   end
!tempcc ! have to store all the 2RDM matrix elements 
!tempcc ! for the .n_bas*.n_bas pairs of functions of contraction 1
!tempcc 
!tempcc    electric_dipole_x result (res)
!tempcc    ! Evaluate the electric_dipole x component matrix for a given geminal contraction
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
!tempcc      v :: MAT4{REAL}*
!tempcc      edm_archive :: ARCHIVE
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      i,j :: INT
!tempcc 
!tempcc      edm_archive.set(.name,"Dx_integrals")
!tempcc      v.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc      edm_archive.read(v)
!tempcc      reorder_ket.create(.n_geminals)
!tempcc      reorder_ket = [ (i, i=1,.n_geminals) ]
!tempcc      res=ZERO
!tempcc      res = .hamiltonian_for(v,reorder_ket) 
!tempcc      do i=1,.n_bas
!tempcc      do j=1,i-1
!tempcc      res(i,j) = res(j,i)
!tempcc      end
!tempcc      end
!tempcc      reorder_ket.destroy
!tempcc      v.destroy
!tempcc    end
!tempcc 
!tempcc    electric_dipole_y result (res)
!tempcc    ! Evaluate the electric_dipole y component matrix for a given geminal contraction
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
!tempcc      v :: MAT4{REAL}*
!tempcc      edm_archive :: ARCHIVE
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      i,j :: INT
!tempcc 
!tempcc      edm_archive.set(.name,"Dy_integrals")
!tempcc      v.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc      edm_archive.read(v)
!tempcc      reorder_ket.create(.n_geminals)
!tempcc      reorder_ket = [ (i, i=1,.n_geminals) ]
!tempcc      res=ZERO
!tempcc      res = .hamiltonian_for(v,reorder_ket) 
!tempcc      do i=1,.n_bas
!tempcc      do j=1,i-1
!tempcc      res(i,j) = res(j,i)
!tempcc      end
!tempcc      end
!tempcc      reorder_ket.destroy
!tempcc      v.destroy
!tempcc    end
!tempcc 
!tempcc    electric_dipole_z result (res)
!tempcc    ! Evaluate the electric_dipole z component matrix for a given geminal contraction
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
!tempcc      v :: MAT4{REAL}*
!tempcc      edm_archive :: ARCHIVE
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      i,j :: INT
!tempcc 
!tempcc      edm_archive.set(.name,"Dz_integrals")
!tempcc      v.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc      edm_archive.read(v)
!tempcc      reorder_ket.create(.n_geminals)
!tempcc      reorder_ket = [ (i, i=1,.n_geminals) ]
!tempcc      res=ZERO
!tempcc      res = .hamiltonian_for(v,reorder_ket) 
!tempcc      do i=1,.n_bas
!tempcc      do j=1,i-1
!tempcc      res(i,j) = res(j,i)
!tempcc      end
!tempcc      end
!tempcc      reorder_ket.destroy
!tempcc      v.destroy
!tempcc    end
!tempcc   
!tempcc    hamiltonian result (res)
!tempcc    ! Evaluate the hamiltonian matrix for a given geminal contraction
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
!tempcc      v :: MAT4{REAL}*
!tempcc      eri_archive :: ARCHIVE
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      i,j :: INT
!tempcc 
!tempcc      eri_archive.set(.name,"h_integrals")
!tempcc      v.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc      eri_archive.read(v)
!tempcc      reorder_ket.create(.n_geminals)
!tempcc      reorder_ket = [ (i, i=1,.n_geminals) ]
!tempcc      res=ZERO
!tempcc      res = .hamiltonian_for(v,reorder_ket) 
!tempcc      do i=1,.n_bas
!tempcc      do j=1,i-1
!tempcc      res(i,j) = res(j,i)
!tempcc      end
!tempcc  !    res(i,i) = res(i,i) + .nuclear_repulsion_energy
!tempcc      end
!tempcc      reorder_ket.destroy
!tempcc      v.destroy
!tempcc    end
!tempcc 
!tempcc    hamiltonian(i) result (res)
!tempcc    ! Evaluate the hamiltonian matrix for a given geminal contraction
!tempcc      i :: INT
!tempcc      res :: VEC{REAL}(.n_bas)
!tempcc      ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
!tempcc      v :: MAT4{REAL}*
!tempcc      eri_archive :: ARCHIVE
!tempcc      reorder_ket :: VEC{INT}*
!tempcc 
!tempcc      eri_archive.set(.name,"h_integrals")
!tempcc      v.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc      eri_archive.read(v)
!tempcc      reorder_ket.create(.n_geminals)
!tempcc      reorder_ket = [ (i, i=1,.n_geminals) ]
!tempcc    !  res.create(.n_bas)
!tempcc      res=ZERO
!tempcc      res = .hamiltonian_for(v,reorder_ket,i)
!tempcc   !   if(i==j) res = res +.nuclear_repulsion_energy
!tempcc      reorder_ket.destroy
!tempcc      v.destroy
!tempcc    end
!tempcc 
!tempcc    hamiltonian(i,j) result (res)
!tempcc    ! Evaluate the hamiltonian matrix for a given geminal contraction
!tempcc      i,j :: INT
!tempcc      res :: REAL
!tempcc      ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
!tempcc      v :: MAT4{REAL}*
!tempcc      eri_archive :: ARCHIVE
!tempcc      reorder_ket :: VEC{INT}*
!tempcc 
!tempcc      eri_archive.set(.name,"h_integrals")
!tempcc      v.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc      eri_archive.read(v)
!tempcc      reorder_ket.create(.n_geminals)
!tempcc      reorder_ket = [ (i, i=1,.n_geminals) ]
!tempcc      res=ZERO
!tempcc      res = .hamiltonian_for(v,reorder_ket,j,i)
!tempcc   !   if(i==j) res = res +.nuclear_repulsion_energy
!tempcc      reorder_ket.destroy
!tempcc      v.destroy
!tempcc    end
!tempcc 
!tempcc    make_RHM(rhm)
!tempcc    ! make reduced hamiltonian matrix 
!tempcc      rhm ::  MAT{REAL}*
!tempcc      v :: MAT4{REAL}*
!tempcc      i,j,k,l,m,n :: INT
!tempcc      eri_archive :: ARCHIVE
!tempcc      rhm = ZERO
!tempcc      eri_archive.set(.name,"h_integrals")
!tempcc      v.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc      eri_archive.read(v)
!tempcc      do i=1,.n_bas
!tempcc        do k=1,.n_bf
!tempcc          do l=1,.n_bf
!tempcc            if(NOT .contraction_wfs(i)[k,l].is_zero)then
!tempcc              do j=1,.n_bas
!tempcc                do m=1,.n_bf
!tempcc                  do n=1,.n_bf
!tempcc                    if(NOT .contraction_wfs(j)[m,n].is_zero)then
!tempcc                      rhm(i,j)=rhm(i,j)+ &
!tempcc               .contraction_wfs(i)[k,l]*.contraction_wfs(j)[m,n]*v(k,l,m,n)
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc          end
!tempcc        end
!tempcc      end
!tempcc      v.destroy
!tempcc    end
!tempcc 
!tempcc !to do one day ...: fix the indentation of the tests if(NOT fac.is_zero(.tol)) in
!tempcc !Hamiltonian_for functions
!tempcc ! change .n_bf into n_bf after adding n_bf=.n_bf at the beginning of the
!tempcc ! recursive functions
!tempcc 
!tempcc    hamiltonian_for(v,order_ket) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the hamiltonian integrals matrix
!tempcc    ! between mean field (Sz=0)-geminals 
!tempcc    ! v is the array containing the hf integrals of the 2-electron Hamiltonian.
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if ii is a special ket,
!tempcc !then jj>ii is also a special ket. This allows some simplifications but may be a
!tempcc !bit limitative in the future.
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      v :: MAT4{REAL}, IN
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      row_ind, col_ind :: INT
!tempcc      ii,jj,kk,j,k,l,dim,bi1,bi2,bj1,bj2,bk1,bk2,bq1,bq2 :: INT
!tempcc      fac :: REAL
!tempcc      reorder_ket,reorder_bra :: VEC{INT}*
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_bra_i :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_h2_q ::  MAT{REAL}*
!tempcc      temp_qa_h2 :: MAT4{REAL}*
!tempcc      temp_qb_h2 :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ex :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ex :: MAT4{REAL}*
!tempcc      temp_qa_h2_jb :: MAT4{REAL}*
!tempcc      temp_qb_h2_ja :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_jb_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_ja_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ex_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ex_kb :: MAT4{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_q_h2_ja_kb :: MAT{REAL}*
!tempcc      temp_q_h2_jb_ka :: MAT{REAL}*
!tempcc      temp_qa_h2_j :: MAT{REAL}*
!tempcc      temp_qb_h2_j :: MAT{REAL}*
!tempcc 
!tempcc      nullify(temp_qa_h2_ja)
!tempcc      nullify(temp_qb_h2_jb)
!tempcc      nullify(temp_qa_h2_jb)
!tempcc      nullify(temp_qb_h2_ja)
!tempcc      nullify(temp_qa_h2_ja_ex)
!tempcc      nullify(temp_qb_h2_jb_ex)
!tempcc      nullify(temp_qa_ja)
!tempcc      nullify(temp_qb_jb)
!tempcc      nullify(temp_q_h2_ja_kb)
!tempcc      nullify(temp_q_h2_jb_ka)
!tempcc      nullify(temp_qb_h2_jb_kb)
!tempcc      nullify(temp_qb_h2_jb_ex_kb)
!tempcc      nullify(temp_qa_h2_ja_ka)
!tempcc      nullify(temp_qa_h2_ja_ex_ka)
!tempcc      nullify(temp_qa_h2_ja_kb)
!tempcc      nullify(temp_qb_h2_jb_ka)
!tempcc      nullify(temp_qa_h2_jb_ka)
!tempcc      nullify(temp_qb_h2_ja_kb)
!tempcc      dim = order_ket.dim
!tempcc      res = ZERO
!tempcc       
!tempcc      if (dim==1) then ! case 1.2 only
!tempcc        j = order_ket(1)
!tempcc        DIE_IF(j/=1,"dim=1 but j not 1")
!tempcc        temp_h2_q.create(.n_bf,.n_bf)
!tempcc        do col_ind=1,.n_bas
!tempcc          do bj2=1,.n_bf
!tempcc          do bj1=1,.n_bf
!tempcc            temp_h2_q(bj1,bj2) = sum(v(bj1,bj2,:,:)*.contraction_wfs(col_ind)[:,:])
!tempcc          end
!tempcc          end
!tempcc          do row_ind=1,col_ind
!tempcc            res(row_ind,col_ind) = sum(.contraction_wfs(row_ind)[:,:]*temp_h2_q)
!tempcc          end
!tempcc        end
!tempcc        temp_h2_q.destroy
!tempcc     !debug           write(*,*) 'case 1.2',dim,res
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        temp_bra_q => .bra(dim)[:,:]
!tempcc        reorder_ket.create(dim-1)
!tempcc !the next two arrays are created here because they are small and used in all
!tempcc !cases
!tempcc        temp_qa_h2_j.create(.n_bf,.n_bf)
!tempcc        temp_qb_h2_j.create(.n_bf,.n_bf)
!tempcc        temp_qa_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc        temp_qb_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc        do bj2=1,.n_bf
!tempcc        do bj1=1,.n_bf
!tempcc        do bq2=1,.n_bf
!tempcc        do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc          temp_qa_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(:,bq2)*v(:,bq1,bj1,bj2))
!tempcc          temp_qb_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(bq1,:)*v(bq2,:,bj1,bj2))
!tempcc        end
!tempcc        end
!tempcc        end
!tempcc        end
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc !debug   write(*,*) "jj,j",jj,j
!tempcc          if (j==1) then !ket from contraction 1
!tempcc            DIE_IF(jj/=1,"j is 1 but jj not 1")
!tempcc            do col_ind=1,.n_bas
!tempcc              temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc              if(temp_qa_h2_ja.destroyed) then
!tempcc                temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc   !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc   ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc   !must be done for each subcase.
!tempcc                temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qa_ja.create(.n_bf,.n_bf)
!tempcc                temp_qb_jb.create(.n_bf,.n_bf)
!tempcc              end
!tempcc              do bj2=1,.n_bf
!tempcc              do bq2=1,.n_bf
!tempcc                temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
!tempcc                temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
!tempcc              end
!tempcc              end
!tempcc              do bj2=1,.n_bf
!tempcc              do bj1=1,.n_bf
!tempcc              do bq2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc                temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc                temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc                temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc                temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
!tempcc                temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc              end
!tempcc              end
!tempcc !case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk) !cannot be 1
!tempcc !debug                write(*,*) "kk,k",kk,k
!tempcc                DIE_IF(k<2,"k cannot be 1")  !debug
!tempcc                reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) =  k
!tempcc                if (.special_ket(k)[1]==0) then !k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc !case 2.3
!tempcc                  if(temp_qa_h2_ja_kb.destroyed) then
!tempcc                    temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
!tempcc                    temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
!tempcc                    temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                    temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                  end
!tempcc !case 2.3.1 call special overlap ab
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                    temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                    temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                    temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  reorder_bra.create(dim-2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bk1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        do bq1=1,.n_bf
!tempcc                        do bi2=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                             + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                             + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                             + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(:,col_ind) = res(:,col_ind) &
!tempcc                            + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2)*fac
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do row_ind = 1, col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bk1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        do bi2=1,.n_bf
!tempcc                        do bq1=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                             + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                             + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                             + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                            + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac 
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc !debug                 write(*,*) 'case 2.3.1',dim,res
!tempcc !case 2.3.2 call special overlap aa
!tempcc                  temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
!tempcc                  temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                    temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk1
!tempcc                      do bj1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj1 
!tempcc                        do bi1=1,.n_bf
!tempcc                        do bq1=1,.n_bf
!tempcc                          fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                             + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(:,col_ind) = res(:,col_ind) &
!tempcc                            + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac 
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk1
!tempcc                      do bj1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj1 
!tempcc                        do bi1=1,.n_bf
!tempcc                        do bq1=1,.n_bf
!tempcc                          fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                             + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                            + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc !debug                 write(*,*) 'case 2.3.2',dim,res
!tempcc !case 2.3.3 call special overlap bb
!tempcc                  temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
!tempcc                  temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                    temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bk2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      do bj2=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj2 
!tempcc                        do bi2=1,.n_bf
!tempcc                        do bq2=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                             + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(:,col_ind) = res(:,col_ind) &
!tempcc                            + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! <<
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bk2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      do bj2=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj2 
!tempcc                        do bi2=1,.n_bf
!tempcc                        do bq2=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                             + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                            + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  reorder_bra.destroy
!tempcc !debug                 write(*,*) 'case 2.3.3',dim,res
!tempcc !case 2.2
!tempcc                 ! if(temp_q_h2_ja_kb.destroyed) then
!tempcc                 !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
!tempcc                 !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
!tempcc                 ! end
!tempcc                 ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
!tempcc                 ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
!tempcc                      temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
!tempcc                      fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        res(:,col_ind) = res(:,col_ind) &
!tempcc                        - .overlap_for(reorder_ket,col_ind) * fac 
!tempcc                      end 
!tempcc                    end 
!tempcc                  end
!tempcc !debug                 write(*,*) 'case 2.2',dim,res
!tempcc !case 2.1
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        res(:,col_ind) = res(:,col_ind) &
!tempcc                        - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc !debug                 write(*,*) 'case 2.1',dim,res
!tempcc                else !k special
!tempcc                  bk1=.special_ket(k)[1]
!tempcc                  bk2=.special_ket(k)[2]
!tempcc !case 2.3
!tempcc !case 2.3.1 call special overlap ab
!tempcc                  !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                  !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
!tempcc                  !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
!tempcc                  !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                  reorder_bra.create(dim-2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,bk2-1
!tempcc                 !    .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
!tempcc                        end 
!tempcc                      end
!tempcc                      end
!tempcc                    end
!tempcc                    do bj2=bk2+1,.n_bf
!tempcc                    ! .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <
!tempcc                        end 
!tempcc                      end 
!tempcc                      end 
!tempcc                    end
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                    do bj1=1,bk1-1
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                 !    .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    do bj1=bk1+1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                  !   .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                   !   .special_ket(k)[2] = bk2
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(:,col_ind) = res(:,col_ind) &
!tempcc                        + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bj2=1,bk2-1
!tempcc                 !    .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                          + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                        end 
!tempcc                      end
!tempcc                      end
!tempcc                    end
!tempcc                    do bj2=bk2+1,.n_bf
!tempcc                    ! .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                          + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                        end 
!tempcc                      end 
!tempcc                      end 
!tempcc                    end
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                    do bj1=1,bk1-1
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                 !    .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                          + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    do bj1=bk1+1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                  !   .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                          + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                   !   .special_ket(k)[2] = bk2
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                        + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end 
!tempcc                  .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!tempcc !debug                 write(*,*) 'case 2.3.1',dim,res
!tempcc !case 2.3.2 call special overlap aa
!tempcc                 !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
!tempcc                 !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                !     .special_ket(k)[2] = bk1
!tempcc                      do bi1=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                           + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac ! <
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                  !   .special_ket(k)[2] = bk1
!tempcc                      do bi1=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                           + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                          + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc !debug                 write(*,*) 'case 2.3.2',dim,res
!tempcc !case 2.3.3 call special overlap bb
!tempcc                !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
!tempcc                !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                  !   .special_ket(k)[2] = bk2
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                           + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! <<
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                   !  .special_ket(k)[2] = bk2
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                           + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                          + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  reorder_bra.destroy
!tempcc !debug                 write(*,*) 'case 2.3.3',dim,res
!tempcc !case 2.2
!tempcc                  !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                  do bj2=1,bk2-1
!tempcc                    temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                    fac= temp_q_h2_ja_kb.trace
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                  !  .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                    temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                    fac= temp_q_h2_ja_kb.trace
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                  !  .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2
!tempcc                  !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                  do bj1=1,bk1-1
!tempcc                    temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                    fac= temp_q_h2_jb_ka.trace
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                 !   .special_ket(k)[2] = bk2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                    fac= temp_q_h2_jb_ka.trace
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                 !   .special_ket(k)[2] = bk2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
!tempcc                  fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc              !    .special_ket(k)[1] = bk1 
!tempcc              !    .special_ket(k)[2] = bk2
!tempcc                    res(:,col_ind) = res(:,col_ind) &
!tempcc                    - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                  end 
!tempcc !debug                 write(*,*) 'case 2.2',dim,res
!tempcc !case 2.1
!tempcc                  do bj2=1,bk2-1
!tempcc                    fac= temp_qa_ja(bk2,bj2)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                   !  .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                    fac= temp_qa_ja(bk2,bj2)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                   !  .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bj1=1,bk1-1
!tempcc                    fac= temp_qb_jb(bk1,bj1)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    fac= temp_qb_jb(bk1,bj1)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                  !  .special_ket(k)[1] = bk1 
!tempcc                  !  .special_ket(k)[2] = bk2
!tempcc                    res(:,col_ind) = res(:,col_ind) &
!tempcc                    - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                  end
!tempcc !debug                 write(*,*) 'case 2.1',dim,res
!tempcc                end !k special
!tempcc              end !do kk
!tempcc              nullify(temp_q_h2_ja_kb)
!tempcc              nullify(temp_q_h2_jb_ka)
!tempcc              temp_qb_h2_jb_ka.destroy
!tempcc              nullify(temp_qb_h2_jb_kb)
!tempcc              nullify(temp_qb_h2_jb_ex_kb)
!tempcc              temp_qa_h2_ja_kb.destroy
!tempcc              nullify(temp_qa_h2_ja_ka)
!tempcc              nullify(temp_qa_h2_ja_ex_ka)
!tempcc              temp_qa_h2_jb_ka.destroy
!tempcc              temp_qb_h2_ja_kb.destroy
!tempcc !case 1.3
!tempcc              temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
!tempcc              temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
!tempcc              !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
!tempcc              !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
!tempcc           !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc !debug             stdout.put(reorder_ket)
!tempcc              reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
!tempcc              reorder_bra.create(dim-2)
!tempcc              do ii=dim-1,2,-1
!tempcc                temp_bra_i => .bra(ii)[:,:]
!tempcc                reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    res(:,col_ind) = res(:,col_ind) &
!tempcc                    - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                end
!tempcc              end !ii case ii=1 remains 
!tempcc              reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc              do row_ind=1,col_ind
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                    - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                end
!tempcc              end
!tempcc              reorder_bra.destroy
!tempcc !debug                 write(*,*) 'case 1.3',dim,res
!tempcc !case 1.2
!tempcc              fac=temp_qb_h2_j.trace
!tempcc              if( NOT fac.is_zero(.tol)) then
!tempcc                res(:,col_ind) = res(:,col_ind) &
!tempcc                + .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc              end 
!tempcc !debug                 write(*,*) 'case 1.2',dim,res
!tempcc !case 1.1
!tempcc              fac=temp_qb_jb.trace
!tempcc              if( NOT fac.is_zero(.tol)) then
!tempcc                res(:,col_ind) = res(:,col_ind) &
!tempcc                + .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc              end 
!tempcc !debug                 write(*,*) 'case 1.1',dim,res
!tempcc            end !do col_ind
!tempcc          else !j>1
!tempcc            if (.special_ket(j)[1]==0) then !j not special
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc              if(temp_qa_h2_ja.destroyed) then
!tempcc                temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc                temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qa_ja.create(.n_bf,.n_bf)
!tempcc                temp_qb_jb.create(.n_bf,.n_bf)
!tempcc              end
!tempcc              do bj2=1,.n_bf
!tempcc              do bq2=1,.n_bf
!tempcc                temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
!tempcc                temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
!tempcc              end
!tempcc              end
!tempcc              do bj2=1,.n_bf
!tempcc              do bj1=1,.n_bf
!tempcc              do bq2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc                temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc                temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc                temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc                temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
!tempcc                temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc              end
!tempcc              end
!tempcc !case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk) !cannot be 1
!tempcc !debug               write(*,*) 'kk,k',kk,k
!tempcc                DIE_IF(k<2,"k cannot be 1")  !debug
!tempcc                reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) =  k
!tempcc                if (.special_ket(k)[1]==0) then !k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc !case 2.3
!tempcc                  if(temp_qa_h2_ja_kb.destroyed) then
!tempcc                    temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
!tempcc                    temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
!tempcc                    temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                    temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                  end
!tempcc !case 2.3.1 call special overlap ab
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                    temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                    temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                    temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  reorder_bra.create(dim-2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bk1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        do bq1=1,.n_bf
!tempcc                        do bi2=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                             + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                             + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                             + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do col_ind=1,.n_bas
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bk1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        do bi2=1,.n_bf
!tempcc                        do bq1=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                             + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                             + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                             + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                            + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc !debug               write(*,*) 'case 2.3.1',dim,res
!tempcc !case 2.3.2 call special overlap aa
!tempcc                  temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
!tempcc                  temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                    temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk1
!tempcc                      do bj1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj1 
!tempcc                        do bi1=1,.n_bf
!tempcc                        do bq1=1,.n_bf
!tempcc                          fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                             + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,bi1,bq1) * fac ! <<
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do col_ind=1,.n_bas
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk1
!tempcc                      do bj1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj1 
!tempcc                        do bi1=1,.n_bf
!tempcc                        do bq1=1,.n_bf
!tempcc                          fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                             + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                            + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc !debug              write(*,*) 'case 2.3.2',dim,res
!tempcc !case 2.3.3 call special overlap bb
!tempcc                  temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
!tempcc                  temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                    temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bk2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      do bj2=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj2 
!tempcc                        do bi2=1,.n_bf
!tempcc                        do bq2=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                             + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,bi2,bq2) * fac ! <
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do col_ind=1,.n_bas
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bk2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      do bj2=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj2 
!tempcc                        do bi2=1,.n_bf
!tempcc                        do bq2=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                             + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                          if( NOT fac.is_zero(.tol)) then
!tempcc                            res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                            + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                          end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  reorder_bra.destroy
!tempcc !debug               write(*,*) 'case 2.3.3',dim,res
!tempcc !case 2.2
!tempcc                 ! if(temp_q_h2_ja_kb.destroyed) then
!tempcc                 !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
!tempcc                 !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
!tempcc                 ! end
!tempcc                 ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
!tempcc                 ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
!tempcc                      temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
!tempcc                      fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                  end
!tempcc !debug               write(*,*) 'case 2.2',dim,res
!tempcc !case 2.1
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc !debug               write(*,*) 'case 2.1',dim,res
!tempcc                else !k special
!tempcc                  bk1=.special_ket(k)[1]
!tempcc                  bk2=.special_ket(k)[2]
!tempcc !case 2.3
!tempcc !case 2.3.1 call special overlap ab
!tempcc                  !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                  !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
!tempcc                  !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
!tempcc                  !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                  reorder_bra.create(dim-2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,bk2-1
!tempcc                 !    .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
!tempcc                        end 
!tempcc                      end
!tempcc                      end
!tempcc                    end
!tempcc                    do bj2=bk2+1,.n_bf
!tempcc                    ! .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
!tempcc                        end 
!tempcc                      end 
!tempcc                      end 
!tempcc                    end
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                    do bj1=1,bk1-1
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                 !    .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                        if( NOT fac.is_zero(.tol)) then
!tempcc                          res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
!tempcc                        end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    do bj1=bk1+1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                  !   .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                   !   .special_ket(k)[2] = bk2
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do col_ind=1,.n_bas
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bj2=1,bk2-1
!tempcc                 !    .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                        + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end
!tempcc                      end
!tempcc                    end
!tempcc                    do bj2=bk2+1,.n_bf
!tempcc                    ! .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                        + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end 
!tempcc                    end
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                    do bj1=1,bk1-1
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                 !    .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                        + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    do bj1=bk1+1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                  !   .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                        + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                   !   .special_ket(k)[2] = bk2
!tempcc                      res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                      + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end 
!tempcc                  end 
!tempcc                  .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!tempcc !debug               write(*,*) 'case 2.3.1',dim,res
!tempcc !case 2.3.2 call special overlap aa
!tempcc                 !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
!tempcc                 !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                !     .special_ket(k)[2] = bk1
!tempcc                      do bi1=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                           + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do col_ind=1,.n_bas
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                  !   .special_ket(k)[2] = bk1
!tempcc                      do bi1=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                           + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                        + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc !debug               write(*,*) 'case 2.3.2',dim,res
!tempcc !case 2.3.3 call special overlap bb
!tempcc                !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
!tempcc                !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                  !   .special_ket(k)[2] = bk2
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                           + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do col_ind=1,.n_bas
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                   !  .special_ket(k)[2] = bk2
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                           + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                        + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  reorder_bra.destroy
!tempcc !debug               write(*,*) 'case 2.3.3',dim,res
!tempcc !case 2.2
!tempcc                  !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                  do bj2=1,bk2-1
!tempcc                    temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                    fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                    temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                    fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2
!tempcc                  !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                  do bj1=1,bk1-1
!tempcc                    temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                    fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                 !  .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                    fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                 !  .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
!tempcc                  fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              !    .special_ket(k)[1] = bk1 
!tempcc              !    .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc !debug               write(*,*) 'case 2.2',dim,res
!tempcc !case 2.1
!tempcc                  do bj2=1,bk2-1
!tempcc                    fac= temp_qa_ja(bk2,bj2)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                   !  .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                    fac= temp_qa_ja(bk2,bj2)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                   !  .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bj1=1,bk1-1
!tempcc                    fac= temp_qb_jb(bk1,bj1)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    fac= temp_qb_jb(bk1,bj1)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                  !  .special_ket(k)[1] = bk1 
!tempcc                  !  .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                  end
!tempcc !debug               write(*,*) 'case 2.1',dim,res
!tempcc                end !k special
!tempcc              end !do kk
!tempcc              nullify(temp_q_h2_ja_kb)
!tempcc              nullify(temp_q_h2_jb_ka)
!tempcc              temp_qb_h2_jb_ka.destroy
!tempcc              nullify(temp_qb_h2_jb_kb)
!tempcc              nullify(temp_qb_h2_jb_ex_kb)
!tempcc              temp_qa_h2_ja_kb.destroy
!tempcc              nullify(temp_qa_h2_ja_ka)
!tempcc              nullify(temp_qa_h2_ja_ex_ka)
!tempcc              temp_qa_h2_jb_ka.destroy
!tempcc              temp_qb_h2_ja_kb.destroy
!tempcc !case 1.3
!tempcc              temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
!tempcc              temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
!tempcc              !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
!tempcc              !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
!tempcc              ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc !debug             stdout.put(reorder_ket)
!tempcc              reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
!tempcc              reorder_bra.create(dim-2)
!tempcc              do ii=dim-1,2,-1
!tempcc                temp_bra_i => .bra(ii)[:,:]
!tempcc                reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                end
!tempcc              end !ii case ii=1 remains 
!tempcc              reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc              do col_ind=1,.n_bas
!tempcc              do row_ind=1,col_ind
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                    - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                end
!tempcc              end
!tempcc              end
!tempcc              reorder_bra.destroy
!tempcc !debug               write(*,*) 'case 1.3',dim,res
!tempcc !case 1.2
!tempcc              fac=temp_qb_h2_j.trace
!tempcc              if( NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_ket) * fac 
!tempcc              end 
!tempcc !debug               write(*,*) 'case 1.2',dim,res
!tempcc !case 1.1
!tempcc              fac=temp_qb_jb.trace
!tempcc              if( NOT fac.is_zero(.tol)) then
!tempcc                res = res + .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc              end 
!tempcc !debug               write(*,*) 'case 1.1',dim,res
!tempcc            else ! j is a special ket
!tempcc ! warning: we have not changed the structure with respect to the case "not a
!tempcc ! special ket", therefore more space than needed is used and large parts of the
!tempcc ! arrays are dangerously not initialized.
!tempcc              bj1=.special_ket(j)[1]
!tempcc              bj2=.special_ket(j)[2]
!tempcc !case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk) !cannot be 1
!tempcc !debug               write(*,*) 'kk,k',kk,k
!tempcc                DIE_IF(k<2,"k cannot be 1")  !debug
!tempcc                reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) =  k
!tempcc                DIE_IF(.special_ket(k)[1]==0,"j special ket but not k") 
!tempcc                bk1=.special_ket(k)[1]
!tempcc                bk2=.special_ket(k)[2]
!tempcc !case 2.3
!tempcc !case 2.3.1 call special overlap ab
!tempcc                !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
!tempcc                !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
!tempcc                !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                reorder_bra.create(dim-2)
!tempcc                if(bj2/=bk2 OR bj1/=bk1) then
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc               !    .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do col_ind=1,.n_bas
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc               !    .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                      + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                      + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                  end
!tempcc                  end
!tempcc                else !bj1==bk1 AND bj2==bk2
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                 !     .special_ket(k)[1] = bk1 
!tempcc                 !     .special_ket(k)[2] = bk2
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do col_ind=1,.n_bas
!tempcc                  do row_ind=1,col_ind
!tempcc                    temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                 !     .special_ket(k)[1] = bk1 
!tempcc                 !     .special_ket(k)[2] = bk2
!tempcc                      res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                      + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end 
!tempcc                  end 
!tempcc                end !bj1==bk1 AND bj2==bk2
!tempcc                .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!tempcc !debug               write(*,*) 'case 2.3.1',dim,res
!tempcc !case 2.3.2 call special overlap aa
!tempcc               !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
!tempcc               !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
!tempcc                .special_ket(k)[1] = bj1 
!tempcc              ! .special_ket(k)[2] = bk1
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bi1=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc                    fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
!tempcc                       + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do col_ind=1,.n_bas
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bi1=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc                    fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
!tempcc                       + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                    + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                end
!tempcc                end
!tempcc !debug               write(*,*) 'case 2.3.2',dim,res
!tempcc !case 2.3.3 call special overlap bb
!tempcc              !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
!tempcc              !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
!tempcc                .special_ket(k)[2] = bk2 
!tempcc                .special_ket(k)[1] = bj2 
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bi2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
!tempcc                       + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,bi2,bq2) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do col_ind=1,.n_bas
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bi2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
!tempcc                       + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                    + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                end
!tempcc                end
!tempcc                reorder_bra.destroy
!tempcc                .special_ket(k)[1] = bk1 
!tempcc !debug               write(*,*) 'case 2.3.3',dim,res
!tempcc !case 2.2
!tempcc                if(bj2/=bk2 OR bj1/=bk1) then
!tempcc                !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
!tempcc                  fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                !  .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                  .special_ket(k)[2] = bk2
!tempcc                !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
!tempcc                  fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc               !   .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                else !bj2==bk2 AND bj1==bk1
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
!tempcc                  fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc            !     .special_ket(k)[1] = bk1 
!tempcc            !     .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc                end !bj2==bk2 AND bj1==bk1
!tempcc !debug               write(*,*) 'case 2.2',dim,res
!tempcc !case 2.1
!tempcc                if(bj2/=bk2 OR bj1/=bk1) then
!tempcc                  fac= temp_bra_q(bj1,bk2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                  end 
!tempcc                  fac= temp_bra_q(bk1,bj2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                  end 
!tempcc                else !bj2==bk2 AND bj1==bk1
!tempcc                  fac= temp_bra_q(bk1,bj2) + temp_bra_q(bj1,bk2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                !   .special_ket(k)[1] = bk1 
!tempcc                !   .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                  end
!tempcc                end !bj2==bk2 AND bj1==bk1
!tempcc !debug               write(*,*) 'case 2.1',dim,res
!tempcc              end !do kk
!tempcc              !nullify(temp_q_h2_ja_kb)
!tempcc              !nullify(temp_q_h2_jb_ka)
!tempcc              !temp_qb_h2_jb_ka.destroy
!tempcc              !nullify(temp_qb_h2_jb_kb)
!tempcc              !nullify(temp_qb_h2_jb_ex_kb)
!tempcc              !temp_qa_h2_ja_kb.destroy
!tempcc              !nullify(temp_qa_h2_ja_ka)
!tempcc              !nullify(temp_qa_h2_ja_ex_ka)
!tempcc              !temp_qa_h2_jb_ka.destroy
!tempcc              !temp_qb_h2_ja_kb.destroy
!tempcc !case 1.3
!tempcc              temp_qa_h2_j=temp_qa_h2(:,:,bj1,bj2)
!tempcc              temp_qb_h2_j=temp_qb_h2(:,:,bj1,bj2)
!tempcc              !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
!tempcc              !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
!tempcc              ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
!tempcc              reorder_bra.create(dim-2)
!tempcc              do ii=dim-1,2,-1
!tempcc                temp_bra_i => .bra(ii)[:,:]
!tempcc                reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                end
!tempcc              end !ii case ii=1 remains 
!tempcc              reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc              do col_ind=1,.n_bas
!tempcc              do row_ind=1,col_ind
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  res(row_ind,col_ind) = res(row_ind,col_ind) &
!tempcc                  - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                end
!tempcc              end
!tempcc              end
!tempcc              reorder_bra.destroy
!tempcc !debug               write(*,*) 'case 1.3',dim,res
!tempcc !case 1.2
!tempcc              fac=temp_qb_h2_j.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_ket) * fac ! 
!tempcc                      end 
!tempcc !debug               write(*,*) 'case 1.2',dim,res
!tempcc !case 1.1
!tempcc              fac=temp_bra_q(bj1,bj2)
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              res = res + .hamiltonian_for(v,reorder_ket) * fac ! 
!tempcc                      end 
!tempcc !debug               write(*,*) 'case 1.1',dim,res
!tempcc            end !j special ket
!tempcc          end !if j=1
!tempcc        end !do jj
!tempcc        if(temp_qa_h2_ja.created) then
!tempcc          temp_qa_h2_ja.destroy
!tempcc          temp_qb_h2_jb.destroy
!tempcc          temp_qa_h2_jb.destroy
!tempcc          temp_qb_h2_ja.destroy
!tempcc          temp_qa_h2_ja_ex.destroy
!tempcc          temp_qb_h2_jb_ex.destroy
!tempcc          temp_qa_ja.destroy
!tempcc          temp_qb_jb.destroy
!tempcc        end
!tempcc        temp_qa_h2_j.destroy
!tempcc        temp_qb_h2_j.destroy
!tempcc        temp_qa_h2.destroy
!tempcc        temp_qb_h2.destroy
!tempcc        reorder_ket.destroy
!tempcc      end !if dim=1
!tempcc    end
!tempcc 
!tempcc    hamiltonian_for(v,order_ket,col_ind) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the hamiltonian integrals matrix
!tempcc    ! column vector between mean field (Sz=0)-geminals 
!tempcc    ! v is the array containing the hf integrals of the 2-electron Hamiltonian.
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if ii is a special ket,
!tempcc !than jj>ii is also a special ket. This allows some simplifications but may be a
!tempcc !bit limitative in the future.
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      v :: MAT4{REAL}, IN
!tempcc      col_ind :: INT, IN
!tempcc      res :: VEC{REAL}(.n_bas)
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      row_ind :: INT
!tempcc      ii,jj,kk,j,k,l,dim,bi1,bi2,bj1,bj2,bk1,bk2,bq1,bq2 :: INT
!tempcc      fac :: REAL
!tempcc      reorder_ket,reorder_bra :: VEC{INT}*
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_bra_i :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_h2_q ::  MAT{REAL}*
!tempcc      temp_qa_h2 :: MAT4{REAL}*
!tempcc      temp_qb_h2 :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ex :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ex :: MAT4{REAL}*
!tempcc      temp_qa_h2_jb :: MAT4{REAL}*
!tempcc      temp_qb_h2_ja :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_jb_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_ja_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ex_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ex_kb :: MAT4{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_q_h2_ja_kb :: MAT{REAL}*
!tempcc      temp_q_h2_jb_ka :: MAT{REAL}*
!tempcc      temp_qa_h2_j :: MAT{REAL}*
!tempcc      temp_qb_h2_j :: MAT{REAL}*
!tempcc 
!tempcc      nullify(temp_qa_ja)
!tempcc      nullify(temp_qb_jb)
!tempcc      nullify(temp_qa_h2_ja_ex)
!tempcc      nullify(temp_qb_h2_jb_ex)
!tempcc      nullify(temp_qa_h2_ja)
!tempcc      nullify(temp_qb_h2_jb)
!tempcc      nullify(temp_qa_h2_jb)
!tempcc      nullify(temp_qb_h2_ja)
!tempcc      nullify(temp_q_h2_ja_kb)
!tempcc      nullify(temp_q_h2_jb_ka)
!tempcc      nullify(temp_qb_h2_jb_kb)
!tempcc      nullify(temp_qb_h2_jb_ex_kb)
!tempcc      nullify(temp_qa_h2_ja_ka)
!tempcc      nullify(temp_qa_h2_ja_ex_ka)
!tempcc      nullify(temp_qa_h2_ja_kb)
!tempcc      nullify(temp_qb_h2_jb_ka)
!tempcc      nullify(temp_qa_h2_jb_ka)
!tempcc      nullify(temp_qb_h2_ja_kb)
!tempcc      dim = order_ket.dim
!tempcc      res = ZERO
!tempcc       
!tempcc      if (dim==1) then ! case 1.2 only
!tempcc        j = order_ket(1)
!tempcc        DIE_IF(j==1,"j is 1")
!tempcc        if (.special_ket(j)[1]>0) then             
!tempcc          bj1 = .special_ket(j)[1]                 
!tempcc          bj2 = .special_ket(j)[2]                
!tempcc          do row_ind=1,col_ind
!tempcc            res(row_ind) = sum(.contraction_wfs(row_ind)[:,:]*v(:,:,bj1,bj2))
!tempcc          end
!tempcc        else
!tempcc          temp_h2_q.create(.n_bf,.n_bf)
!tempcc          do bj2=1,.n_bf
!tempcc          do bj1=1,.n_bf
!tempcc            temp_h2_q(bj1,bj2) = sum(v(bj1,bj2,:,:)*.ket(j)[:,:])
!tempcc          end
!tempcc          end
!tempcc          do row_ind=1,col_ind
!tempcc            res(row_ind) = sum(.contraction_wfs(row_ind)[:,:]*temp_h2_q)
!tempcc          end
!tempcc          temp_h2_q.destroy
!tempcc        end
!tempcc     !debug           write(*,*) 'case 1.2',dim,res
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        temp_bra_q => .bra(dim)[:,:]
!tempcc        reorder_ket.create(dim-1)
!tempcc !the next two arrays are created here because they are small and used in all
!tempcc !cases
!tempcc        temp_qa_h2_j.create(.n_bf,.n_bf)
!tempcc        temp_qb_h2_j.create(.n_bf,.n_bf)
!tempcc        temp_qa_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc        temp_qb_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc        do bj2=1,.n_bf
!tempcc        do bj1=1,.n_bf
!tempcc        do bq2=1,.n_bf
!tempcc        do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc          temp_qa_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(:,bq2)*v(:,bq1,bj1,bj2))
!tempcc          temp_qb_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(bq1,:)*v(bq2,:,bj1,bj2))
!tempcc        end
!tempcc        end
!tempcc        end
!tempcc        end
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc !debug    write(*,*) "jj,j",jj,j
!tempcc          DIE_IF(j==1,"j is 1 ")
!tempcc          if (.special_ket(j)[1]==0) then !j not special
!tempcc            temp_ket_j => .ket(j)[:,:]
!tempcc            if(temp_qa_h2_ja.destroyed) then
!tempcc              temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc              temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qa_ja.create(.n_bf,.n_bf)
!tempcc              temp_qb_jb.create(.n_bf,.n_bf)
!tempcc            end
!tempcc            do bj2=1,.n_bf
!tempcc            do bq2=1,.n_bf
!tempcc              temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
!tempcc              temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
!tempcc            end
!tempcc            end
!tempcc            do bj2=1,.n_bf
!tempcc            do bj1=1,.n_bf
!tempcc            do bq2=1,.n_bf
!tempcc            do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc              temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc              temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc              temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc              temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc              temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
!tempcc              temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
!tempcc            end
!tempcc            end
!tempcc            end
!tempcc            end
!tempcc !case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk) !cannot be 1
!tempcc !debug               write(*,*) 'kk,k',kk,k
!tempcc              DIE_IF(k<2,"k cannot be 1")  !debug
!tempcc              reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) =  k
!tempcc              if (.special_ket(k)[1]==0) then !k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc !case 2.3
!tempcc                if(temp_qa_h2_ja_kb.destroyed) then
!tempcc                  temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
!tempcc                  temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
!tempcc                  temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                  temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                end
!tempcc !case 2.3.1 call special overlap ab
!tempcc                do bj1=1,.n_bf
!tempcc                do bj2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                  temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                  temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                  temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                  temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                reorder_bra.create(dim-2)
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bk1 
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                           + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii, the case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bk1 
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                           + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind) = res(row_ind) &
!tempcc                        + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc !debug               write(*,*) 'case 2.3.1',dim,res
!tempcc !case 2.3.2 call special overlap aa
!tempcc                temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
!tempcc                temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
!tempcc                do bj1=1,.n_bf
!tempcc                do bj2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                  temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                  temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bk1=1,.n_bf
!tempcc                    .special_ket(k)[2] = bk1
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      do bi1=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                           + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac ! <<
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bk1=1,.n_bf
!tempcc                    .special_ket(k)[2] = bk1
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      do bi1=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                           + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind) = res(row_ind) &
!tempcc                        + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc !debug              write(*,*) 'case 2.3.2',dim,res
!tempcc !case 2.3.3 call special overlap bb
!tempcc                temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
!tempcc                temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
!tempcc                do bj1=1,.n_bf
!tempcc                do bj2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                  temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                  temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bk2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                           + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! <
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bk2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                           + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res(row_ind) = res(row_ind) &
!tempcc                        + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                reorder_bra.destroy
!tempcc !debug               write(*,*) 'case 2.3.3',dim,res
!tempcc !case 2.2
!tempcc               ! if(temp_q_h2_ja_kb.destroyed) then
!tempcc               !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
!tempcc               !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
!tempcc               ! end
!tempcc               ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
!tempcc               ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
!tempcc                do bj2=1,.n_bf
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bk1=1,.n_bf
!tempcc                    temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
!tempcc                    temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
!tempcc                    fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                    res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                end
!tempcc !debug               write(*,*) 'case 2.2',dim,res
!tempcc !case 2.1
!tempcc                do bj2=1,.n_bf
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bk1=1,.n_bf
!tempcc                    fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bk1 
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end 
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc !debug               write(*,*) 'case 2.1',dim,res
!tempcc              else !k special
!tempcc                bk1=.special_ket(k)[1]
!tempcc                bk2=.special_ket(k)[2]
!tempcc !case 2.3
!tempcc !case 2.3.1 call special overlap ab
!tempcc                !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
!tempcc                !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
!tempcc                !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                reorder_bra.create(dim-2)
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bj2=1,bk2-1
!tempcc               !    .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                  ! .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bj1=1,bk1-1
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc               !    .special_ket(k)[2] = bk2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                !   .special_ket(k)[2] = bk2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                       + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                 !   .special_ket(k)[1] = bk1 
!tempcc                 !   .special_ket(k)[2] = bk2
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                end !do ii, the case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bj2=1,bk2-1
!tempcc               !    .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res(row_ind) = res(row_ind) &
!tempcc                      + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                  ! .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res(row_ind) = res(row_ind) &
!tempcc                      + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bj1=1,bk1-1
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc               !    .special_ket(k)[2] = bk2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res(row_ind) = res(row_ind) &
!tempcc                      + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                !   .special_ket(k)[2] = bk2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res(row_ind) = res(row_ind) &
!tempcc                      + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                       + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                 !   .special_ket(k)[1] = bk1 
!tempcc                 !   .special_ket(k)[2] = bk2
!tempcc                    res(row_ind) = res(row_ind) &
!tempcc                    + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                end 
!tempcc                .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!tempcc !debug               write(*,*) 'case 2.3.1',dim,res
!tempcc !case 2.3.2 call special overlap aa
!tempcc               !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
!tempcc               !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bj1=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc              !     .special_ket(k)[2] = bk1
!tempcc                    do bi1=1,.n_bf
!tempcc                    do bq1=1,.n_bf
!tempcc                      fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                         + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bj1=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                !   .special_ket(k)[2] = bk1
!tempcc                    do bi1=1,.n_bf
!tempcc                    do bq1=1,.n_bf
!tempcc                      fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                         + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res(row_ind) = res(row_ind) &
!tempcc                      + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[2] = bk2 
!tempcc !debug               write(*,*) 'case 2.3.2',dim,res
!tempcc !case 2.3.3 call special overlap bb
!tempcc              !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
!tempcc              !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj2 
!tempcc                !   .special_ket(k)[2] = bk2
!tempcc                    do bi2=1,.n_bf
!tempcc                    do bq2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                         + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj2 
!tempcc                 !  .special_ket(k)[2] = bk2
!tempcc                    do bi2=1,.n_bf
!tempcc                    do bq2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                         + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res(row_ind) = res(row_ind) &
!tempcc                      + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1] = bk1 
!tempcc                reorder_bra.destroy
!tempcc !debug               write(*,*) 'case 2.3.3',dim,res
!tempcc !case 2.2
!tempcc                !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                do bj2=1,bk2-1
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                  fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                ! .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                do bj2=bk2+1,.n_bf
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                  fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                ! .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                .special_ket(k)[2] = bk2
!tempcc                !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                do bj1=1,bk1-1
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                  fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc               !  .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                do bj1=bk1+1,.n_bf
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                  fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc               !  .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                .special_ket(k)[1] = bk1 
!tempcc                temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
!tempcc                temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
!tempcc                fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc            !    .special_ket(k)[1] = bk1 
!tempcc            !    .special_ket(k)[2] = bk2
!tempcc                res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               write(*,*) 'case 2.2',dim,res
!tempcc !case 2.1
!tempcc                do bj2=1,bk2-1
!tempcc                  fac= temp_qa_ja(bk2,bj2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                do bj2=bk2+1,.n_bf
!tempcc                  fac= temp_qa_ja(bk2,bj2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                .special_ket(k)[2] = bk2 
!tempcc                do bj1=1,bk1-1
!tempcc                  fac= temp_qb_jb(bk1,bj1)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                do bj1=bk1+1,.n_bf
!tempcc                  fac= temp_qb_jb(bk1,bj1)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                .special_ket(k)[1] = bk1 
!tempcc                fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc                !  .special_ket(k)[1] = bk1 
!tempcc                !  .special_ket(k)[2] = bk2
!tempcc                  res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                end
!tempcc !debug               write(*,*) 'case 2.1',dim,res
!tempcc              end !k special
!tempcc            end !do kk
!tempcc            nullify(temp_q_h2_ja_kb)
!tempcc            nullify(temp_q_h2_jb_ka)
!tempcc            temp_qb_h2_jb_ka.destroy
!tempcc            nullify(temp_qb_h2_jb_kb)
!tempcc            nullify(temp_qb_h2_jb_ex_kb)
!tempcc            temp_qa_h2_ja_kb.destroy
!tempcc            nullify(temp_qa_h2_ja_ka)
!tempcc            nullify(temp_qa_h2_ja_ex_ka)
!tempcc            temp_qa_h2_jb_ka.destroy
!tempcc            temp_qb_h2_ja_kb.destroy
!tempcc !case 1.3
!tempcc            temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
!tempcc            temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
!tempcc            !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
!tempcc            !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
!tempcc            !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
!tempcc            reorder_bra.create(dim-2)
!tempcc            do ii=dim-1,2,-1
!tempcc              temp_bra_i => .bra(ii)[:,:]
!tempcc              reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc              reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc              do bi2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc              end
!tempcc              end
!tempcc            end !ii case ii=1 remains 
!tempcc            reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc            do row_ind=1,col_ind
!tempcc              temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc              do bi2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                res(row_ind) = res(row_ind) &
!tempcc                - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc              end
!tempcc              end
!tempcc            end
!tempcc            reorder_bra.destroy
!tempcc !debug               write(*,*) 'case 1.3',dim,res
!tempcc !case 1.2
!tempcc            fac=temp_qb_h2_j.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc            res = res + .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               write(*,*) 'case 1.2',dim,res
!tempcc !case 1.1
!tempcc            fac=temp_qb_jb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc            res = res + .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               write(*,*) 'case 1.1',dim,res
!tempcc          else ! j is a special ket
!tempcc ! warning: we have not changed the structure with respect to the case "not a
!tempcc ! special ket", therefore more space than needed is used and large parts of the
!tempcc ! arrays are dangerously not initialized.
!tempcc            bj1=.special_ket(j)[1]
!tempcc            bj2=.special_ket(j)[2]
!tempcc !case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk) !cannot be 1
!tempcc !debug               write(*,*) 'kk,k',kk,k
!tempcc              DIE_IF(k<2,"k cannot be 1")  !debug
!tempcc              reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) =  k
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special ket but not k") 
!tempcc              bk1=.special_ket(k)[1]
!tempcc              bk2=.special_ket(k)[2]
!tempcc !case 2.3
!tempcc !case 2.3.1 call special overlap ab
!tempcc              !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc              !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
!tempcc              !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
!tempcc              !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc              reorder_bra.create(dim-2)
!tempcc              if(bj2/=bk2 OR bj1/=bk1) then
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc             !    .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                end !do ii, the case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc             !    .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res(row_ind) = res(row_ind) &
!tempcc                    + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res(row_ind) = res(row_ind) &
!tempcc                    + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                end
!tempcc              else !bj1==bk1 AND bj2==bk2
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                       + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc               !     .special_ket(k)[1] = bk1 
!tempcc               !     .special_ket(k)[2] = bk2
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                end !do ii, the case ii=1 is left
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do row_ind=1,col_ind
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                       + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc               !     .special_ket(k)[1] = bk1 
!tempcc               !     .special_ket(k)[2] = bk2
!tempcc                    res(row_ind) = res(row_ind) &
!tempcc                    + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                end 
!tempcc              end !bj1==bk1 AND bj2==bk2
!tempcc              .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!tempcc !debug               write(*,*) 'case 2.3.1',dim,res
!tempcc !case 2.3.2 call special overlap aa
!tempcc             !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
!tempcc             !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
!tempcc              .special_ket(k)[1] = bj1 
!tempcc            ! .special_ket(k)[2] = bk1
!tempcc              do ii=dim-1,2,-1
!tempcc                temp_bra_i => .bra(ii)[:,:]
!tempcc                reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                do bi1=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
!tempcc                     + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                end
!tempcc              end !do ii , case ii=1 is left
!tempcc              reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc              do row_ind=1,col_ind
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                do bi1=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
!tempcc                     + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    res(row_ind) = res(row_ind) &
!tempcc                    + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                end
!tempcc              end
!tempcc !debug               write(*,*) 'case 2.3.2',dim,res
!tempcc !case 2.3.3 call special overlap bb
!tempcc            !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
!tempcc            !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
!tempcc              .special_ket(k)[2] = bk2 
!tempcc              .special_ket(k)[1] = bj2 
!tempcc              do ii=dim-1,2,-1
!tempcc                temp_bra_i => .bra(ii)[:,:]
!tempcc                reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                  fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
!tempcc                     + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! 
!tempcc                  end 
!tempcc                end 
!tempcc                end
!tempcc              end !do ii , case ii=1 is left
!tempcc              reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc              do row_ind=1,col_ind
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                  fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
!tempcc                     + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    res(row_ind) = res(row_ind) &
!tempcc                    + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
!tempcc                  end 
!tempcc                end 
!tempcc                end
!tempcc              end
!tempcc              reorder_bra.destroy
!tempcc              .special_ket(k)[1] = bk1 
!tempcc !debug               write(*,*) 'case 2.3.3',dim,res
!tempcc !case 2.2
!tempcc              if(bj2/=bk2 OR bj1/=bk1) then
!tempcc              !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
!tempcc                fac= temp_q_h2_ja_kb.trace
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc              !   .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                end 
!tempcc                .special_ket(k)[2] = bk2
!tempcc              !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
!tempcc                fac= temp_q_h2_jb_ka.trace
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc             !    .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                end 
!tempcc                .special_ket(k)[1] = bk1 
!tempcc              else !bj2==bk2 AND bj1==bk1
!tempcc                temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
!tempcc                temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
!tempcc                fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc          !       .special_ket(k)[1] = bk1 
!tempcc          !       .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc                end 
!tempcc              end !bj2==bk2 AND bj1==bk1
!tempcc !debug               write(*,*) 'case 2.2',dim,res
!tempcc !case 2.1
!tempcc              if(bj2/=bk2 OR bj1/=bk1) then
!tempcc                fac= temp_bra_q(bj1,bk2)
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc               !  .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                end 
!tempcc                fac= temp_bra_q(bk1,bj2)
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                end 
!tempcc              else !bj2==bk2 AND bj1==bk1
!tempcc                fac= temp_bra_q(bk1,bj2) + temp_bra_q(bj1,bk2)
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc              !   .special_ket(k)[1] = bk1 
!tempcc              !   .special_ket(k)[2] = bk2
!tempcc                  res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc                end
!tempcc              end !bj2==bk2 AND bj1==bk1
!tempcc !debug               write(*,*) 'case 2.1',dim,res
!tempcc            end !do kk
!tempcc          !  nullify(temp_q_h2_ja_kb)
!tempcc          !  nullify(temp_q_h2_jb_ka)
!tempcc          !  temp_qb_h2_jb_ka.destroy
!tempcc          !  nullify(temp_qb_h2_jb_kb)
!tempcc          !  nullify(temp_qb_h2_jb_ex_kb)
!tempcc          !  temp_qa_h2_ja_kb.destroy
!tempcc          !  nullify(temp_qa_h2_ja_ka)
!tempcc          !  nullify(temp_qa_h2_ja_ex_ka)
!tempcc          !  temp_qa_h2_jb_ka.destroy
!tempcc          !  temp_qb_h2_ja_kb.destroy
!tempcc !case 1.3
!tempcc            temp_qa_h2_j=temp_qa_h2(:,:,bj1,bj2)
!tempcc            temp_qb_h2_j=temp_qb_h2(:,:,bj1,bj2)
!tempcc            !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
!tempcc            !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
!tempcc            !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
!tempcc            reorder_bra.create(dim-2)
!tempcc            do ii=dim-1,2,-1
!tempcc              temp_bra_i => .bra(ii)[:,:]
!tempcc              reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc              reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc              do bi2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc                  res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
!tempcc                end 
!tempcc              end
!tempcc              end
!tempcc            end !ii case ii=1 remains 
!tempcc            reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc            do row_ind=1,col_ind
!tempcc              temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc              do bi2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc                  res(row_ind) = res(row_ind) &
!tempcc                  - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                end 
!tempcc              end
!tempcc              end
!tempcc            end
!tempcc            reorder_bra.destroy
!tempcc !debug               write(*,*) 'case 1.3',dim,res
!tempcc !case 1.2
!tempcc            fac=temp_qb_h2_j.trace
!tempcc            if( NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_ket,col_ind) * fac ! 
!tempcc            end 
!tempcc !debug               write(*,*) 'case 1.2',dim,res
!tempcc !case 1.1
!tempcc            fac=temp_bra_q(bj1,bj2)
!tempcc            if( NOT fac.is_zero(.tol)) then
!tempcc              res = res + .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
!tempcc            end 
!tempcc !debug               write(*,*) 'case 1.1',dim,res
!tempcc          end !j special ket
!tempcc        end !do jj
!tempcc        temp_qa_ja.destroy
!tempcc        temp_qb_jb.destroy
!tempcc        temp_qa_h2_ja_ex.destroy
!tempcc        temp_qb_h2_jb_ex.destroy
!tempcc        temp_qa_h2_ja.destroy
!tempcc        temp_qb_h2_jb.destroy
!tempcc        temp_qa_h2_jb.destroy
!tempcc        temp_qb_h2_ja.destroy
!tempcc        temp_qa_h2_j.destroy
!tempcc        temp_qb_h2_j.destroy
!tempcc        temp_qa_h2.destroy
!tempcc        temp_qb_h2.destroy
!tempcc        reorder_ket.destroy
!tempcc      end !if dim=1
!tempcc    end
!tempcc 
!tempcc    hamiltonian_for(v,order_ket,row_ind,col_ind) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the hamiltonian integrals matrix
!tempcc    ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!tempcc    ! v is the array containing the hf integrals of the 2-electron Hamiltonian.
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if ii is a special ket,
!tempcc !than jj>ii is also a special ket. This allows some simplifications but may be a
!tempcc !bit limitative in the future.
!tempcc      row_ind, col_ind :: INT, IN
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      v :: MAT4{REAL}, IN
!tempcc      res :: REAL
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
!tempcc      ii,jj,kk,j,k,l,dim,bi1,bi2,bj1,bj2,bk1,bk2,bq1,bq2 :: INT
!tempcc      fac :: REAL
!tempcc      reorder_ket,reorder_bra :: VEC{INT}*
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_bra_i :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_q_h2 ::  MAT{REAL}*
!tempcc      temp_qa_h2 :: MAT4{REAL}*
!tempcc      temp_qb_h2 :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ex :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ex :: MAT4{REAL}*
!tempcc      temp_qa_h2_jb :: MAT4{REAL}*
!tempcc      temp_qb_h2_ja :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_jb_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_ja_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_kb :: MAT4{REAL}*
!tempcc      temp_qa_h2_ja_ex_ka :: MAT4{REAL}*
!tempcc      temp_qb_h2_jb_ex_kb :: MAT4{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_q_h2_ja_kb :: MAT{REAL}*
!tempcc      temp_q_h2_jb_ka :: MAT{REAL}*
!tempcc      temp_qa_h2_j :: MAT{REAL}*
!tempcc      temp_qb_h2_j :: MAT{REAL}*
!tempcc 
!tempcc      nullify(temp_qa_ja)
!tempcc      nullify(temp_qb_jb)
!tempcc      nullify(temp_qa_h2_ja_ex)
!tempcc      nullify(temp_qb_h2_jb_ex)
!tempcc      nullify(temp_qa_h2_ja)
!tempcc      nullify(temp_qb_h2_jb)
!tempcc      nullify(temp_qa_h2_jb)
!tempcc      nullify(temp_qb_h2_ja)
!tempcc      nullify(temp_q_h2_ja_kb)
!tempcc      nullify(temp_q_h2_jb_ka)
!tempcc      nullify(temp_qb_h2_jb_kb)
!tempcc      nullify(temp_qb_h2_jb_ex_kb)
!tempcc      nullify(temp_qa_h2_ja_ka)
!tempcc      nullify(temp_qa_h2_ja_ex_ka)
!tempcc      nullify(temp_qa_h2_ja_kb)
!tempcc      nullify(temp_qb_h2_jb_ka)
!tempcc      nullify(temp_qa_h2_jb_ka)
!tempcc      nullify(temp_qb_h2_ja_kb)
!tempcc      dim = order_ket.dim
!tempcc      res = ZERO
!tempcc       
!tempcc      if (dim==1) then ! case 1.2 only
!tempcc        j = order_ket(1)
!tempcc        if (.special_ket(j)[1]>0) then             
!tempcc          bj1 = .special_ket(j)[1]                 
!tempcc          bj2 = .special_ket(j)[2]                
!tempcc          fac = sum(.contraction_wfs(row_ind)[:,:]*v(:,:,bj1,bj2))
!tempcc        else
!tempcc          temp_q_h2.create(.n_bf,.n_bf)
!tempcc          do bj2=1,.n_bf
!tempcc          do bj1=1,.n_bf
!tempcc            temp_q_h2(bj1,bj2) = sum(.contraction_wfs(row_ind)[:,:]*v(:,:,bj1,bj2))
!tempcc          end
!tempcc          end
!tempcc          if(j==1) then
!tempcc            fac = sum(temp_q_h2*.contraction_wfs(col_ind)[:,:])
!tempcc          else 
!tempcc            fac = sum(temp_q_h2*.ket(j)[:,:])
!tempcc          end
!tempcc          temp_q_h2.destroy
!tempcc        end
!tempcc        res = fac
!tempcc !debug
!tempcc !debug write(*,*)"jj,j",1,j
!tempcc !debug write(*,*)"case 1.2, dim", dim
!tempcc !debug write(*,*)res
!tempcc !debug
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        temp_bra_q => .bra(dim)[:,:]
!tempcc        reorder_ket.create(dim-1)
!tempcc !the next two arrays are created here because they are small and used in all
!tempcc !cases
!tempcc        temp_qa_h2_j.create(.n_bf,.n_bf)
!tempcc        temp_qb_h2_j.create(.n_bf,.n_bf)
!tempcc        temp_qa_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc        temp_qb_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc        do bj2=1,.n_bf
!tempcc        do bj1=1,.n_bf
!tempcc        do bq2=1,.n_bf
!tempcc        do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc          temp_qa_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(:,bq2)*v(:,bq1,bj1,bj2))
!tempcc          temp_qb_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(bq1,:)*v(bq2,:,bj1,bj2))
!tempcc        end
!tempcc        end
!tempcc        end
!tempcc        end
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc !debug    
!tempcc !debug write(*,*) "jj,j",jj,j
!tempcc !debug    
!tempcc          if (j==1) then !ket from contraction 1
!tempcc            temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc            if(temp_qa_h2_ja.destroyed) then
!tempcc              temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc              temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc              temp_qa_ja.create(.n_bf,.n_bf)
!tempcc              temp_qb_jb.create(.n_bf,.n_bf)
!tempcc            end
!tempcc            do bj2=1,.n_bf
!tempcc            do bq2=1,.n_bf
!tempcc              temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
!tempcc              temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
!tempcc            end
!tempcc            end
!tempcc            do bj2=1,.n_bf
!tempcc            do bj1=1,.n_bf
!tempcc            do bq2=1,.n_bf
!tempcc            do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc              temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc              temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc              temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc              temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc              temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
!tempcc              temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
!tempcc            end
!tempcc            end
!tempcc            end
!tempcc            end
!tempcc !case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk) !cannot be 1
!tempcc !debug              
!tempcc !debug write(*,*) "kk,k",kk,k
!tempcc !debug              
!tempcc              DIE_IF(k<2,"k cannot be 1")  !debug
!tempcc              reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) =  k
!tempcc !debug
!tempcc !debug     do l=1,dim-1
!tempcc !debug       stdout.show("l=",l)
!tempcc !debug       stdout.show("reorder_ket(l)=",reorder_ket(l))
!tempcc !debug       stdout.show("special_ket(reorder_ket(l))-in",.special_ket(reorder_ket(l)).element)
!tempcc !debug     end
!tempcc !debug
!tempcc              if (.special_ket(k)[1]==0) then !k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc !case 2.3
!tempcc                if(temp_qa_h2_ja_kb.destroyed) then
!tempcc                  temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
!tempcc                  temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
!tempcc                  temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                  temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                end
!tempcc !case 2.3.1 call special overlap ab
!tempcc                do bj1=1,.n_bf
!tempcc                do bj2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                  temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                  temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                  temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                  temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                reorder_bra.create(dim-2)
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bk1 
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                           + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"case 2.3.1, dim, ii", dim, ii
!tempcc !debug write(*,*)res
!tempcc !debug
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii, the case ii=1 is left
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do bj2=1,.n_bf
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bk1=1,.n_bf
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                    do bi2=1,.n_bf
!tempcc                    do bq1=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"case 2.3.1 ii=1, dim", dim
!tempcc !debug write(*,*)res
!tempcc !debug
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc !debug              
!tempcc !debug write(*,*) 'case 2.3.1',dim,res
!tempcc !debug              
!tempcc !case 2.3.2 call special overlap aa
!tempcc                temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
!tempcc                temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
!tempcc                do bj1=1,.n_bf
!tempcc                do bj2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                  temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                  temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bk1=1,.n_bf
!tempcc                    .special_ket(k)[2] = bk1
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      do bi1=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                           + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <<
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do bk1=1,.n_bf
!tempcc                  .special_ket(k)[2] = bk1
!tempcc                  do bj1=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                    do bi1=1,.n_bf
!tempcc                    do bq1=1,.n_bf
!tempcc                      fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                         + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.2',dim,res
!tempcc !debug              
!tempcc !case 2.3.3 call special overlap bb
!tempcc                temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
!tempcc                temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
!tempcc                do bj1=1,.n_bf
!tempcc                do bj2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                  temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                  temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                end
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bk2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                           + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do bk2=1,.n_bf
!tempcc                  .special_ket(k)[2] = bk2
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj2 
!tempcc                    do bi2=1,.n_bf
!tempcc                    do bq2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                         + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                reorder_bra.destroy
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.3',dim,res
!tempcc !debug              
!tempcc !case 2.2
!tempcc               ! if(temp_q_h2_ja_kb.destroyed) then
!tempcc               !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
!tempcc               !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
!tempcc               ! end
!tempcc               ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
!tempcc               ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
!tempcc                do bj2=1,.n_bf
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bk1=1,.n_bf
!tempcc                    temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
!tempcc                    temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
!tempcc                    fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                end
!tempcc !debug             
!tempcc !debug write(*,*) 'case 2.2',dim,res
!tempcc !debug              
!tempcc !case 2.1
!tempcc                do bj2=1,.n_bf
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bk1=1,.n_bf
!tempcc                    fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bk1 
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end 
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.1',dim,res
!tempcc !debug              
!tempcc              else !k special
!tempcc                bk1=.special_ket(k)[1]
!tempcc                bk2=.special_ket(k)[2]
!tempcc !case 2.3
!tempcc !case 2.3.1 call special overlap ab
!tempcc                !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
!tempcc                !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
!tempcc                !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                reorder_bra.create(dim-2)
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bj2=1,bk2-1
!tempcc               !    .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                  ! .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bj1=1,bk1-1
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc               !    .special_ket(k)[2] = bk2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                !   .special_ket(k)[2] = bk2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                       + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                 !   .special_ket(k)[1] = bk1 
!tempcc                 !   .special_ket(k)[2] = bk2
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                end !do ii, the case ii=1 is left
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do bj2=1,bk2-1
!tempcc             !    .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                end
!tempcc                do bj2=bk2+1,.n_bf
!tempcc                ! .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                end
!tempcc                .special_ket(k)[2] = bk2 
!tempcc                do bj1=1,bk1-1
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc             !    .special_ket(k)[2] = bk2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                end
!tempcc                do bj1=bk1+1,.n_bf
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc              !   .special_ket(k)[2] = bk2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-out",.special_ket(k).element)
!tempcc !debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1] = bk1 
!tempcc                do bq1=1,.n_bf
!tempcc                do bi2=1,.n_bf
!tempcc                  fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                     + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                     + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                     + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc               !   .special_ket(k)[1] = bk1 
!tempcc               !   .special_ket(k)[2] = bk2
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!tempcc !debug
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc !debug
!tempcc !debug stdout.show("special_ket(k)-out",.special_ket(k).element)
!tempcc !debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!tempcc !debug
!tempcc                      end 
!tempcc                end 
!tempcc                end 
!tempcc                .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.1',dim,res
!tempcc !debug              
!tempcc !case 2.3.2 call special overlap aa
!tempcc               !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
!tempcc               !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bj1=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc              !     .special_ket(k)[2] = bk1
!tempcc                    do bi1=1,.n_bf
!tempcc                    do bq1=1,.n_bf
!tempcc                      fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                         + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do bj1=1,.n_bf
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc              !   .special_ket(k)[2] = bk1
!tempcc                  do bi1=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc                    fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                       + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[2] = bk2 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.2',dim,res
!tempcc !debug              
!tempcc !case 2.3.3 call special overlap bb
!tempcc              !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
!tempcc              !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj2 
!tempcc                !   .special_ket(k)[2] = bk2
!tempcc                    do bi2=1,.n_bf
!tempcc                    do bq2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                         + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc            !debug    write(*,*) 'coucou1'
!tempcc            !debug    stdout.put(temp_bra_i)
!tempcc                do bj2=1,.n_bf
!tempcc                  .special_ket(k)[1] = bj2 
!tempcc               !  .special_ket(k)[2] = bk2
!tempcc                  do bi2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                       + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
!tempcc                      end 
!tempcc            !debug    if(NOT fac.is_zero(.tol)) then
!tempcc            !debug    write(*,*) 'bj2,bk2,bi2,bq2,fac',bj2,bk2,bi2,bq2,fac
!tempcc            !debug    end
!tempcc                  end 
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1] = bk1 
!tempcc                reorder_bra.destroy
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.3',dim,res
!tempcc !debug              
!tempcc !case 2.2
!tempcc                !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                do bj2=1,bk2-1
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                  fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                !  .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                do bj2=bk2+1,.n_bf
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                  fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                !  .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                .special_ket(k)[2] = bk2
!tempcc                !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                do bj1=1,bk1-1
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                  fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc               !   .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                do bj1=bk1+1,.n_bf
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                  fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc               !   .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                .special_ket(k)[1] = bk1 
!tempcc                temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
!tempcc                temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
!tempcc                fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc            !    .special_ket(k)[1] = bk1 
!tempcc            !    .special_ket(k)[2] = bk2
!tempcc                res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.2',dim,res
!tempcc !debug              
!tempcc !case 2.1
!tempcc                do bj2=1,bk2-1
!tempcc                  fac= temp_qa_ja(bk2,bj2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                do bj2=bk2+1,.n_bf
!tempcc                  fac= temp_qa_ja(bk2,bj2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                .special_ket(k)[2] = bk2 
!tempcc                do bj1=1,bk1-1
!tempcc                  fac= temp_qb_jb(bk1,bj1)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                do bj1=bk1+1,.n_bf
!tempcc                  fac= temp_qb_jb(bk1,bj1)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                  end 
!tempcc                end
!tempcc                .special_ket(k)[1] = bk1 
!tempcc                fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
!tempcc                if( NOT fac.is_zero(.tol)) then
!tempcc                !  .special_ket(k)[1] = bk1 
!tempcc                !  .special_ket(k)[2] = bk2
!tempcc                  res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                end
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.1',dim,res
!tempcc !debug              
!tempcc              end !k special
!tempcc            end !do kk
!tempcc            nullify(temp_q_h2_ja_kb)
!tempcc            nullify(temp_q_h2_jb_ka)
!tempcc            temp_qb_h2_jb_ka.destroy
!tempcc            nullify(temp_qb_h2_jb_kb)
!tempcc            nullify(temp_qb_h2_jb_ex_kb)
!tempcc            temp_qa_h2_ja_kb.destroy
!tempcc            nullify(temp_qa_h2_ja_ka)
!tempcc            nullify(temp_qa_h2_ja_ex_ka)
!tempcc            temp_qa_h2_jb_ka.destroy
!tempcc            temp_qb_h2_ja_kb.destroy
!tempcc !case 1.3
!tempcc            temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
!tempcc            temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
!tempcc            !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
!tempcc            !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
!tempcc            !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
!tempcc            reorder_bra.create(dim-2)
!tempcc            do ii=dim-1,2,-1
!tempcc              temp_bra_i => .bra(ii)[:,:]
!tempcc              reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc              reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc              do bi2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc              end
!tempcc              end
!tempcc            end !ii case ii=1 remains 
!tempcc            temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc            reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc            do bi2=1,.n_bf
!tempcc            do bq1=1,.n_bf
!tempcc              fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc            end
!tempcc            end
!tempcc            reorder_bra.destroy
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.3',dim,res
!tempcc !debug              
!tempcc !case 1.2
!tempcc            fac=temp_qb_h2_j.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc            res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.2',dim,res
!tempcc !debug              
!tempcc !case 1.1
!tempcc            fac=temp_qb_jb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc            res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.1',dim,res
!tempcc !debug              
!tempcc          else !j>1
!tempcc            if (.special_ket(j)[1]==0) then !j not special
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc              if(temp_qa_h2_ja.destroyed) then
!tempcc                temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc                temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                temp_qa_ja.create(.n_bf,.n_bf)
!tempcc                temp_qb_jb.create(.n_bf,.n_bf)
!tempcc              end
!tempcc              do bj2=1,.n_bf
!tempcc              do bq2=1,.n_bf
!tempcc                temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
!tempcc                temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
!tempcc              end
!tempcc              end
!tempcc              do bj2=1,.n_bf
!tempcc              do bj1=1,.n_bf
!tempcc              do bq2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc                temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc                temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
!tempcc                temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!tempcc !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
!tempcc ! in case of memory shortage they can be created later but then the loop on kk 
!tempcc !must be done for each subcase.
!tempcc                temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
!tempcc                temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc              end
!tempcc              end
!tempcc !case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk) !cannot be 1
!tempcc !debug               
!tempcc !debug write(*,*) 'kk,k',kk,k
!tempcc !debug               
!tempcc                DIE_IF(k<2,"k cannot be 1")  !debug
!tempcc                reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) =  k
!tempcc                if (.special_ket(k)[1]==0) then !k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc !case 2.3
!tempcc                  if(temp_qa_h2_ja_kb.destroyed) then
!tempcc                    temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
!tempcc                    temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
!tempcc                    temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                    temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
!tempcc                  end
!tempcc !case 2.3.1 call special overlap ab
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                    temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                    temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
!tempcc                    temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  reorder_bra.create(dim-2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bk1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        do bq1=1,.n_bf
!tempcc                        do bi2=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                             + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                             + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                             + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                          res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bk1 
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
!tempcc                           + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.1',dim,res
!tempcc !debug              
!tempcc !case 2.3.2 call special overlap aa
!tempcc                  temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
!tempcc                  temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                    temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bk1=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk1
!tempcc                      do bj1=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj1 
!tempcc                        do bi1=1,.n_bf
!tempcc                        do bq1=1,.n_bf
!tempcc                          fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                             + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                          res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <<
!tempcc                      end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do bk1=1,.n_bf
!tempcc                    .special_ket(k)[2] = bk1
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      do bi1=1,.n_bf
!tempcc                      do bq1=1,.n_bf
!tempcc                        fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
!tempcc                           + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.2',dim,res
!tempcc !debug              
!tempcc !case 2.3.3 call special overlap bb
!tempcc                  temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
!tempcc                  temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
!tempcc                  do bj1=1,.n_bf
!tempcc                  do bj2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc ! respect the bra/ket nature of the indices
!tempcc                    temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                    temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bk2=1,.n_bf
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      do bj2=1,.n_bf
!tempcc                        .special_ket(k)[1] = bj2 
!tempcc                        do bi2=1,.n_bf
!tempcc                        do bq2=1,.n_bf
!tempcc                          fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                             + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                          res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
!tempcc                      end 
!tempcc                        end 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do bk2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                      do bi2=1,.n_bf
!tempcc                      do bq2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
!tempcc                           + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  reorder_bra.destroy
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.3',dim,res
!tempcc !debug              
!tempcc !case 2.2
!tempcc                 ! if(temp_q_h2_ja_kb.destroyed) then
!tempcc                 !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
!tempcc                 !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
!tempcc                 ! end
!tempcc                 ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
!tempcc                 ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
!tempcc                      temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
!tempcc                      fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bk1 
!tempcc                      res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                  end
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.2',dim,res
!tempcc !debug              
!tempcc !case 2.1
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bk1=1,.n_bf
!tempcc                      fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[1] = bk1 
!tempcc                        res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.1',dim,res
!tempcc !debug              
!tempcc                else !k special
!tempcc                  bk1=.special_ket(k)[1]
!tempcc                  bk2=.special_ket(k)[2]
!tempcc !case 2.3
!tempcc !case 2.3.1 call special overlap ab
!tempcc                  !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                  !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
!tempcc                  !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
!tempcc                  !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                  reorder_bra.create(dim-2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,bk2-1
!tempcc                 !    .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end
!tempcc                      end
!tempcc                    end
!tempcc                    do bj2=bk2+1,.n_bf
!tempcc                    ! .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                           + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end 
!tempcc                    end
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                    do bj1=1,bk1-1
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                 !    .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    do bj1=bk1+1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                  !   .special_ket(k)[2] = bk2
!tempcc                      do bq1=1,.n_bf
!tempcc                      do bi2=1,.n_bf
!tempcc                        fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                        res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                      end 
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                   !   .special_ket(k)[2] = bk2
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do bj2=1,bk2-1
!tempcc               !    .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                  ! .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bj1=1,bk1-1
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc               !    .special_ket(k)[2] = bk2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                !   .special_ket(k)[2] = bk2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                       + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                 !   .special_ket(k)[1] = bk1 
!tempcc                 !   .special_ket(k)[2] = bk2
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                  .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.1',dim,res
!tempcc !debug              
!tempcc !case 2.3.2 call special overlap aa
!tempcc                 !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
!tempcc                 !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj1=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                !     .special_ket(k)[2] = bk1
!tempcc                    do bi1=1,.n_bf
!tempcc                    do bq1=1,.n_bf
!tempcc                      fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                         + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do bj1=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                !   .special_ket(k)[2] = bk1
!tempcc                  do bi1=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc                    fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
!tempcc                       + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.2',dim,res
!tempcc !debug              
!tempcc !case 2.3.3 call special overlap bb
!tempcc                !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
!tempcc                !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bj2=1,.n_bf
!tempcc                      .special_ket(k)[1] = bj2 
!tempcc                  !   .special_ket(k)[2] = bk2
!tempcc                    do bi2=1,.n_bf
!tempcc                    do bq2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                         + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end
!tempcc                    end
!tempcc                  end !do ii , case ii=1 is left
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do bj2=1,.n_bf
!tempcc                    .special_ket(k)[1] = bj2 
!tempcc                 !  .special_ket(k)[2] = bk2
!tempcc                  do bi2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
!tempcc                       + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  reorder_bra.destroy
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.3',dim,res
!tempcc !debug              
!tempcc !case 2.2
!tempcc                  !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                  do bj2=1,bk2-1
!tempcc                    temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                    fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                    temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
!tempcc                    fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2
!tempcc                  !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                  do bj1=1,bk1-1
!tempcc                    temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                    fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                 !  .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
!tempcc                    fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                 !  .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
!tempcc                  fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              !    .special_ket(k)[1] = bk1 
!tempcc              !    .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.2',dim,res
!tempcc !debug              
!tempcc !case 2.1
!tempcc                  do bj2=1,bk2-1
!tempcc                    fac= temp_qa_ja(bk2,bj2)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                   !  .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  do bj2=bk2+1,.n_bf
!tempcc                    fac= temp_qa_ja(bk2,bj2)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                   !  .special_ket(k)[1] = bk1 
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bj1=1,bk1-1
!tempcc                    fac= temp_qb_jb(bk1,bj1)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  do bj1=bk1+1,.n_bf
!tempcc                    fac= temp_qb_jb(bk1,bj1)
!tempcc                    if( NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                    end 
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                  fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                  !  .special_ket(k)[1] = bk1 
!tempcc                  !  .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                  end
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.1',dim,res
!tempcc !debug              
!tempcc                end !k special
!tempcc              end !do kk
!tempcc              nullify(temp_q_h2_ja_kb)
!tempcc              nullify(temp_q_h2_jb_ka)
!tempcc              temp_qb_h2_jb_ka.destroy
!tempcc              nullify(temp_qb_h2_jb_kb)
!tempcc              nullify(temp_qb_h2_jb_ex_kb)
!tempcc              temp_qa_h2_ja_kb.destroy
!tempcc              nullify(temp_qa_h2_ja_ka)
!tempcc              nullify(temp_qa_h2_ja_ex_ka)
!tempcc              temp_qa_h2_jb_ka.destroy
!tempcc              temp_qb_h2_ja_kb.destroy
!tempcc !case 1.3
!tempcc              temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
!tempcc              temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
!tempcc              !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
!tempcc              !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
!tempcc              !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
!tempcc              reorder_bra.create(dim-2)
!tempcc              do ii=dim-1,2,-1
!tempcc                temp_bra_i => .bra(ii)[:,:]
!tempcc                reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                end
!tempcc              end !ii case ii=1 remains 
!tempcc              temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc              reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc              do bi2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc              end
!tempcc              end
!tempcc              reorder_bra.destroy
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.3',dim,res
!tempcc !debug              
!tempcc !case 1.2
!tempcc              fac=temp_qb_h2_j.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.2',dim,res
!tempcc !debug              
!tempcc !case 1.1
!tempcc              fac=temp_qb_jb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.1',dim,res
!tempcc !debug              
!tempcc            else ! j is a special ket
!tempcc ! warning: we have not changed the structure with respect to the case "not a
!tempcc ! special ket", therefore more space than needed is used and large parts of the
!tempcc ! arrays are dangerously not initialized.
!tempcc              bj1=.special_ket(j)[1]
!tempcc              bj2=.special_ket(j)[2]
!tempcc !case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk) !cannot be 1
!tempcc !debug               
!tempcc !debug write(*,*) 'kk,k',kk,k
!tempcc !debug               
!tempcc                DIE_IF(k<2,"k cannot be 1")  !debug
!tempcc                reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) =  k
!tempcc                DIE_IF(.special_ket(k)[1]==0,"j special ket but not k") 
!tempcc                bk1=.special_ket(k)[1]
!tempcc                bk2=.special_ket(k)[2]
!tempcc !case 2.3
!tempcc !case 2.3.1 call special overlap ab
!tempcc                !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
!tempcc                !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
!tempcc                !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                reorder_bra.create(dim-2)
!tempcc                if(bj2/=bk2 OR bj1/=bk1) then
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc               !    .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                           + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc             !    .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc                  .special_ket(k)[2] = bk2 
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                else !bj1==bk1 AND bj2==bk2
!tempcc                  do ii=dim-1,2,-1
!tempcc                    temp_bra_i => .bra(ii)[:,:]
!tempcc                    reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                    reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                    do bq1=1,.n_bf
!tempcc                    do bi2=1,.n_bf
!tempcc                      fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                         + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                         + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                 !     .special_ket(k)[1] = bk1 
!tempcc                 !     .special_ket(k)[2] = bk2
!tempcc                      res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                    end 
!tempcc                    end 
!tempcc                  end !do ii, the case ii=1 is left
!tempcc                  temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                  reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                  do bq1=1,.n_bf
!tempcc                  do bi2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
!tempcc                       + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
!tempcc                       + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
!tempcc                       + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc               !     .special_ket(k)[1] = bk1 
!tempcc               !     .special_ket(k)[2] = bk2
!tempcc                    res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!tempcc                      end 
!tempcc                  end 
!tempcc                  end 
!tempcc                end !bj1==bk1 AND bj2==bk2
!tempcc                .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.1',dim,res
!tempcc !debug              
!tempcc !case 2.3.2 call special overlap aa
!tempcc               !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
!tempcc               !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
!tempcc                .special_ket(k)[1] = bj1 
!tempcc              ! .special_ket(k)[2] = bk1
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bi1=1,.n_bf
!tempcc                  do bq1=1,.n_bf
!tempcc                    fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
!tempcc                       + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                  end
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do bi1=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
!tempcc                     + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                end
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.2',dim,res
!tempcc !debug              
!tempcc !case 2.3.3 call special overlap bb
!tempcc              !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
!tempcc              !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
!tempcc                .special_ket(k)[2] = bk2 
!tempcc                .special_ket(k)[1] = bj2 
!tempcc                do ii=dim-1,2,-1
!tempcc                  temp_bra_i => .bra(ii)[:,:]
!tempcc                  reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                  reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                  do bi2=1,.n_bf
!tempcc                  do bq2=1,.n_bf
!tempcc                    fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
!tempcc                       + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                    res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
!tempcc                      end 
!tempcc                  end 
!tempcc                  end
!tempcc                end !do ii , case ii=1 is left
!tempcc                temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc                reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq2=1,.n_bf
!tempcc                  fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
!tempcc                     + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
!tempcc                      end 
!tempcc                end 
!tempcc                end
!tempcc                .special_ket(k)[1] = bk1 
!tempcc                reorder_bra.destroy
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.3.3',dim,res
!tempcc !debug              
!tempcc !case 2.2
!tempcc                if(bj2/=bk2 OR bj1/=bk1) then
!tempcc                !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
!tempcc                  fac= temp_q_h2_ja_kb.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                !  .special_ket(k)[1] = bk1 
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                  .special_ket(k)[2] = bk2
!tempcc                !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
!tempcc                  fac= temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1 
!tempcc               !   .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                  .special_ket(k)[1] = bk1 
!tempcc                else !bj2==bk2 AND bj1==bk1
!tempcc                  temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
!tempcc                  temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
!tempcc                  fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc            !     .special_ket(k)[1] = bk1 
!tempcc            !     .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc                end !bj2==bk2 AND bj1==bk1
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.2',dim,res
!tempcc !debug              
!tempcc !case 2.1
!tempcc                if(bj2/=bk2 OR bj1/=bk1) then
!tempcc                  fac= temp_bra_q(bj1,bk2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1 
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                    .special_ket(k)[2] = bk2 
!tempcc                  end 
!tempcc                  fac= temp_bra_q(bk1,bj2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                    .special_ket(k)[1] = bk1 
!tempcc                  end 
!tempcc                else !bj2==bk2 AND bj1==bk1
!tempcc                  fac= temp_bra_q(bk1,bj2) + temp_bra_q(bj1,bk2)
!tempcc                  if( NOT fac.is_zero(.tol)) then
!tempcc                !   .special_ket(k)[1] = bk1 
!tempcc                !   .special_ket(k)[2] = bk2
!tempcc                    res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                  end
!tempcc                end !bj2==bk2 AND bj1==bk1
!tempcc !debug               
!tempcc !debug write(*,*) 'case 2.1',dim,res
!tempcc !debug              
!tempcc              end !do kk
!tempcc !             nullify(temp_q_h2_ja_kb)
!tempcc !             nullify(temp_q_h2_jb_ka)
!tempcc !             temp_qb_h2_jb_ka.destroy
!tempcc !             nullify(temp_qb_h2_jb_kb)
!tempcc !             nullify(temp_qb_h2_jb_ex_kb)
!tempcc !             temp_qa_h2_ja_kb.destroy
!tempcc !             nullify(temp_qa_h2_ja_ka)
!tempcc !             nullify(temp_qa_h2_ja_ex_ka)
!tempcc !             temp_qa_h2_jb_ka.destroy
!tempcc !             temp_qb_h2_ja_kb.destroy
!tempcc !case 1.3
!tempcc              temp_qa_h2_j=temp_qa_h2(:,:,bj1,bj2)
!tempcc              temp_qb_h2_j=temp_qb_h2(:,:,bj1,bj2)
!tempcc              !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
!tempcc              !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
!tempcc              !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
!tempcc              reorder_bra.create(dim-2)
!tempcc              do ii=dim-1,2,-1
!tempcc                temp_bra_i => .bra(ii)[:,:]
!tempcc                reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
!tempcc                reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
!tempcc                do bi2=1,.n_bf
!tempcc                do bq1=1,.n_bf
!tempcc                  fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                  res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc                end
!tempcc                end
!tempcc              end !ii case ii=1 remains 
!tempcc              temp_bra_i => .contraction_wfs(row_ind)[:,:]
!tempcc              reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
!tempcc              do bi2=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc                res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!tempcc                      end 
!tempcc              end
!tempcc              end
!tempcc              reorder_bra.destroy
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.3',dim,res
!tempcc !debug              
!tempcc   !case 1.2
!tempcc              fac=temp_qb_h2_j.trace
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.2',dim,res
!tempcc !debug              
!tempcc   !case 1.1
!tempcc              fac=temp_bra_q(bj1,bj2)
!tempcc                      if( NOT fac.is_zero(.tol)) then
!tempcc              res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
!tempcc                      end 
!tempcc !debug               
!tempcc !debug write(*,*) 'case 1.1',dim,res
!tempcc !debug              
!tempcc            end !j special ket
!tempcc          end !if j=1
!tempcc        end !do jj
!tempcc        temp_qa_h2_ja.destroy
!tempcc        temp_qb_h2_jb.destroy
!tempcc        temp_qa_h2_jb.destroy
!tempcc        temp_qb_h2_ja.destroy
!tempcc        temp_qa_h2_ja_ex.destroy
!tempcc        temp_qb_h2_jb_ex.destroy
!tempcc        temp_qa_ja.destroy
!tempcc        temp_qb_jb.destroy
!tempcc        temp_qa_h2_j.destroy
!tempcc        temp_qb_h2_j.destroy
!tempcc        temp_qa_h2.destroy
!tempcc        temp_qb_h2.destroy
!tempcc        reorder_ket.destroy
!tempcc      end !if dim=1
!tempcc    end
!tempcc 
!tempcc    overlap_for(order_bra,order_ket) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the overlap integrals matrix between
!tempcc    ! mean field (Sz=0)-geminals (upper triangle only is evaluated)
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if jj is a special ket,
!tempcc !than kk>jj is also a special ket.
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(.special_ket(1)[1]==0,".special_ket(1) already set")
!tempcc      ENSURE(order_ket.dim==order_bra.dim,"dim of bra not equal to dim of ket")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      row_ind,col_ind :: INT
!tempcc      q,jj,j,kk,k,dim,l,bq1,bj1,bj2,bk1,bk2 :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      reorder_bra :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_bra(dim)
!tempcc      res = ZERO
!tempcc       
!tempcc      if (dim==1) then ! only Case 1
!tempcc        j = order_ket(1)
!tempcc        DIE_IF(j/=1,"dim is 1 but j is not 1")
!tempcc        DIE_IF(q/=1,"dim is 1 but q is not 1")
!tempcc        do col_ind=1,.n_bas 
!tempcc          temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc          do row_ind=1,col_ind
!tempcc            fac = sum(.contraction_wfs(row_ind)[:,:]*temp_ket_j)
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res(row_ind,col_ind)=fac !permit to set to zero numbers below a threshold
!tempcc            end
!tempcc          end
!tempcc        end
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        DIE_IF(q==1,"q=1 but dim is more than 1")
!tempcc        reorder_bra.create(dim-1)
!tempcc        reorder_bra(1:dim-1)   = [ (order_bra(l), l=1,dim-1) ]
!tempcc        temp_bra_q => .bra(q)[:,:]
!tempcc        reorder_ket.create(dim-1)
!tempcc        temp_qa_ja.create(.n_bf,.n_bf)
!tempcc        temp_qb_jb.create(.n_bf,.n_bf)
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc          if (j==1) then ! 1 not special
!tempcc            do col_ind=1,.n_bas
!tempcc              temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc              do bj1=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc                temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc   ! Case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                if (.special_ket(k)[1]>0) then ! k special
!tempcc                  bk1 = .special_ket(k)[1]
!tempcc                  bk2 = .special_ket(k)[2]
!tempcc                  do bj1 = 1,bk1-1
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1 = bk1+1,.n_bf
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = 1,bk2-1
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = bk2+1,.n_bf
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res(:,col_ind) = res(:,col_ind) &
!tempcc                    - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                  end
!tempcc                else ! k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc                  do bk2 = 1,.n_bf
!tempcc                  do bj1 = 1,.n_bf
!tempcc                    fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc                end  ! if (.special_ket(k)
!tempcc              end !do kk
!tempcc   ! Case 1
!tempcc              !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_qb_jb.trace
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res(:,col_ind) = res(:,col_ind) &
!tempcc                + .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc              end
!tempcc            end !do col_ind
!tempcc          else ! j>1 
!tempcc            if (.special_ket(j)[1]>0) then
!tempcc              bj1 = .special_ket(j)[1]
!tempcc              bj2 = .special_ket(j)[2]
!tempcc ! Case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc                DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!tempcc !debug              if(.special_ket(k)[1]==0) then
!tempcc !debug     write(*,*) "j special but not k"
!tempcc !debug     stdout.show("dim=",dim)
!tempcc !debug     do l=1,dim
!tempcc !debug       stdout.show("l=",l)
!tempcc !debug       stdout.show("order_ket(l)=",order_ket(l))
!tempcc !debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!tempcc !debug     end
!tempcc !debug     stop
!tempcc !debug     end
!tempcc !assume special_ket's are also ordered at the end in the initial guess
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                if(bj1/=bk1 OR bj2/=bk2) then
!tempcc                  fac=temp_bra_q(bk1,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                  fac=temp_bra_q(bj1,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                else ! bj1==bk1 AND bj2==bk2
!tempcc                  fac=TWO * temp_bra_q(bk1,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                  end
!tempcc                end ! bj1==bk1 AND bj2==bk2
!tempcc              end !do kk
!tempcc ! Case 1
!tempcc              !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_bra_q(bj1,bj2)
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc              end
!tempcc            else !j not special
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc              do bj1=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc                temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc ! Case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                if (.special_ket(k)[1]>0) then ! k special
!tempcc                  bk1 = .special_ket(k)[1]
!tempcc                  bk2 = .special_ket(k)[2]
!tempcc                  do bj1 = 1,bk1-1
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1 = bk1+1,.n_bf
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = 1,bk2-1
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = bk2+1,.n_bf
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                  end
!tempcc                else ! k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc                  do bk2 = 1,.n_bf
!tempcc                  do bj1 = 1,.n_bf
!tempcc                    fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc                end  ! if (.special_ket(k)
!tempcc              end !do kk
!tempcc ! Case 1
!tempcc             ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_qb_jb.trace
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_bra,reorder_ket) * fac ! <<
!tempcc              end
!tempcc            end !j not special
!tempcc          end !if(j==1 AND .special_ket(1)==0) else
!tempcc        end  !do jj=dim,1,-1
!tempcc      temp_qa_ja.destroy
!tempcc      temp_qb_jb.destroy
!tempcc      reorder_ket.destroy
!tempcc      end ! if(dim==1)
!tempcc      reorder_bra.destroy
!tempcc    end
!tempcc 
!tempcc    overlap_for(order_bra,order_ket,col_ind) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the overlap integrals column
!tempcc    ! vector specified by col_ind between mean field (Sz=0)-geminals 
!tempcc    ! upper half only is evaluated.
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if jj is a special ket,
!tempcc !than kk>jj is also a special ket. 
!tempcc      col_ind :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: VEC{REAL}(.n_bas)
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(order_ket.dim==order_bra.dim,"dim of bra not equal to dim of ket")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      row_ind :: INT
!tempcc      q,jj,j,kk,k,dim,l,bq1,bj1,bj2,bk1,bk2 :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      reorder_bra :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_bra(dim)
!tempcc      res=ZERO
!tempcc 
!tempcc      if (dim==1) then ! only Case 1
!tempcc        j = order_ket(1)
!tempcc        DIE_IF(q/=1,"dim is 1 but q is not 1")
!tempcc        DIE_IF(j==1,"ket of contraction 1 has already appeared")
!tempcc        if (.special_ket(j)[1]>0) then             
!tempcc          bj1 = .special_ket(j)[1]                 
!tempcc          bj2 = .special_ket(j)[2]                
!tempcc          do row_ind=1,col_ind
!tempcc            fac = .contraction_wfs(row_ind)[bj1,bj2]
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res(row_ind)=fac !permit to set to zero numbers below a threshold
!tempcc            end
!tempcc          end
!tempcc        else 
!tempcc          temp_ket_j => .ket(j)[:,:]
!tempcc          do row_ind=1,col_ind
!tempcc            fac = sum(.contraction_wfs(row_ind)[:,:]*temp_ket_j)
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res(row_ind)=fac !permit to set to zero numbers below a threshold
!tempcc            end
!tempcc          end
!tempcc        end
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        DIE_IF(q==1,"q=1 but dim is more than 1")
!tempcc        reorder_bra.create(dim-1)
!tempcc        reorder_bra(1:dim-1)   = [ (order_bra(l), l=1,dim-1) ]
!tempcc        temp_bra_q => .bra(q)[:,:]
!tempcc        reorder_ket.create(dim-1)
!tempcc        temp_qa_ja.create(.n_bf,.n_bf)
!tempcc        temp_qb_jb.create(.n_bf,.n_bf)
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc          DIE_IF(j==1,"ket of contraction 1 has already appeared")
!tempcc          if (.special_ket(j)[1]>0) then
!tempcc            bj1 = .special_ket(j)[1]
!tempcc            bj2 = .special_ket(j)[2]
!tempcc ! Case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc !debug             if(.special_ket(k)[1]==0)then
!tempcc !debug               write(*,*) "j special but not k"
!tempcc !debug               stdout.show("dim=",dim)
!tempcc !debug               do l=1,dim
!tempcc !debug                 stdout.show("l=",l)
!tempcc !debug                 stdout.show("order_ket(l)=",order_ket(l))
!tempcc !debug                 stdout.show("special_ket(order_ket(l))",.special_ket(order_ket(l)).element)
!tempcc !debug               end
!tempcc !debug               write(*,*) "kk,k",kk,k
!tempcc !debug               write(*,*) "jj,j",jj,j
!tempcc !debug               stop
!tempcc !debug             end
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!tempcc !assume special_ket's are also ordered at the end in the initial guess
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) = k 
!tempcc              bk1 = .special_ket(k)[1]
!tempcc              bk2 = .special_ket(k)[2]
!tempcc              if(bj1/=bk1 OR bj2/=bk2) then
!tempcc                fac=temp_bra_q(bk1,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                  .special_ket(k)[1] = bk1
!tempcc                end
!tempcc                fac=temp_bra_q(bj1,bk2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc               !  .special_ket(k)[1] = bk1
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                  .special_ket(k)[2] = bk2
!tempcc                end
!tempcc              else ! bj1==bk1 AND bj2==bk2
!tempcc                fac=TWO * temp_bra_q(bk1,bk2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc               !  .special_ket(k)[1] = bk1
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                end
!tempcc              end ! bj1==bk1 AND bj2==bk2
!tempcc            end !do kk
!tempcc ! Case 1
!tempcc          !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc            fac = temp_bra_q(bj1,bj2)
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc            end
!tempcc          else !j not special
!tempcc            temp_ket_j => .ket(j)[:,:]
!tempcc            do bj1=1,.n_bf
!tempcc            do bq1=1,.n_bf
!tempcc              temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc              temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc            end
!tempcc            end
!tempcc ! Case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) = k 
!tempcc              if (.special_ket(k)[1]>0) then ! k special
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                do bj1 = 1,bk1-1
!tempcc                  fac=temp_qb_jb(bk1,bj1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                end
!tempcc                do bj1 = bk1+1,.n_bf
!tempcc                  fac=temp_qb_jb(bk1,bj1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                end
!tempcc                do bj2 = 1,bk2-1
!tempcc                  fac=temp_qa_ja(bk2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                end
!tempcc                do bj2 = bk2+1,.n_bf
!tempcc                  fac=temp_qa_ja(bk2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                end
!tempcc                fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                ! .special_ket(k)[1] = bk1
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                end
!tempcc              else ! k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc                do bk2 = 1,.n_bf
!tempcc                do bj1 = 1,.n_bf
!tempcc                  fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                  end
!tempcc                end
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc              end  ! if (.special_ket(k)
!tempcc            end !do kk
!tempcc ! Case 1
!tempcc          !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc            fac = temp_qb_jb.trace
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
!tempcc            end
!tempcc          end !j not special
!tempcc        end  !do jj=dim,1,-1
!tempcc      temp_qa_ja.destroy
!tempcc      temp_qb_jb.destroy
!tempcc      reorder_ket.destroy
!tempcc      end ! if(dim==1)
!tempcc      reorder_bra.destroy
!tempcc    end
!tempcc 
!tempcc    overlap_for(order_bra,order_ket,row_ind,col_ind) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the overlap integrals matrix
!tempcc    ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if jj is a special ket,
!tempcc !than kk>jj is also a special ket.
!tempcc      row_ind, col_ind :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: REAL
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(order_ket.dim==order_bra.dim,"dim of bra not equal to dim of ket")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
!tempcc      q,jj,j,kk,k,dim,l,bq1,bj1,bj2,bk1,bk2 :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      reorder_bra :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_bra(dim)
!tempcc      if(q==1) then
!tempcc        temp_bra_q => .contraction_wfs(row_ind)[:,:]
!tempcc      else
!tempcc        temp_bra_q => .bra(q)[:,:]
!tempcc      end
!tempcc      reorder_bra.create(dim-1)
!tempcc      reorder_bra(1:dim-1)   = [ (order_bra(l), l=1,dim-1) ]
!tempcc      res = ZERO
!tempcc       
!tempcc      if (dim==1) then ! only Case 1
!tempcc        j = order_ket(1)
!tempcc        if (.special_ket(j)[1]>0) then             
!tempcc          bj1 = .special_ket(j)[1]                 
!tempcc          bj2 = .special_ket(j)[2]                
!tempcc          fac = temp_bra_q(bj1,bj2)
!tempcc        else if(.special_ket(j)[1]==0 AND j==1) then
!tempcc          fac = sum(temp_bra_q*.contraction_wfs(col_ind)[:,:])
!tempcc        else if (.special_ket(j)[1]==0 AND j/=1) then
!tempcc          fac = sum(temp_bra_q*.ket(j)[:,:])
!tempcc        end
!tempcc        if (NOT fac.is_zero(.tol)) then
!tempcc           res = fac
!tempcc        end
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        reorder_ket.create(dim-1)
!tempcc        temp_qa_ja.create(.n_bf,.n_bf)
!tempcc        temp_qb_jb.create(.n_bf,.n_bf)
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc          if (j==1 AND .special_ket(1)[1]==0) then ! 1 not special
!tempcc            temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc            do bj1=1,.n_bf
!tempcc            do bq1=1,.n_bf
!tempcc              temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc              temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc            end
!tempcc            end
!tempcc ! Case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) = k 
!tempcc              if (.special_ket(k)[1]>0) then ! k special
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                do bj1 = 1,bk1-1
!tempcc                  fac=temp_qb_jb(bk1,bj1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                end
!tempcc                do bj1 = bk1+1,.n_bf
!tempcc                  fac=temp_qb_jb(bk1,bj1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                end
!tempcc                do bj2 = 1,bk2-1
!tempcc                  fac=temp_qa_ja(bk2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                end
!tempcc                do bj2 = bk2+1,.n_bf
!tempcc                  fac=temp_qa_ja(bk2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                end
!tempcc                fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                ! .special_ket(k)[1] = bk1
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                end
!tempcc              else ! k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc                do bk2 = 1,.n_bf
!tempcc                do bj1 = 1,.n_bf
!tempcc                  fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                  end
!tempcc                end
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc              end  ! if (.special_ket(k)
!tempcc            end !do kk
!tempcc ! Case 1
!tempcc          !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc            fac = temp_qb_jb.trace
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc            end
!tempcc          else ! j>1 or 1 special
!tempcc            if (.special_ket(j)[1]>0) then
!tempcc              bj1 = .special_ket(j)[1]
!tempcc              bj2 = .special_ket(j)[2]
!tempcc ! Case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc                DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!tempcc !debug              if(.special_ket(k)[1]==0) then
!tempcc !debug     write(*,*) "j special but not k"
!tempcc !debug     stdout.show("dim=",dim)
!tempcc !debug     do l=1,dim
!tempcc !debug       stdout.show("l=",l)
!tempcc !debug       stdout.show("order_ket(l)=",order_ket(l))
!tempcc !debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!tempcc !debug     end
!tempcc !debug     stop
!tempcc !debug     end
!tempcc !assume special_ket's are also ordered at the end in the initial guess
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                if(bj1/=bk1 OR bj2/=bk2) then
!tempcc                  fac=temp_bra_q(bk1,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                  fac=temp_bra_q(bj1,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                else ! bj1==bk1 AND bj2==bk2
!tempcc                  fac=TWO * temp_bra_q(bk1,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                  end
!tempcc                end ! bj1==bk1 AND bj2==bk2
!tempcc              end !do kk
!tempcc ! Case 1
!tempcc         !     reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_bra_q(bj1,bj2)
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc              end
!tempcc            else !j not special
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc              do bj1=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc                temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc ! Case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                if (.special_ket(k)[1]>0) then ! k special
!tempcc                  bk1 = .special_ket(k)[1]
!tempcc                  bk2 = .special_ket(k)[2]
!tempcc                  do bj1 = 1,bk1-1
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1 = bk1+1,.n_bf
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = 1,bk2-1
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = bk2+1,.n_bf
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                  end
!tempcc                else ! k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc                  do bk2 = 1,.n_bf
!tempcc                  do bj1 = 1,.n_bf
!tempcc                    fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc                end  ! if (.special_ket(k)
!tempcc              end !do kk
!tempcc ! Case 1
!tempcc            !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_qb_jb.trace
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc              end
!tempcc            end !j not special
!tempcc          end !if(j==1 AND .special_ket(1)==0) else
!tempcc        end  !do jj=dim,1,-1
!tempcc      temp_qa_ja.destroy
!tempcc      temp_qb_jb.destroy
!tempcc      reorder_ket.destroy
!tempcc      end ! if(dim==1)
!tempcc      reorder_bra.destroy
!tempcc    end
!tempcc 
!tempcc !It is possible to speed up a bit the
!tempcc !special_overlap_spin_xy_for(order_bra,order_ket,row_ind,col_ind,b1,b2) routines
!tempcc !by taking into account the fact that the bra and ket of contraction 1 have already been
!tempcc !found when it is called when performing an Hamiltonian matrix calculation,
!tempcc !however the routine won't work afterwards when only a single Hamiltonian matrix
!tempcc !element is calculated with hamiltonian_for(v,order_ket,row_ind,col_ind).
!tempcc 
!tempcc    special_overlap_spin_ab_for(order_bra,order_ket,b1,b2) result (res) ::: recursive
!tempcc    ! Special function which evaluates the overlap integrals matrix between
!tempcc    ! mean field (Sz=0)-geminals when .bra(dim) is a special bra
!tempcc !comments: should not be called if dim=1 because row_ind would
!tempcc ! be already defined.
!tempcc      b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(order_ket.dim>1,"dimension less than two")
!tempcc      ENSURE(.special_ket(1)[2]==0,"ket already set for contr 1")
!tempcc      col_ind :: INT
!tempcc      dim,bq1,bq2,q,jj,bj1,bj2,j,kk,bk1,bk2,k :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      DIE_IF(q==1,"ket of contraction 1 not in place")
!tempcc      res = ZERO
!tempcc      
!tempcc      if(.special_ket(q)[2]==0) then !not a special ket
!tempcc        temp_ket_q => .ket(q)[:,:]
!tempcc        do bq1=1,.n_bf
!tempcc          .special_ket(q)[1]=bq1
!tempcc          do bq2=1,.n_bf
!tempcc            if (NOT temp_ket_q(bq1,bq2).is_zero) then
!tempcc              .special_ket(q)[2]=bq2
!tempcc              res=res+.special_overlap_spin_ab_for(order_bra,order_ket,b1,b2) &
!tempcc                    *temp_ket_q(bq1,bq2) 
!tempcc            end
!tempcc          end
!tempcc        end
!tempcc        .special_ket(q)[1]=0
!tempcc        .special_ket(q)[2]=0
!tempcc        return
!tempcc      end
!tempcc ! at this stage q is necessarily a special ket and dim>1
!tempcc      reorder_ket.create(dim-1)
!tempcc      do jj = dim,1,-1
!tempcc         j = order_ket(jj)
!tempcc         reorder_ket(1:jj-1)   = order_ket(1:jj-1)
!tempcc         reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc         if (.special_ket(j)[1]>0) then  !j special
!tempcc           bj1 = .special_ket(j)[1]
!tempcc           bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc           if (bj1==b1 AND bj2==b2 ) then
!tempcc             res = res + .overlap_for(order_bra,reorder_ket)  ! <<
!tempcc           end
!tempcc ! Case 2
!tempcc           do kk = dim,jj+1,-1
!tempcc             k = order_ket(kk)
!tempcc             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc !debug              if(.special_ket(k)[1]==0) then
!tempcc !debug                write(*,*) 'j special but not k'
!tempcc !debug                stop
!tempcc !debug              end
!tempcc             bk1 = .special_ket(k)[1]
!tempcc             bk2 = .special_ket(k)[2]
!tempcc       !      reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc             reorder_ket(dim-1) = k 
!tempcc             fac = ZERO
!tempcc             if (bj1==b1 AND bk2==b2 AND (bj2/=b2 OR bk1/=b1)) then
!tempcc               fac = ONE
!tempcc             ! .special_ket(k)[1] = bk1 ! 
!tempcc               .special_ket(k)[2] = bj2 
!tempcc             else if((bj1/=b1 OR bk2/=b2) AND bj2==b2 AND bk1==b1) then
!tempcc               fac = ONE
!tempcc               .special_ket(k)[1] = bj1 ! 
!tempcc             ! .special_ket(k)[2] = bk2 
!tempcc             else if(bj1==b1 AND bk2==b2 AND bj2==b2 AND bk1==b1) then
!tempcc                fac=TWO 
!tempcc             ! .special_ket(k)[1] = bk1  
!tempcc             ! .special_ket(k)[2] = bk2 
!tempcc             end
!tempcc             res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc             .special_ket(k)[1] = bk1
!tempcc             .special_ket(k)[2] = bk2
!tempcc           end !do kk
!tempcc         else ! j not special
!tempcc           if(j==1)then
!tempcc          !   reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc             do col_ind=1,.n_bas
!tempcc               temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc ! Case 1
!tempcc               reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc               fac = temp_ket_j(b1,b2)
!tempcc               if (NOT fac.is_zero(.tol)) then
!tempcc                 res(:,col_ind) = res(:,col_ind) &
!tempcc                 + .overlap_for(order_bra,reorder_ket,col_ind)*fac ! <<
!tempcc               end
!tempcc ! Case 2
!tempcc               do kk = dim,jj+1,-1
!tempcc                 k = order_ket(kk)
!tempcc !3-04-05               reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc                 reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                 reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                 reorder_ket(dim-1) = k 
!tempcc                 if (.special_ket(k)[1]>0) then
!tempcc ! Case 2, k special
!tempcc                   bk1 = .special_ket(k)[1]
!tempcc                   bk2 = .special_ket(k)[2]
!tempcc                   if (bk2 == b2 AND bk1 /= b1) then
!tempcc                     do bj2 = 1,.n_bf
!tempcc                       fac = temp_ket_j(b1,bj2)
!tempcc                       if (NOT fac.is_zero(.tol)) then
!tempcc                     !   .special_ket(k)[1] = bk1 
!tempcc                         .special_ket(k)[2] = bj2
!tempcc                         res(:,col_ind) = res(:,col_ind) &
!tempcc                         - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                       end
!tempcc                     end
!tempcc                     .special_ket(k)[2] = bk2
!tempcc                   else if (bk2 /= b2 AND bk1 == b1) then   
!tempcc                     do bj1 = 1,.n_bf
!tempcc                       fac = temp_ket_j(bj1,b2)
!tempcc                       if (NOT fac.is_zero(.tol)) then
!tempcc                         .special_ket(k)[1] = bj1 
!tempcc                      !  .special_ket(k)[2] = bk2
!tempcc                         res(:,col_ind) = res(:,col_ind) &
!tempcc                         - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                       end
!tempcc                     end
!tempcc                     .special_ket(k)[1] = bk1
!tempcc                   else if (bk2 == b2 AND bk1 == b1) then   
!tempcc                     do bj1 = 1,b1-1
!tempcc                       fac = temp_ket_j(bj1,b2)
!tempcc                       if (NOT fac.is_zero(.tol)) then
!tempcc                         .special_ket(k)[1] = bj1 
!tempcc                      !  .special_ket(k)[2] = bk2
!tempcc                         res(:,col_ind) = res(:,col_ind) &
!tempcc                         - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                       end
!tempcc                     end
!tempcc                     do bj1 = b1+1,.n_bf
!tempcc                       fac = temp_ket_j(bj1,b2)
!tempcc                       if (NOT fac.is_zero(.tol)) then
!tempcc                         .special_ket(k)[1] = bj1 
!tempcc                      !  .special_ket(k)[2] = bk2
!tempcc                         res(:,col_ind) = res(:,col_ind) &
!tempcc                         - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                       end
!tempcc                     end
!tempcc                     .special_ket(k)[1] = bk1
!tempcc                     do bj2 = 1,b2-1
!tempcc                       fac = temp_ket_j(b1,bj2)
!tempcc                       if (NOT fac.is_zero(.tol)) then
!tempcc                     !   .special_ket(k)[1] = bk1 
!tempcc                         .special_ket(k)[2] = bj2
!tempcc                         res(:,col_ind) = res(:,col_ind) &
!tempcc                         - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                       end
!tempcc                     end
!tempcc                     do bj2 = b2+1,.n_bf
!tempcc                       fac = temp_ket_j(b1,bj2)
!tempcc                       if (NOT fac.is_zero(.tol)) then
!tempcc                     !   .special_ket(k)[1] = bk1 
!tempcc                         .special_ket(k)[2] = bj2
!tempcc                         res(:,col_ind) = res(:,col_ind) &
!tempcc                         - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                       end
!tempcc                     end
!tempcc                     .special_ket(k)[2] = bk2
!tempcc                     fac = TWO*temp_ket_j(b1,b2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                     !   .special_ket(k)[1] = bk1 
!tempcc                     !   .special_ket(k)[2] = bk2 
!tempcc                       res(:,col_ind) = res(:,col_ind) &
!tempcc                       - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                     end
!tempcc                   end !else if (bk2 == b2 AND bk1 == b1)
!tempcc                 else !  Case 2, NONE SPECIAL
!tempcc                   temp_ket_k => .ket(k)[:,:]
!tempcc                   do bj2 = 1,.n_bf
!tempcc                   do bk1 = 1,.n_bf
!tempcc                     fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                       .special_ket(k)[1] = bk1 
!tempcc                       .special_ket(k)[2] = bj2
!tempcc                       res(:,col_ind) = res(:,col_ind) &
!tempcc                       - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                     end 
!tempcc                   end
!tempcc                   end
!tempcc                   .special_ket(k)[1] = 0 
!tempcc                   .special_ket(k)[2] = 0
!tempcc                 end ! if k special
!tempcc               end !do kk
!tempcc             end !do col_ind
!tempcc           else !j/=1
!tempcc             temp_ket_j => .ket(j)[:,:]
!tempcc ! Case 1
!tempcc !3-04-05            reorder_ket(1:jj-1) = order_ket(1:jj-1) 
!tempcc !3-04-05            reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc             fac = temp_ket_j(b1,b2)
!tempcc             if (NOT fac.is_zero(.tol)) then
!tempcc               res = res + .overlap_for(order_bra,reorder_ket)*fac ! <<
!tempcc             end
!tempcc   ! Case 2
!tempcc             do kk = dim,jj+1,-1
!tempcc               k = order_ket(kk)
!tempcc               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc               reorder_ket(dim-1) = k 
!tempcc               if (.special_ket(k)[1]>0) then
!tempcc   ! Case 2, k special
!tempcc                 bk1 = .special_ket(k)[1]
!tempcc                 bk2 = .special_ket(k)[2]
!tempcc                 if (bk2 == b2 AND bk1 /= b1) then
!tempcc                   do bj2 = 1,.n_bf
!tempcc                     fac = temp_ket_j(b1,bj2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                       .special_ket(k)[2] = bj2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                     end
!tempcc                   end
!tempcc                   .special_ket(k)[2] = bk2
!tempcc                 else if (bk2 /= b2 AND bk1 == b1) then   
!tempcc                   do bj1 = 1,.n_bf
!tempcc                     fac = temp_ket_j(bj1,b2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                       .special_ket(k)[1] = bj1 
!tempcc                    !  .special_ket(k)[2] = bk2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                     end
!tempcc                   end
!tempcc                   .special_ket(k)[1] = bk1
!tempcc                 else if (bk2 == b2 AND bk1 == b1) then   
!tempcc                   do bj1 = 1,b1-1
!tempcc                     fac = temp_ket_j(bj1,b2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                       .special_ket(k)[1] = bj1 
!tempcc                    !  .special_ket(k)[2] = bk2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                     end
!tempcc                   end
!tempcc                   do bj1 = b1+1,.n_bf
!tempcc                     fac = temp_ket_j(bj1,b2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                       .special_ket(k)[1] = bj1 
!tempcc                    !  .special_ket(k)[2] = bk2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                     end
!tempcc                   end
!tempcc                   .special_ket(k)[1] = bk1
!tempcc                   do bj2 = 1,b2-1
!tempcc                     fac = temp_ket_j(b1,bj2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                       .special_ket(k)[2] = bj2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                     end
!tempcc                   end
!tempcc                   do bj2 = b2+1,.n_bf
!tempcc                     fac = temp_ket_j(b1,bj2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                       .special_ket(k)[2] = bj2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                     end
!tempcc                   end
!tempcc                   .special_ket(k)[2] = bk2
!tempcc                   fac = TWO*temp_ket_j(b1,b2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                   !   .special_ket(k)[2] = bk2 
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                   end
!tempcc                 end !else if (bk2 == b2 AND bk1 == b1)
!tempcc               else !  Case 2, NONE SPECIAL
!tempcc                 temp_ket_k => .ket(k)[:,:]
!tempcc                 do bj2 = 1,.n_bf
!tempcc                 do bk1 = 1,.n_bf
!tempcc                   fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                     .special_ket(k)[1] = bk1 
!tempcc                     .special_ket(k)[2] = bj2
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                   end 
!tempcc                 end
!tempcc                 end
!tempcc                 .special_ket(k)[1] = 0 
!tempcc                 .special_ket(k)[2] = 0
!tempcc               end ! if k special
!tempcc             end !do kk
!tempcc           end !j==1
!tempcc         end! if j special
!tempcc      end !do jj
!tempcc      reorder_ket.destroy
!tempcc    end
!tempcc 
!tempcc    special_overlap_spin_ab_for(order_bra,order_ket,col_ind,b1,b2) result (res) ::: recursive
!tempcc    ! Special function which evaluates the overlap integrals column vector
!tempcc    ! specified by col_ind between mean field (Sz=0)-geminals when .bra(dim) is a special bra
!tempcc !comments: should not be called if dim=1 because row_ind would be already defined.
!tempcc      col_ind,b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: VEC{REAL}(.n_bas)
!tempcc      ENSURE(order_ket.dim>1,"dimension less than two")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      dim,bq1,bq2,q,jj,bj1,bj2,j,kk,bk1,bk2,k :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      DIE_IF(q==1,"ket of contraction 1 not in place")
!tempcc      res = ZERO
!tempcc      
!tempcc      if(.special_ket(q)[2]==0) then !not a special ket
!tempcc        temp_ket_q => .ket(q)[:,:]
!tempcc        do bq1=1,.n_bf
!tempcc          .special_ket(q)[1]=bq1
!tempcc          do bq2=1,.n_bf
!tempcc            if (NOT temp_ket_q(bq1,bq2).is_zero) then
!tempcc              .special_ket(q)[2]=bq2
!tempcc              res=res+.special_overlap_spin_ab_for(order_bra,order_ket,col_ind,b1,b2) &
!tempcc                    *temp_ket_q(bq1,bq2) 
!tempcc            end
!tempcc          end
!tempcc        end
!tempcc        .special_ket(q)[1]=0
!tempcc        .special_ket(q)[2]=0
!tempcc        return
!tempcc      end
!tempcc ! at this stage q is necessarily a special ket and dim>1
!tempcc      reorder_ket.create(dim-1)
!tempcc      do jj = dim,1,-1
!tempcc         reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc         reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc         j = order_ket(jj)
!tempcc         DIE_IF(j==1,"ket of contraction 1 has already appeared")
!tempcc         if (.special_ket(j)[1]>0) then  !j special
!tempcc           bj1 = .special_ket(j)[1]
!tempcc           bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc           if (bj1==b1 AND bj2==b2 ) then
!tempcc             res = res + .overlap_for(order_bra,reorder_ket,col_ind)  ! <<
!tempcc           end
!tempcc ! Case 2
!tempcc           do kk = dim,jj+1,-1
!tempcc             k = order_ket(kk)
!tempcc             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc !debug              if(.special_ket(k)[1]==0) then
!tempcc !debug                write(*,*) 'j special but not k'
!tempcc !debug                stop
!tempcc !debug              end
!tempcc             bk1 = .special_ket(k)[1]
!tempcc             bk2 = .special_ket(k)[2]
!tempcc       !      reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc             reorder_ket(dim-1) = k 
!tempcc             fac = ZERO
!tempcc             if (bj1==b1 AND bk2==b2 AND (bj2/=b2 OR bk1/=b1)) then
!tempcc               fac = ONE
!tempcc             ! .special_ket(k)[1] = bk1 ! 
!tempcc               .special_ket(k)[2] = bj2 
!tempcc             else if((bj1/=b1 OR bk2/=b2) AND bj2==b2 AND bk1==b1) then
!tempcc               fac = ONE
!tempcc               .special_ket(k)[1] = bj1 ! 
!tempcc             ! .special_ket(k)[2] = bk2 
!tempcc             else if(bj1==b1 AND bk2==b2 AND bj2==b2 AND bk1==b1) then
!tempcc                fac=TWO 
!tempcc             ! .special_ket(k)[1] = bk1  
!tempcc             ! .special_ket(k)[2] = bk2 
!tempcc             end
!tempcc             res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc             .special_ket(k)[1] = bk1
!tempcc             .special_ket(k)[2] = bk2
!tempcc           end !do kk
!tempcc         else ! j not special
!tempcc           temp_ket_j => .ket(j)[:,:]
!tempcc ! Case 1
!tempcc           fac = temp_ket_j(b1,b2)
!tempcc           if (NOT fac.is_zero(.tol)) then
!tempcc             res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac ! <<
!tempcc           end
!tempcc ! Case 2
!tempcc           do kk = dim,jj+1,-1
!tempcc             k = order_ket(kk)
!tempcc !3-04-05            reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc             reorder_ket(dim-1) = k 
!tempcc             if (.special_ket(k)[1]>0) then
!tempcc ! Case 2, k special
!tempcc               bk1 = .special_ket(k)[1]
!tempcc               bk2 = .special_ket(k)[2]
!tempcc               if (bk2 == b2 AND bk1 /= b1) then
!tempcc                 do bj2 = 1,.n_bf
!tempcc                   fac = temp_ket_j(b1,bj2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                 !   .special_ket(k)[1] = bk1 
!tempcc                     .special_ket(k)[2] = bj2
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                   end
!tempcc                 end
!tempcc                 .special_ket(k)[2] = bk2
!tempcc               else if (bk2 /= b2 AND bk1 == b1) then   
!tempcc                 do bj1 = 1,.n_bf
!tempcc                   fac = temp_ket_j(bj1,b2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                     .special_ket(k)[1] = bj1 
!tempcc                  !  .special_ket(k)[2] = bk2
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                   end
!tempcc                 end
!tempcc                 .special_ket(k)[1] = bk1
!tempcc               else if (bk2 == b2 AND bk1 == b1) then   
!tempcc                 do bj1 = 1,b1-1
!tempcc                   fac = temp_ket_j(bj1,b2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                     .special_ket(k)[1] = bj1 
!tempcc                  !  .special_ket(k)[2] = bk2
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                   end
!tempcc                 end
!tempcc                 do bj1 = b1+1,.n_bf
!tempcc                   fac = temp_ket_j(bj1,b2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                     .special_ket(k)[1] = bj1 
!tempcc                  !  .special_ket(k)[2] = bk2
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                   end
!tempcc                 end
!tempcc                 .special_ket(k)[1] = bk1
!tempcc                 do bj2 = 1,b2-1
!tempcc                   fac = temp_ket_j(b1,bj2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                 !   .special_ket(k)[1] = bk1 
!tempcc                     .special_ket(k)[2] = bj2
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                   end
!tempcc                 end
!tempcc                 do bj2 = b2+1,.n_bf
!tempcc                   fac = temp_ket_j(b1,bj2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                 !   .special_ket(k)[1] = bk1 
!tempcc                     .special_ket(k)[2] = bj2
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                   end
!tempcc                 end
!tempcc                 .special_ket(k)[2] = bk2
!tempcc                 fac = TWO*temp_ket_j(b1,b2)
!tempcc                 if (NOT fac.is_zero(.tol)) then
!tempcc                 !   .special_ket(k)[1] = bk1 
!tempcc                 !   .special_ket(k)[2] = bk2 
!tempcc                   res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                 end
!tempcc               end !else if (bk2 == b2 AND bk1 == b1)
!tempcc             else !  Case 2, NONE SPECIAL
!tempcc               temp_ket_k => .ket(k)[:,:]
!tempcc               do bj2 = 1,.n_bf
!tempcc               do bk1 = 1,.n_bf
!tempcc                 fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
!tempcc                 if (NOT fac.is_zero(.tol)) then
!tempcc                   .special_ket(k)[1] = bk1 
!tempcc                   .special_ket(k)[2] = bj2
!tempcc                   res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                 end 
!tempcc               end
!tempcc               end
!tempcc               .special_ket(k)[1] = 0 
!tempcc               .special_ket(k)[2] = 0
!tempcc             end ! if k special
!tempcc           end !do kk
!tempcc         end! if j special
!tempcc      end !do jj
!tempcc      reorder_ket.destroy
!tempcc    end
!tempcc 
!tempcc    special_overlap_spin_ab_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res) ::: recursive
!tempcc    ! Special function which evaluates the overlap integrals matrix element
!tempcc    ! specified by row_ind and col_ind between mean field (Sz=0)-geminals when .bra(dim) is a special bra
!tempcc      row_ind,col_ind,b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: REAL
!tempcc !     ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
!tempcc      dim,bq1,bq2,q,jj,bj1,bj2,j,kk,bk1,bk2,k :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      res = ZERO
!tempcc !debug
!tempcc !debug do i=1,dim
!tempcc !debug  write(*,*)"i=",i
!tempcc !debug j=order_ket(i)
!tempcc !debug  stdout.show("order_ket-in",order_ket(i))
!tempcc !debug  stdout.show("special_ket(j)-in",.special_ket(j).element)
!tempcc !debug enddo
!tempcc !debug
!tempcc      
!tempcc      if(.special_ket(q)[2]==0) then !not a special ket
!tempcc        if(q==1) then
!tempcc          DIE_IF(dim/=1,"order(dim>1)=1")
!tempcc          temp_ket_q => .contraction_wfs(col_ind)[:,:]
!tempcc        else
!tempcc          temp_ket_q => .ket(q)[:,:]
!tempcc        end
!tempcc        do bq1=1,.n_bf
!tempcc          .special_ket(q)[1]=bq1
!tempcc          do bq2=1,.n_bf
!tempcc            if (NOT temp_ket_q(bq1,bq2).is_zero) then
!tempcc              .special_ket(q)[2]=bq2
!tempcc              res=res+.special_overlap_spin_ab_for(order_bra,order_ket,row_ind,col_ind,b1,b2) &
!tempcc                    *temp_ket_q(bq1,bq2) 
!tempcc            end
!tempcc          end
!tempcc        end
!tempcc        .special_ket(q)[1]=0
!tempcc        .special_ket(q)[2]=0
!tempcc        return
!tempcc      end
!tempcc ! at this stage q is necessarily a special ket
!tempcc      if(dim==1) then
!tempcc        if (.special_ket(q)[1]==b1 AND .special_ket(q)[2]==b2 ) res = ONE
!tempcc        return
!tempcc      else ! q special ket and dim>1
!tempcc        reorder_ket.create(dim-1)
!tempcc        do jj = dim,1,-1
!tempcc           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc           reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc           j = order_ket(jj)
!tempcc           if (.special_ket(j)[1]>0) then  !j special
!tempcc             bj1 = .special_ket(j)[1]
!tempcc             bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc             if (bj1==b1 AND bj2==b2 ) then
!tempcc               res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)  ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res11 in special_overlap_ab",res
!tempcc !debug
!tempcc             end
!tempcc ! Case 2
!tempcc             do kk = dim,jj+1,-1
!tempcc               k = order_ket(kk)
!tempcc               DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc !debug              if(.special_ket(k)[1]==0) then
!tempcc !debug                write(*,*) 'j special but not k'
!tempcc !debug                stop
!tempcc !debug              end
!tempcc               bk1 = .special_ket(k)[1]
!tempcc               bk2 = .special_ket(k)[2]
!tempcc           !    reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc               reorder_ket(dim-1) = k 
!tempcc !the following line was forgotten, the bug has been fixed in Nice 
!tempcc               fac = ZERO
!tempcc               if (bj1==b1 AND bk2==b2 AND (bj2/=b2 OR bk1/=b1)) then
!tempcc                 fac = ONE
!tempcc               ! .special_ket(k)[1] = bk1 ! 
!tempcc                 .special_ket(k)[2] = bj2 
!tempcc               else if((bj1/=b1 OR bk2/=b2) AND bj2==b2 AND bk1==b1) then
!tempcc                 fac = ONE
!tempcc                 .special_ket(k)[1] = bj1 ! 
!tempcc               ! .special_ket(k)[2] = bk2 
!tempcc               else if(bj1==b1 AND bk2==b2 AND bj2==b2 AND bk1==b1) then
!tempcc                  fac=TWO 
!tempcc               ! .special_ket(k)[1] = bk1  
!tempcc               ! .special_ket(k)[2] = bk2 
!tempcc               end
!tempcc               res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res10 in special_overlap_ab",res
!tempcc !debug
!tempcc               .special_ket(k)[1] = bk1
!tempcc               .special_ket(k)[2] = bk2
!tempcc             end !do kk
!tempcc           else ! j not special
!tempcc             if(j==1)then
!tempcc               temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc             else
!tempcc               temp_ket_j => .ket(j)[:,:]
!tempcc             end
!tempcc ! Case 1
!tempcc             fac = temp_ket_j(b1,b2)
!tempcc             if (NOT fac.is_zero(.tol)) then
!tempcc               res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res9 in special_overlap_ab",res
!tempcc !debug
!tempcc             end
!tempcc ! Case 2
!tempcc             do kk = dim,jj+1,-1
!tempcc               k = order_ket(kk)
!tempcc !3-04-05            reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc               reorder_ket(dim-1) = k 
!tempcc               if (.special_ket(k)[1]>0) then
!tempcc ! Case 2, k special
!tempcc                 bk1 = .special_ket(k)[1]
!tempcc                 bk2 = .special_ket(k)[2]
!tempcc                 if (bk2 == b2 AND bk1 /= b1) then
!tempcc                   do bj2 = 1,.n_bf
!tempcc                     fac = temp_ket_j(b1,bj2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                       .special_ket(k)[2] = bj2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res8 in special_overlap_ab",res
!tempcc !debug
!tempcc                     end
!tempcc                   end
!tempcc                   .special_ket(k)[2] = bk2
!tempcc                 else if (bk2 /= b2 AND bk1 == b1) then   
!tempcc                   do bj1 = 1,.n_bf
!tempcc                     fac = temp_ket_j(bj1,b2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                       .special_ket(k)[1] = bj1 
!tempcc                    !  .special_ket(k)[2] = bk2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res7 in special_overlap_ab",res
!tempcc !debug
!tempcc                     end
!tempcc                   end
!tempcc                   .special_ket(k)[1] = bk1
!tempcc                 else if (bk2 == b2 AND bk1 == b1) then   
!tempcc                   do bj1 = 1,b1-1
!tempcc                     fac = temp_ket_j(bj1,b2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                       .special_ket(k)[1] = bj1 
!tempcc                    !  .special_ket(k)[2] = bk2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res6 in special_overlap_ab",res
!tempcc !debug
!tempcc                     end
!tempcc                   end
!tempcc                   do bj1 = b1+1,.n_bf
!tempcc                     fac = temp_ket_j(bj1,b2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                       .special_ket(k)[1] = bj1 
!tempcc                    !  .special_ket(k)[2] = bk2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res5 in special_overlap_ab",res
!tempcc !debug
!tempcc                     end
!tempcc                   end
!tempcc                   .special_ket(k)[1] = bk1
!tempcc                   do bj2 = 1,b2-1
!tempcc                     fac = temp_ket_j(b1,bj2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                       .special_ket(k)[2] = bj2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res4 in special_overlap_ab",res
!tempcc !debug
!tempcc                     end
!tempcc                   end
!tempcc                   do bj2 = b2+1,.n_bf
!tempcc                     fac = temp_ket_j(b1,bj2)
!tempcc                     if (NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                       .special_ket(k)[2] = bj2
!tempcc                       res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res3 in special_overlap_ab",res
!tempcc !debug
!tempcc                     end
!tempcc                   end
!tempcc                   .special_ket(k)[2] = bk2
!tempcc                   fac = TWO*temp_ket_j(b1,b2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                   !   .special_ket(k)[1] = bk1 
!tempcc                   !   .special_ket(k)[2] = bk2 
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res2 in special_overlap_ab",res
!tempcc !debug
!tempcc                   end
!tempcc                 end !else if (bk2 == b2 AND bk1 == b1)
!tempcc               else !  Case 2, NONE SPECIAL
!tempcc                 temp_ket_k => .ket(k)[:,:]
!tempcc                 do bj2 = 1,.n_bf
!tempcc                 do bk1 = 1,.n_bf
!tempcc                   fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
!tempcc                   if (NOT fac.is_zero(.tol)) then
!tempcc                     .special_ket(k)[1] = bk1 
!tempcc                     .special_ket(k)[2] = bj2
!tempcc                     res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc !debug
!tempcc !debug write(*,*)"res1 in special_overlap_ab",res
!tempcc !debug
!tempcc                   end 
!tempcc                 end
!tempcc                 end
!tempcc                 .special_ket(k)[1] = 0 
!tempcc                 .special_ket(k)[2] = 0
!tempcc               end ! if k special
!tempcc             end !do kk
!tempcc           end! if j special
!tempcc        end !do jj
!tempcc        reorder_ket.destroy
!tempcc      end ! q special ket and dim>1
!tempcc !debug
!tempcc !debug write(*,*)"res in special_overlap_ab",res
!tempcc !debug
!tempcc    end
!tempcc 
!tempcc    special_overlap_spin_bb_for(order_bra,order_ket,b1,b2) result (res)
!tempcc    ! Special function which evaluates the overlap integrals between
!tempcc    ! mean field (Sz=0)-geminals except .special_ket(order_ket(dim)) and the corresponding
!tempcc    ! special bra which are (Sz=-1)-geminals.
!tempcc !comments: should not be called if dim=1 because row_ind and col_ind would
!tempcc ! be already defined.
!tempcc 
!tempcc      b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(order_ket.dim>1,"dimension less than two")
!tempcc      ENSURE(.special_ket(1)[2]==0,"ket already set for contr 1")
!tempcc      ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no ket")
!tempcc      col_ind :: INT
!tempcc      dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      res = ZERO
!tempcc       
!tempcc      ! test for identical spinorbitals
!tempcc      b3 = .special_ket(q)[1]
!tempcc      b4 = .special_ket(q)[2]
!tempcc      if (b3==b4 OR b1==b2 ) return
!tempcc       
!tempcc      if(dim==1) then ! only Case 0
!tempcc        if (b3==b1 AND b4==b2 ) res = ONE
!tempcc        if (b3==b2 AND b4==b1 ) res = -ONE
!tempcc        return
!tempcc      else !dim>1
!tempcc        reorder_ket.create(dim-1)
!tempcc ! Case 0
!tempcc        reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
!tempcc        if (b3==b1 AND b4==b2 ) then
!tempcc          res = res + .overlap_for(order_bra,reorder_ket) 
!tempcc        else if (b3==b2 AND b4==b1 ) then
!tempcc          res = res - .overlap_for(order_bra,reorder_ket)
!tempcc        end
!tempcc        do jj = dim-1,1,-1
!tempcc          j = order_ket(jj)
!tempcc          reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc          reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
!tempcc          if (.special_ket(j)[1]>0) then  !j special
!tempcc            DIE_IF(j==1,"1 special") 
!tempcc            bj1 = .special_ket(j)[1]
!tempcc            bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc            if (bj2==b1 AND b4==b2 ) then
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b3
!tempcc              res = res - .overlap_for(order_bra,reorder_ket) 
!tempcc            else if (bj2==b2 AND b4==b1 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b3
!tempcc              res = res + .overlap_for(order_bra,reorder_ket) 
!tempcc            else if (bj2==b1 AND b3==b2 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b4
!tempcc              res = res + .overlap_for(order_bra,reorder_ket) 
!tempcc            else if (bj2==b2 AND b3==b1 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b4
!tempcc              res = res - .overlap_for(order_bra,reorder_ket) 
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc              bk1 = .special_ket(k)[1]
!tempcc              bk2 = .special_ket(k)[2]
!tempcc !3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (bj2==b1 AND bk2==b2 ) then
!tempcc                .special_ket(k)[1]=bj1
!tempcc                .special_ket(k)[2]=b3
!tempcc                .special_ket(q)[1]=bk1
!tempcc                .special_ket(q)[2]=b4
!tempcc                res = res + .overlap_for(order_bra,reorder_ket) 
!tempcc              else if (bj2==b2 AND bk2==b1 ) then
!tempcc                .special_ket(k)[1]=bj1
!tempcc                .special_ket(k)[2]=b3
!tempcc                .special_ket(q)[1]=bk1
!tempcc                .special_ket(q)[2]=b4
!tempcc                res = res - .overlap_for(order_bra,reorder_ket) 
!tempcc              end
!tempcc              .special_ket(k)[1]=bk1
!tempcc              .special_ket(k)[2]=bk2
!tempcc            end ! do kk 
!tempcc          else !j not special  
!tempcc            if(j==1)then
!tempcc              do col_ind=1,.n_bas
!tempcc !3-04-05               reorder_ket(1:jj-1)   = [ (order_ket(i), i=1,jj-1) ]
!tempcc                reorder_ket(jj:dim-1) = [ (order_ket(i), i=jj+1,dim) ] !reorder(dim-1)=q
!tempcc                temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc     ! Case 1
!tempcc                if (b4==b2 ) then
!tempcc                  do bj1=1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=bj1
!tempcc                      .special_ket(q)[2]=b3
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(order_bra,reorder_ket,col_ind)*fac
!tempcc                    end
!tempcc                  end
!tempcc                else if (b4==b1 ) then        
!tempcc                  do bj1=1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=bj1
!tempcc                      .special_ket(q)[2]=b3
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                if (b3==b2 ) then        
!tempcc                  do bj1=1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=bj1
!tempcc                      .special_ket(q)[2]=b4
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                else if (b3==b1 ) then        
!tempcc                  do bj1=1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=bj1
!tempcc                      .special_ket(q)[2]=b4
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc ! Case 2
!tempcc                do kk = dim-1,jj+1,-1
!tempcc                  k = order_ket(kk)
!tempcc !3-04-05                 reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc                  reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                  reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc                  reorder_ket(dim-2) = k 
!tempcc                  reorder_ket(dim-1) = q 
!tempcc                  if (.special_ket(k)[1]>0) then ! Case 2, k special
!tempcc                    bk1 = .special_ket(k)[1]
!tempcc                    bk2 = .special_ket(k)[2]
!tempcc                    if (bk2==b2 ) then
!tempcc                      .special_ket(k)[2]=b3
!tempcc                      .special_ket(q)[1]=bk1
!tempcc                      .special_ket(q)[2]=b4
!tempcc                      do bj1=1,.n_bf
!tempcc                        fac = temp_ket_j(bj1,b1)
!tempcc                        if (NOT fac.is_zero(.tol)) then
!tempcc                          .special_ket(k)[1]=bj1
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                        end
!tempcc                      end
!tempcc                    else if (bk2==b1 ) then
!tempcc                      .special_ket(k)[2]=b3
!tempcc                      .special_ket(q)[1]=bk1
!tempcc                      .special_ket(q)[2]=b4
!tempcc                      do bj1=1,.n_bf
!tempcc                        fac = temp_ket_j(bj1,b2)
!tempcc                        if (NOT fac.is_zero(.tol)) then
!tempcc                          .special_ket(k)[1]=bj1
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1]=bk1
!tempcc                    .special_ket(k)[2]=bk2
!tempcc                  else !k not special
!tempcc                    temp_ket_k => .ket(k)[:,:]
!tempcc                    .special_ket(k)[2]=b3
!tempcc                    .special_ket(q)[2]=b4
!tempcc                    do bj1 = 1,.n_bf
!tempcc                      .special_ket(k)[1]=bj1
!tempcc                      do bk1 = 1,.n_bf
!tempcc                        fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
!tempcc                        if (NOT fac.is_zero(.tol)) then
!tempcc                          .special_ket(q)[1]=bk1
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                        end 
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = 0 
!tempcc                    .special_ket(k)[2] = 0
!tempcc                  end !k special
!tempcc                end ! do kk 
!tempcc              end ! do col_ind
!tempcc            else ! j/=1
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc   ! Case 1
!tempcc              if (b4==b2 ) then
!tempcc                do bj1=1,.n_bf
!tempcc                  fac = temp_ket_j(bj1,b1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(q)[1]=bj1
!tempcc                    .special_ket(q)[2]=b3
!tempcc                    res = res - .overlap_for(order_bra,reorder_ket)*fac
!tempcc                  end
!tempcc                end
!tempcc              else if (b4==b1 ) then        
!tempcc                do bj1=1,.n_bf
!tempcc                  fac = temp_ket_j(bj1,b2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(q)[1]=bj1
!tempcc                    .special_ket(q)[2]=b3
!tempcc                    res = res + .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                  end
!tempcc                end
!tempcc              end
!tempcc              if (b3==b2 ) then        
!tempcc                do bj1=1,.n_bf
!tempcc                  fac = temp_ket_j(bj1,b1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(q)[1]=bj1
!tempcc                    .special_ket(q)[2]=b4
!tempcc                    res = res + .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                  end
!tempcc                end
!tempcc              else if (b3==b1 ) then        
!tempcc                do bj1=1,.n_bf
!tempcc                  fac = temp_ket_j(bj1,b2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(q)[1]=bj1
!tempcc                    .special_ket(q)[2]=b4
!tempcc                    res = res - .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                  end
!tempcc                end
!tempcc              end
!tempcc ! Case 2
!tempcc              do kk = dim-1,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc !3-04-05               reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc                reorder_ket(dim-2) = k 
!tempcc                reorder_ket(dim-1) = q 
!tempcc                if (.special_ket(k)[1]>0) then ! Case 2, k special
!tempcc                  bk1 = .special_ket(k)[1]
!tempcc                  bk2 = .special_ket(k)[2]
!tempcc                  if (bk2==b2 ) then
!tempcc                    .special_ket(k)[2]=b3
!tempcc                    .special_ket(q)[1]=bk1
!tempcc                    .special_ket(q)[2]=b4
!tempcc                    do bj1=1,.n_bf
!tempcc                      fac = temp_ket_j(bj1,b1)
!tempcc                      if (NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[1]=bj1
!tempcc                        res = res + .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                      end
!tempcc                    end
!tempcc                  else if (bk2==b1 ) then
!tempcc                    .special_ket(k)[2]=b3
!tempcc                    .special_ket(q)[1]=bk1
!tempcc                    .special_ket(q)[2]=b4
!tempcc                    do bj1=1,.n_bf
!tempcc                      fac = temp_ket_j(bj1,b2)
!tempcc                      if (NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[1]=bj1
!tempcc                        res = res - .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[1]=bk1
!tempcc                  .special_ket(k)[2]=bk2
!tempcc                else !k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc                  .special_ket(k)[2]=b3
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  do bj1 = 1,.n_bf
!tempcc                    .special_ket(k)[1]=bj1
!tempcc                    do bk1 = 1,.n_bf
!tempcc                      fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
!tempcc                      if (NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(q)[1]=bk1
!tempcc                        res = res + .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                      end 
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc                end !k special
!tempcc              end ! do kk 
!tempcc            end ! j==1
!tempcc          end !j special
!tempcc        end ! do jj 
!tempcc        .special_ket(q)[1]=b3
!tempcc        .special_ket(q)[2]=b4
!tempcc        reorder_ket.destroy
!tempcc      end !dim>1
!tempcc    end
!tempcc 
!tempcc    special_overlap_spin_bb_for(order_bra,order_ket,col_ind,b1,b2) result (res)
!tempcc    ! Special function which evaluates the overlap integrals column vector
!tempcc    ! specified by col_ind between mean field (Sz=0)-geminals except 
!tempcc    ! .special_ket(order_ket(dim)) and the corresponding special bra which are (Sz=-1)-geminals.
!tempcc !comments: should not be called if dim=1 because row_ind would be already defined.
!tempcc      col_ind,b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: VEC{REAL}(.n_bas)
!tempcc      ENSURE(order_ket.dim>1,"dimension less than two")
!tempcc      ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no ket")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      res = ZERO
!tempcc       
!tempcc      ! test for identical spinorbitals
!tempcc      b3 = .special_ket(q)[1]
!tempcc      b4 = .special_ket(q)[2]
!tempcc      if (b3==b4 OR b1==b2 ) return
!tempcc       
!tempcc      if(dim==1) then ! only Case 0
!tempcc        if (b3==b1 AND b4==b2 ) res = ONE
!tempcc        if (b3==b2 AND b4==b1 ) res = -ONE
!tempcc        return
!tempcc      else !dim>1
!tempcc        reorder_ket.create(dim-1)
!tempcc ! Case 0
!tempcc        reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
!tempcc        if (b3==b1 AND b4==b2 ) then
!tempcc          res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc        else if (b3==b2 AND b4==b1 ) then
!tempcc          res = res - .overlap_for(order_bra,reorder_ket,col_ind)
!tempcc        end
!tempcc        do jj = dim-1,1,-1
!tempcc          reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc          reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
!tempcc          j = order_ket(jj)
!tempcc          DIE_IF(j==1,"ket of contraction 1 has already appeared") 
!tempcc          if (.special_ket(j)[1]>0) then  !j special
!tempcc            bj1 = .special_ket(j)[1]
!tempcc            bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc            if (bj2==b1 AND b4==b2 ) then
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b3
!tempcc              res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc            else if (bj2==b2 AND b4==b1 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b3
!tempcc              res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc            else if (bj2==b1 AND b3==b2 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b4
!tempcc              res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc            else if (bj2==b2 AND b3==b1 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b4
!tempcc              res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc              bk1 = .special_ket(k)[1]
!tempcc              bk2 = .special_ket(k)[2]
!tempcc !3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (bj2==b1 AND bk2==b2 ) then
!tempcc                .special_ket(k)[1]=bj1
!tempcc                .special_ket(k)[2]=b3
!tempcc                .special_ket(q)[1]=bk1
!tempcc                .special_ket(q)[2]=b4
!tempcc                res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc              else if (bj2==b2 AND bk2==b1 ) then
!tempcc                .special_ket(k)[1]=bj1
!tempcc                .special_ket(k)[2]=b3
!tempcc                .special_ket(q)[1]=bk1
!tempcc                .special_ket(q)[2]=b4
!tempcc                res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc              end
!tempcc              .special_ket(k)[1]=bk1
!tempcc              .special_ket(k)[2]=bk2
!tempcc            end ! do kk 
!tempcc          else !j not special  
!tempcc            temp_ket_j => .ket(j)[:,:]
!tempcc ! Case 1
!tempcc            if (b4==b2 ) then
!tempcc              do bj1=1,.n_bf
!tempcc                fac = temp_ket_j(bj1,b1)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=bj1
!tempcc                  .special_ket(q)[2]=b3
!tempcc                  res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac
!tempcc                end
!tempcc              end
!tempcc            else if (b4==b1 ) then        
!tempcc              do bj1=1,.n_bf
!tempcc                fac = temp_ket_j(bj1,b2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=bj1
!tempcc                  .special_ket(q)[2]=b3
!tempcc                  res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc            if (b3==b2 ) then        
!tempcc              do bj1=1,.n_bf
!tempcc                fac = temp_ket_j(bj1,b1)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=bj1
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            else if (b3==b1 ) then        
!tempcc              do bj1=1,.n_bf
!tempcc                fac = temp_ket_j(bj1,b2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=bj1
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc !3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (.special_ket(k)[1]>0) then ! Case 2, k special
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                if (bk2==b2 ) then
!tempcc                  .special_ket(k)[2]=b3
!tempcc                  .special_ket(q)[1]=bk1
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  do bj1=1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1]=bj1
!tempcc                      res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                else if (bk2==b1 ) then
!tempcc                  .special_ket(k)[2]=b3
!tempcc                  .special_ket(q)[1]=bk1
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  do bj1=1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1]=bj1
!tempcc                      res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1]=bk1
!tempcc                .special_ket(k)[2]=bk2
!tempcc              else !k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc                .special_ket(k)[2]=b3
!tempcc                .special_ket(q)[2]=b4
!tempcc                do bj1 = 1,.n_bf
!tempcc                  .special_ket(k)[1]=bj1
!tempcc                  do bk1 = 1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=bk1
!tempcc                      res = res + .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                    end 
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc              end !k special
!tempcc            end ! do kk 
!tempcc          end !j special
!tempcc        end ! do jj 
!tempcc        .special_ket(q)[1]=b3
!tempcc        .special_ket(q)[2]=b4
!tempcc        reorder_ket.destroy
!tempcc      end !dim>1
!tempcc    end
!tempcc 
!tempcc    special_overlap_spin_bb_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res)
!tempcc    ! Special function which evaluates the overlap integrals between
!tempcc    ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
!tempcc    ! special bra which are (Sz=-1)-geminals.
!tempcc      row_ind,col_ind,b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: REAL
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no ket")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
!tempcc      dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      res = ZERO
!tempcc       
!tempcc      ! test for identical spinorbitals
!tempcc      b3 = .special_ket(q)[1]
!tempcc      b4 = .special_ket(q)[2]
!tempcc      if (b3==b4 OR b1==b2 ) return
!tempcc       
!tempcc      if(dim==1) then ! only Case 0
!tempcc        if (b3==b1 AND b4==b2 ) res = ONE
!tempcc        if (b3==b2 AND b4==b1 ) res = -ONE
!tempcc        return
!tempcc      else !dim>1
!tempcc        reorder_ket.create(dim-1)
!tempcc ! Case 0
!tempcc        reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
!tempcc        if (b3==b1 AND b4==b2 ) then
!tempcc          res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc        else if (b3==b2 AND b4==b1 ) then
!tempcc          res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)
!tempcc        end
!tempcc        do jj = dim-1,1,-1
!tempcc          reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc          reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
!tempcc          j = order_ket(jj)
!tempcc          if (.special_ket(j)[1]>0) then  !j special
!tempcc            DIE_IF(j==1,"1 special") 
!tempcc            bj1 = .special_ket(j)[1]
!tempcc            bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc            if (bj2==b1 AND b4==b2 ) then
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b3
!tempcc              res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc            else if (bj2==b2 AND b4==b1 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b3
!tempcc              res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc            else if (bj2==b1 AND b3==b2 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b4
!tempcc              res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc            else if (bj2==b2 AND b3==b1 ) then        
!tempcc              .special_ket(q)[1]=bj1
!tempcc              .special_ket(q)[2]=b4
!tempcc              res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc              bk1 = .special_ket(k)[1]
!tempcc              bk2 = .special_ket(k)[2]
!tempcc !3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (bj2==b1 AND bk2==b2 ) then
!tempcc                .special_ket(k)[1]=bj1
!tempcc                .special_ket(k)[2]=b3
!tempcc                .special_ket(q)[1]=bk1
!tempcc                .special_ket(q)[2]=b4
!tempcc                res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc              else if (bj2==b2 AND bk2==b1 ) then
!tempcc                .special_ket(k)[1]=bj1
!tempcc                .special_ket(k)[2]=b3
!tempcc                .special_ket(q)[1]=bk1
!tempcc                .special_ket(q)[2]=b4
!tempcc                res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc              end
!tempcc              .special_ket(k)[1]=bk1
!tempcc              .special_ket(k)[2]=bk2
!tempcc            end ! do kk 
!tempcc          else !j not special  
!tempcc            if(j==1)then
!tempcc              temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc            else
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc            end
!tempcc ! Case 1
!tempcc            if (b4==b2 ) then
!tempcc              do bj1=1,.n_bf
!tempcc                fac = temp_ket_j(bj1,b1)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=bj1
!tempcc                  .special_ket(q)[2]=b3
!tempcc                  res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac
!tempcc                end
!tempcc              end
!tempcc            else if (b4==b1 ) then        
!tempcc              do bj1=1,.n_bf
!tempcc                fac = temp_ket_j(bj1,b2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=bj1
!tempcc                  .special_ket(q)[2]=b3
!tempcc                  res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc            if (b3==b2 ) then        
!tempcc              do bj1=1,.n_bf
!tempcc                fac = temp_ket_j(bj1,b1)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=bj1
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            else if (b3==b1 ) then        
!tempcc              do bj1=1,.n_bf
!tempcc                fac = temp_ket_j(bj1,b2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=bj1
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc !3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (.special_ket(k)[1]>0) then ! Case 2, k special
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                if (bk2==b2 ) then
!tempcc                  .special_ket(k)[2]=b3
!tempcc                  .special_ket(q)[1]=bk1
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  do bj1=1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1]=bj1
!tempcc                      res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                else if (bk2==b1 ) then
!tempcc                  .special_ket(k)[2]=b3
!tempcc                  .special_ket(q)[1]=bk1
!tempcc                  .special_ket(q)[2]=b4
!tempcc                  do bj1=1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1]=bj1
!tempcc                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1]=bk1
!tempcc                .special_ket(k)[2]=bk2
!tempcc              else !k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc                .special_ket(k)[2]=b3
!tempcc                .special_ket(q)[2]=b4
!tempcc                do bj1 = 1,.n_bf
!tempcc                  .special_ket(k)[1]=bj1
!tempcc                  do bk1 = 1,.n_bf
!tempcc                    fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=bk1
!tempcc                      res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    end 
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc              end !k special
!tempcc            end ! do kk 
!tempcc          end !j special
!tempcc        end ! do jj 
!tempcc        .special_ket(q)[1]=b3
!tempcc        .special_ket(q)[2]=b4
!tempcc        reorder_ket.destroy
!tempcc      end !dim>1
!tempcc    end
!tempcc 
!tempcc    special_overlap_spin_aa_for(order_bra,order_ket,b1,b2) result (res)
!tempcc    ! Special function which evaluates the overlap integrals between
!tempcc    ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
!tempcc    ! special bra which are (Sz=-1)-geminals.
!tempcc !comments: should not be called if dim=1 because row_ind and col_ind would
!tempcc ! be already defined.
!tempcc      b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(order_ket.dim>1,"dimension less than two")
!tempcc      ENSURE(.special_ket(1)[2]==0,"ket already set for contr 1")
!tempcc      ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no ket")
!tempcc      col_ind :: INT
!tempcc      dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      res = ZERO
!tempcc       
!tempcc ! test for identical spinorbitals
!tempcc      b3 = .special_ket(q)[1]
!tempcc      b4 = .special_ket(q)[2]
!tempcc      if (b3==b4 OR b1==b2 ) return
!tempcc       
!tempcc      if(dim==1) then ! only Case 0
!tempcc        if (b3==b1 AND b4==b2 ) res = ONE
!tempcc        if (b3==b2 AND b4==b1 ) res = -ONE
!tempcc        return
!tempcc      else !dim>1
!tempcc        reorder_ket.create(dim-1)
!tempcc ! Case 0
!tempcc        reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
!tempcc        if (b3==b1 AND b4==b2 ) then
!tempcc          res = res + .overlap_for(order_bra,reorder_ket) 
!tempcc        else if (b3==b2 AND b4==b1 ) then
!tempcc          res = res - .overlap_for(order_bra,reorder_ket)
!tempcc        end
!tempcc        do jj = dim-1,1,-1
!tempcc          j = order_ket(jj)
!tempcc          reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc          reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
!tempcc          if (.special_ket(j)[1]>0) then  !j special
!tempcc            DIE_IF(j==1,"1 special") 
!tempcc            bj1 = .special_ket(j)[1]
!tempcc            bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc            if (bj1==b1 AND b4==b2 ) then
!tempcc              .special_ket(q)[1]=b3
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res - .overlap_for(order_bra,reorder_ket) 
!tempcc            else if (bj1==b2 AND b4==b1 ) then        
!tempcc              .special_ket(q)[1]=b3
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res + .overlap_for(order_bra,reorder_ket) 
!tempcc            else if (bj1==b1 AND b3==b2 ) then        
!tempcc              .special_ket(q)[1]=b4
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res + .overlap_for(order_bra,reorder_ket) 
!tempcc            else if (bj1==b2 AND b3==b1 ) then        
!tempcc              .special_ket(q)[1]=b4
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res - .overlap_for(order_bra,reorder_ket) 
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc              bk1 = .special_ket(k)[1]
!tempcc              bk2 = .special_ket(k)[2]
!tempcc !3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (bj1==b1 AND bk1==b2 ) then
!tempcc                .special_ket(k)[1]=b3
!tempcc                .special_ket(k)[2]=bj2
!tempcc                .special_ket(q)[1]=b4
!tempcc                .special_ket(q)[2]=bk2
!tempcc                res = res + .overlap_for(order_bra,reorder_ket) 
!tempcc              else if (bj1==b2 AND bk1==b1 ) then
!tempcc                .special_ket(k)[1]=b3
!tempcc                .special_ket(k)[2]=bj2
!tempcc                .special_ket(q)[1]=b4
!tempcc                .special_ket(q)[2]=bk2
!tempcc                res = res - .overlap_for(order_bra,reorder_ket) 
!tempcc              end
!tempcc              .special_ket(k)[1]=bk1
!tempcc              .special_ket(k)[2]=bk2
!tempcc            end ! do kk 
!tempcc          else !j not special  
!tempcc            if(j==1)then
!tempcc              do col_ind =1,.n_bas
!tempcc !3-04-05               reorder_ket(1:jj-1)   = [ (order_ket(i), i=1,jj-1) ]
!tempcc                reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
!tempcc                temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc                if (b4==b2 ) then
!tempcc                  do bj2=1,.n_bf
!tempcc                    fac = temp_ket_j(b1,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=b3
!tempcc                      .special_ket(q)[2]=bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(order_bra,reorder_ket,col_ind)*fac
!tempcc                    end
!tempcc                  end
!tempcc                else if (b4==b1 ) then        
!tempcc                  do bj2=1,.n_bf
!tempcc                    fac = temp_ket_j(b2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=b3
!tempcc                      .special_ket(q)[2]=bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                if (b3==b2 ) then        
!tempcc                  do bj2=1,.n_bf
!tempcc                    fac = temp_ket_j(b1,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=b4
!tempcc                      .special_ket(q)[2]=bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                else if (b3==b1 ) then        
!tempcc                  do bj2=1,.n_bf
!tempcc                    fac = temp_ket_j(b2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[1]=b4
!tempcc                      .special_ket(q)[2]=bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc     ! Case 2
!tempcc                do kk = dim-1,jj+1,-1
!tempcc                  k = order_ket(kk)
!tempcc !3-04-05                 reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc                  reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                  reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc                  reorder_ket(dim-2) = k 
!tempcc                  reorder_ket(dim-1) = q 
!tempcc                  if (.special_ket(k)[1]>0) then ! Case 2, k special
!tempcc                    bk1 = .special_ket(k)[1]
!tempcc                    bk2 = .special_ket(k)[2]
!tempcc                    if (bk1==b2 ) then
!tempcc                      .special_ket(k)[1]=b3
!tempcc                      .special_ket(q)[1]=b4
!tempcc                      .special_ket(q)[2]=bk2
!tempcc                      do bj2=1,.n_bf
!tempcc                        fac = temp_ket_j(b1,bj2)
!tempcc                        if (NOT fac.is_zero(.tol)) then
!tempcc                          .special_ket(k)[2]=bj2
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                        end
!tempcc                      end
!tempcc                    else if (bk1==b1 ) then
!tempcc                      .special_ket(k)[1]=b3
!tempcc                      .special_ket(q)[1]=b4
!tempcc                      .special_ket(q)[2]=bk2
!tempcc                      do bj2=1,.n_bf
!tempcc                        fac = temp_ket_j(b2,bj2)
!tempcc                        if (NOT fac.is_zero(.tol)) then
!tempcc                          .special_ket(k)[2]=bj2
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                        end
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1]=bk1
!tempcc                    .special_ket(k)[2]=bk2
!tempcc                  else !k not special
!tempcc                    temp_ket_k => .ket(k)[:,:]
!tempcc                    .special_ket(k)[1]=b3
!tempcc                    .special_ket(q)[1]=b4
!tempcc                    do bj2 = 1,.n_bf
!tempcc                      .special_ket(k)[2]=bj2
!tempcc                      do bk2 = 1,.n_bf
!tempcc                        fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
!tempcc                        if (NOT fac.is_zero(.tol)) then
!tempcc                          .special_ket(q)[2]=bk2
!tempcc                          res(:,col_ind) = res(:,col_ind) &
!tempcc                          + .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                        end 
!tempcc                      end
!tempcc                    end
!tempcc                    .special_ket(k)[1] = 0 
!tempcc                    .special_ket(k)[2] = 0
!tempcc                  end !k special
!tempcc                end ! do kk 
!tempcc              end ! do  col_ind
!tempcc            else ! j/=1
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc              if (b4==b2 ) then
!tempcc                do bj2=1,.n_bf
!tempcc                  fac = temp_ket_j(b1,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(q)[1]=b3
!tempcc                    .special_ket(q)[2]=bj2
!tempcc                    res = res - .overlap_for(order_bra,reorder_ket)*fac
!tempcc                  end
!tempcc                end
!tempcc              else if (b4==b1 ) then        
!tempcc                do bj2=1,.n_bf
!tempcc                  fac = temp_ket_j(b2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(q)[1]=b3
!tempcc                    .special_ket(q)[2]=bj2
!tempcc                    res = res + .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                  end
!tempcc                end
!tempcc              end
!tempcc              if (b3==b2 ) then        
!tempcc                do bj2=1,.n_bf
!tempcc                  fac = temp_ket_j(b1,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(q)[1]=b4
!tempcc                    .special_ket(q)[2]=bj2
!tempcc                    res = res + .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                  end
!tempcc                end
!tempcc              else if (b3==b1 ) then        
!tempcc                do bj2=1,.n_bf
!tempcc                  fac = temp_ket_j(b2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(q)[1]=b4
!tempcc                    .special_ket(q)[2]=bj2
!tempcc                    res = res - .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                  end
!tempcc                end
!tempcc              end
!tempcc ! Case 2
!tempcc              do kk = dim-1,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc !3-04-05               reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc                reorder_ket(dim-2) = k 
!tempcc                reorder_ket(dim-1) = q 
!tempcc                if (.special_ket(k)[1]>0) then ! Case 2, k special
!tempcc                  bk1 = .special_ket(k)[1]
!tempcc                  bk2 = .special_ket(k)[2]
!tempcc                  if (bk1==b2 ) then
!tempcc                    .special_ket(k)[1]=b3
!tempcc                    .special_ket(q)[1]=b4
!tempcc                    .special_ket(q)[2]=bk2
!tempcc                    do bj2=1,.n_bf
!tempcc                      fac = temp_ket_j(b1,bj2)
!tempcc                      if (NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[2]=bj2
!tempcc                        res = res + .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                      end
!tempcc                    end
!tempcc                  else if (bk1==b1 ) then
!tempcc                    .special_ket(k)[1]=b3
!tempcc                    .special_ket(q)[1]=b4
!tempcc                    .special_ket(q)[2]=bk2
!tempcc                    do bj2=1,.n_bf
!tempcc                      fac = temp_ket_j(b2,bj2)
!tempcc                      if (NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(k)[2]=bj2
!tempcc                        res = res - .overlap_for(order_bra,reorder_ket)*fac 
!tempcc                      end
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[1]=bk1
!tempcc                  .special_ket(k)[2]=bk2
!tempcc                else !k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc                  .special_ket(k)[1]=b3
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  do bj2 = 1,.n_bf
!tempcc                    .special_ket(k)[2]=bj2
!tempcc                    do bk2 = 1,.n_bf
!tempcc                      fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
!tempcc                      if (NOT fac.is_zero(.tol)) then
!tempcc                        .special_ket(q)[2]=bk2
!tempcc                        res = res + .overlap_for(order_bra,reorder_ket) * fac ! <<
!tempcc                      end 
!tempcc                    end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc                end !k special
!tempcc              end ! do kk 
!tempcc            end !j==1
!tempcc          end !j special
!tempcc        end ! do jj 
!tempcc        .special_ket(q)[1]=b3
!tempcc        .special_ket(q)[2]=b4
!tempcc        reorder_ket.destroy
!tempcc      end !dim>1
!tempcc    end
!tempcc 
!tempcc    special_overlap_spin_aa_for(order_bra,order_ket,col_ind,b1,b2) result (res)
!tempcc    ! Special function which evaluates the overlap integrals column vector
!tempcc    ! specified by col_ind between mean field (Sz=0)-geminals except 
!tempcc    ! .special_ket(order_ket(dim)) and the corresponding special bra which are (Sz=1)-geminals.
!tempcc !comments: should not be called if dim=1 because row_ind would be already defined.
!tempcc      col_ind,b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: VEC{REAL}(.n_bas)
!tempcc      ENSURE(order_ket.dim>1,"dimension less than two")
!tempcc      ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no ket")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      res = ZERO
!tempcc       
!tempcc ! test for identical spinorbitals
!tempcc      b3 = .special_ket(q)[1]
!tempcc      b4 = .special_ket(q)[2]
!tempcc      if (b3==b4 OR b1==b2 ) return
!tempcc       
!tempcc      if(dim==1) then ! only Case 0
!tempcc        if (b3==b1 AND b4==b2 ) res = ONE
!tempcc        if (b3==b2 AND b4==b1 ) res = -ONE
!tempcc        return
!tempcc      else !dim>1
!tempcc        reorder_ket.create(dim-1)
!tempcc ! Case 0
!tempcc        reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
!tempcc        if (b3==b1 AND b4==b2 ) then
!tempcc          res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc        else if (b3==b2 AND b4==b1 ) then
!tempcc          res = res - .overlap_for(order_bra,reorder_ket,col_ind)
!tempcc        end
!tempcc        do jj = dim-1,1,-1
!tempcc          reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc          reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
!tempcc          j = order_ket(jj)
!tempcc          DIE_IF(j==1,"ket for contraction 1 has already appeared") 
!tempcc          if (.special_ket(j)[1]>0) then  !j special
!tempcc            bj1 = .special_ket(j)[1]
!tempcc            bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc            if (bj1==b1 AND b4==b2 ) then
!tempcc              .special_ket(q)[1]=b3
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc            else if (bj1==b2 AND b4==b1 ) then        
!tempcc              .special_ket(q)[1]=b3
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc            else if (bj1==b1 AND b3==b2 ) then        
!tempcc              .special_ket(q)[1]=b4
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc            else if (bj1==b2 AND b3==b1 ) then        
!tempcc              .special_ket(q)[1]=b4
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc              bk1 = .special_ket(k)[1]
!tempcc              bk2 = .special_ket(k)[2]
!tempcc       !       reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (bj1==b1 AND bk1==b2 ) then
!tempcc                .special_ket(k)[1]=b3
!tempcc                .special_ket(k)[2]=bj2
!tempcc                .special_ket(q)[1]=b4
!tempcc                .special_ket(q)[2]=bk2
!tempcc                res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc              else if (bj1==b2 AND bk1==b1 ) then
!tempcc                .special_ket(k)[1]=b3
!tempcc                .special_ket(k)[2]=bj2
!tempcc                .special_ket(q)[1]=b4
!tempcc                .special_ket(q)[2]=bk2
!tempcc                res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
!tempcc              end
!tempcc              .special_ket(k)[1]=bk1
!tempcc              .special_ket(k)[2]=bk2
!tempcc            end ! do kk 
!tempcc          else !j not special  
!tempcc            temp_ket_j => .ket(j)[:,:]
!tempcc            if (b4==b2 ) then
!tempcc              do bj2=1,.n_bf
!tempcc                fac = temp_ket_j(b1,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=b3
!tempcc                  .special_ket(q)[2]=bj2
!tempcc                  res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac
!tempcc                end
!tempcc              end
!tempcc            else if (b4==b1 ) then        
!tempcc              do bj2=1,.n_bf
!tempcc                fac = temp_ket_j(b2,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=b3
!tempcc                  .special_ket(q)[2]=bj2
!tempcc                  res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc            if (b3==b2 ) then        
!tempcc              do bj2=1,.n_bf
!tempcc                fac = temp_ket_j(b1,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  .special_ket(q)[2]=bj2
!tempcc                  res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            else if (b3==b1 ) then        
!tempcc              do bj2=1,.n_bf
!tempcc                fac = temp_ket_j(b2,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  .special_ket(q)[2]=bj2
!tempcc                  res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              !reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (.special_ket(k)[1]>0) then ! Case 2, k special
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                if (bk1==b2 ) then
!tempcc                  .special_ket(k)[1]=b3
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  .special_ket(q)[2]=bk2
!tempcc                  do bj2=1,.n_bf
!tempcc                    fac = temp_ket_j(b1,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[2]=bj2
!tempcc                      res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                else if (bk1==b1 ) then
!tempcc                  .special_ket(k)[1]=b3
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  .special_ket(q)[2]=bk2
!tempcc                  do bj2=1,.n_bf
!tempcc                    fac = temp_ket_j(b2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[2]=bj2
!tempcc                      res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1]=bk1
!tempcc                .special_ket(k)[2]=bk2
!tempcc              else !k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc                .special_ket(k)[1]=b3
!tempcc                .special_ket(q)[1]=b4
!tempcc                do bj2 = 1,.n_bf
!tempcc                  .special_ket(k)[2]=bj2
!tempcc                  do bk2 = 1,.n_bf
!tempcc                    fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[2]=bk2
!tempcc                      res = res + .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
!tempcc                    end 
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc              end !k special
!tempcc            end ! do kk 
!tempcc          end !j special
!tempcc        end ! do jj 
!tempcc        .special_ket(q)[1]=b3
!tempcc        .special_ket(q)[2]=b4
!tempcc        reorder_ket.destroy
!tempcc      end !dim>1
!tempcc    end
!tempcc 
!tempcc    special_overlap_spin_aa_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res)
!tempcc    ! Special function which evaluates the overlap integrals between
!tempcc    ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
!tempcc    ! special bra which are (Sz=-1)-geminals.
!tempcc      row_ind,col_ind,b1,b2 :: INT, IN
!tempcc      order_bra, order_ket :: VEC{INT}, IN
!tempcc      res :: REAL
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no ket")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
!tempcc      dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      q=order_ket(dim)
!tempcc      res = ZERO
!tempcc       
!tempcc ! test for identical spinorbitals
!tempcc      b3 = .special_ket(q)[1]
!tempcc      b4 = .special_ket(q)[2]
!tempcc      if (b3==b4 OR b1==b2 ) return
!tempcc       
!tempcc      if(dim==1) then ! only Case 0
!tempcc        if (b3==b1 AND b4==b2 ) res = ONE
!tempcc        if (b3==b2 AND b4==b1 ) res = -ONE
!tempcc        return
!tempcc      else !dim>1
!tempcc        reorder_ket.create(dim-1)
!tempcc ! Case 0
!tempcc        reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
!tempcc        if (b3==b1 AND b4==b2 ) then
!tempcc          res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc        else if (b3==b2 AND b4==b1 ) then
!tempcc          res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)
!tempcc        end
!tempcc        do jj = dim-1,1,-1
!tempcc          reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc          reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
!tempcc          j = order_ket(jj)
!tempcc          if (.special_ket(j)[1]>0) then  !j special
!tempcc            DIE_IF(j==1,"1 special") 
!tempcc            bj1 = .special_ket(j)[1]
!tempcc            bj2 = .special_ket(j)[2]
!tempcc ! The simple case 1
!tempcc            if (bj1==b1 AND b4==b2 ) then
!tempcc              .special_ket(q)[1]=b3
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc            else if (bj1==b2 AND b4==b1 ) then        
!tempcc              .special_ket(q)[1]=b3
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc            else if (bj1==b1 AND b3==b2 ) then        
!tempcc              .special_ket(q)[1]=b4
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc            else if (bj1==b2 AND b3==b1 ) then        
!tempcc              .special_ket(q)[1]=b4
!tempcc              .special_ket(q)[2]=bj2
!tempcc              res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!tempcc              bk1 = .special_ket(k)[1]
!tempcc              bk2 = .special_ket(k)[2]
!tempcc      !        reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (bj1==b1 AND bk1==b2 ) then
!tempcc                .special_ket(k)[1]=b3
!tempcc                .special_ket(k)[2]=bj2
!tempcc                .special_ket(q)[1]=b4
!tempcc                .special_ket(q)[2]=bk2
!tempcc                res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc              else if (bj1==b2 AND bk1==b1 ) then
!tempcc                .special_ket(k)[1]=b3
!tempcc                .special_ket(k)[2]=bj2
!tempcc                .special_ket(q)[1]=b4
!tempcc                .special_ket(q)[2]=bk2
!tempcc                res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
!tempcc              end
!tempcc              .special_ket(k)[1]=bk1
!tempcc              .special_ket(k)[2]=bk2
!tempcc            end ! do kk 
!tempcc          else !j not special  
!tempcc            if(j==1)then
!tempcc              temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc            else
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc            end
!tempcc            if (b4==b2 ) then
!tempcc              do bj2=1,.n_bf
!tempcc                fac = temp_ket_j(b1,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=b3
!tempcc                  .special_ket(q)[2]=bj2
!tempcc                  res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac
!tempcc                end
!tempcc              end
!tempcc            else if (b4==b1 ) then        
!tempcc              do bj2=1,.n_bf
!tempcc                fac = temp_ket_j(b2,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=b3
!tempcc                  .special_ket(q)[2]=bj2
!tempcc                  res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc            if (b3==b2 ) then        
!tempcc              do bj2=1,.n_bf
!tempcc                fac = temp_ket_j(b1,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  .special_ket(q)[2]=bj2
!tempcc                  res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            else if (b3==b1 ) then        
!tempcc              do bj2=1,.n_bf
!tempcc                fac = temp_ket_j(b2,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  .special_ket(q)[2]=bj2
!tempcc                  res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                end
!tempcc              end
!tempcc            end
!tempcc ! Case 2
!tempcc            do kk = dim-1,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              !reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
!tempcc              reorder_ket(dim-2) = k 
!tempcc              reorder_ket(dim-1) = q 
!tempcc              if (.special_ket(k)[1]>0) then ! Case 2, k special
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                if (bk1==b2 ) then
!tempcc                  .special_ket(k)[1]=b3
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  .special_ket(q)[2]=bk2
!tempcc                  do bj2=1,.n_bf
!tempcc                    fac = temp_ket_j(b1,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[2]=bj2
!tempcc                      res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                else if (bk1==b1 ) then
!tempcc                  .special_ket(k)[1]=b3
!tempcc                  .special_ket(q)[1]=b4
!tempcc                  .special_ket(q)[2]=bk2
!tempcc                  do bj2=1,.n_bf
!tempcc                    fac = temp_ket_j(b2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[2]=bj2
!tempcc                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
!tempcc                    end
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1]=bk1
!tempcc                .special_ket(k)[2]=bk2
!tempcc              else !k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc                .special_ket(k)[1]=b3
!tempcc                .special_ket(q)[1]=b4
!tempcc                do bj2 = 1,.n_bf
!tempcc                  .special_ket(k)[2]=bj2
!tempcc                  do bk2 = 1,.n_bf
!tempcc                    fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(q)[2]=bk2
!tempcc                      res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    end 
!tempcc                  end
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc              end !k special
!tempcc            end ! do kk 
!tempcc          end !j special
!tempcc        end ! do jj 
!tempcc        .special_ket(q)[1]=b3
!tempcc        .special_ket(q)[2]=b4
!tempcc        reorder_ket.destroy
!tempcc      end !dim>1
!tempcc    end
!tempcc 
!tempcc    overlap result (res)
!tempcc    ! Evaluate the overlap matrix for a given geminal contraction
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
!tempcc      i,row_ind,col_ind :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      reorder_ket.create(.n_geminals)
!tempcc      reorder_ket = [ (i, i=1,.n_geminals) ]
!tempcc      res = .overlap_for(reorder_ket)
!tempcc !debug     stdout.text("after overlap_for ")
!tempcc !debug     do col_ind=1,.n_bas
!tempcc !debug     do row_ind=1,col_ind
!tempcc !debug       res(row_ind,col_ind)=.overlap_for(reorder_ket,row_ind,col_ind)
!tempcc !debug       reorder_ket = [ (i, i=1,.n_geminals) ]
!tempcc !debug     end
!tempcc !debug     end
!tempcc !debug     .put
!tempcc      do col_ind=2,.n_bas
!tempcc      do row_ind=1,col_ind-1
!tempcc        res(col_ind,row_ind)=res(row_ind,col_ind)
!tempcc      end
!tempcc      end
!tempcc      reorder_ket.destroy
!tempcc    end
!tempcc 
!tempcc    overlap_for(order_ket) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the overlap integrals matrix between
!tempcc    ! mean field (Sz=0)-geminals (upper triangle only is evaluated)
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if jj is a special ket,
!tempcc !than kk>jj is also a special ket.
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      ENSURE(.special_ket(1)[1]==0,".special_ket(1) already set")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      row_ind,col_ind :: INT
!tempcc      jj,j,kk,k,dim,bq1,bj1,bj2,bk1,bk2 :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      res = ZERO
!tempcc       
!tempcc !debug     stdout.text("before overlap_for ")
!tempcc !debug     .put
!tempcc !debug     stdout.show("dim=",dim)
!tempcc !debug     do l=1,dim
!tempcc !debug       stdout.show("l=",l)
!tempcc !debug       stdout.show("order_ket(l)=",order_ket(l))
!tempcc !debug     end
!tempcc      if (dim==1) then ! only Case 1
!tempcc        j = order_ket(1)
!tempcc        DIE_IF(j/=1,"dim is 1 but j is not 1")
!tempcc        do col_ind=1,.n_bas 
!tempcc          temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc          do row_ind=1,col_ind
!tempcc            fac = sum(.contraction_wfs(row_ind)[:,:]*temp_ket_j)
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res(row_ind,col_ind)=fac !permit to set to zero numbers below a threshold
!tempcc            end
!tempcc          end
!tempcc        end
!tempcc        nullify(temp_ket_j)
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        temp_bra_q => .bra(dim)[:,:]
!tempcc        reorder_ket.create(dim-1)
!tempcc        temp_qa_ja.create(.n_bf,.n_bf)
!tempcc        temp_qb_jb.create(.n_bf,.n_bf)
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc          if (j==1) then ! 1 not special
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do col_ind=1,.n_bas
!tempcc              temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc              do bj1=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc                temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc   ! Case 2
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                if (.special_ket(k)[1]>0) then ! k special
!tempcc                  bk1 = .special_ket(k)[1]
!tempcc                  bk2 = .special_ket(k)[2]
!tempcc                  do bj1 = 1,bk1-1
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1 = bk1+1,.n_bf
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = 1,bk2-1
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = bk2+1,.n_bf
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res(:,col_ind) = res(:,col_ind) &
!tempcc                    - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                  end
!tempcc                else ! k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc                  do bk2 = 1,.n_bf
!tempcc                  do bj1 = 1,.n_bf
!tempcc                    fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      res(:,col_ind) = res(:,col_ind) &
!tempcc                      - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc                  nullify(temp_ket_k)
!tempcc                end  ! if (.special_ket(k)
!tempcc              end !do kk
!tempcc   ! Case 1
!tempcc           !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_qb_jb.trace
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res(:,col_ind) = res(:,col_ind) &
!tempcc                + .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc              end
!tempcc            end !do col_ind
!tempcc            nullify(temp_ket_j)
!tempcc          else ! j>1 
!tempcc            if (.special_ket(j)[1]>0) then
!tempcc              bj1 = .special_ket(j)[1]
!tempcc              bj2 = .special_ket(j)[2]
!tempcc ! Case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc                DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!tempcc !debug              if(.special_ket(k)[1]==0) then
!tempcc !debug     write(*,*) "j special but not k"
!tempcc !debug     stdout.show("dim=",dim)
!tempcc !debug     do l=1,dim
!tempcc !debug       stdout.show("l=",l)
!tempcc !debug       stdout.show("order_ket(l)=",order_ket(l))
!tempcc !debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!tempcc !debug     end
!tempcc !debug     stop
!tempcc !debug     end
!tempcc !assume special_ket's are also ordered at the end in the initial guess
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                if(bj1/=bk1 OR bj2/=bk2) then
!tempcc                  fac=temp_bra_q(bk1,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                  fac=temp_bra_q(bj1,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                else ! bj1==bk1 AND bj2==bk2
!tempcc                  fac=TWO * temp_bra_q(bk1,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                  end
!tempcc                end ! bj1==bk1 AND bj2==bk2
!tempcc              end !do kk
!tempcc ! Case 1
!tempcc           !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_bra_q(bj1,bj2)
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_ket) * fac ! <<
!tempcc              end
!tempcc            else !j not special
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc              do bj1=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc                temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc ! Case 2
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                if (.special_ket(k)[1]>0) then ! k special
!tempcc                  bk1 = .special_ket(k)[1]
!tempcc                  bk2 = .special_ket(k)[2]
!tempcc                  do bj1 = 1,bk1-1
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1 = bk1+1,.n_bf
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = 1,bk2-1
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = bk2+1,.n_bf
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                  end
!tempcc                else ! k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc                  do bk2 = 1,.n_bf
!tempcc                  do bj1 = 1,.n_bf
!tempcc                    fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      res = res - .overlap_for(reorder_ket) * fac ! <<
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc                  nullify(temp_ket_k)
!tempcc                end  ! if (.special_ket(k)
!tempcc              end !do kk
!tempcc ! Case 1
!tempcc          !    reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_qb_jb.trace
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_ket) * fac ! <<
!tempcc              end
!tempcc              nullify(temp_ket_j)
!tempcc            end !j not special
!tempcc          end !if(j==1 AND .special_ket(1)==0) else
!tempcc        end  !do jj=dim,1,-1
!tempcc      temp_qa_ja.destroy
!tempcc      temp_qb_jb.destroy
!tempcc      reorder_ket.destroy
!tempcc      nullify(temp_bra_q)
!tempcc      end ! if(dim==1)
!tempcc      
!tempcc    end
!tempcc 
!tempcc    overlap_for(order_ket,col_ind) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the overlap integrals column
!tempcc    ! vector specified by col_ind between mean field (Sz=0)-geminals 
!tempcc    ! upper half only is evaluated.
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if jj is a special ket,
!tempcc !than kk>jj is also a special ket. 
!tempcc      col_ind :: INT, IN
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      res :: VEC{REAL}(.n_bas)
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      row_ind :: INT
!tempcc      jj,j,kk,k,dim,bq1,bj1,bj2,bk1,bk2 :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      res=ZERO
!tempcc 
!tempcc      if (dim==1) then ! only Case 1
!tempcc        j = order_ket(1)
!tempcc        DIE_IF(j==1,"ket of contraction 1 has already appeared")
!tempcc        if (.special_ket(j)[1]>0) then             
!tempcc          bj1 = .special_ket(j)[1]                 
!tempcc          bj2 = .special_ket(j)[2]                
!tempcc          do row_ind=1,col_ind
!tempcc            fac = .contraction_wfs(row_ind)[bj1,bj2]
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res(row_ind)=fac !permit to set to zero numbers below a threshold
!tempcc            end
!tempcc          end
!tempcc        else 
!tempcc          temp_ket_j => .ket(j)[:,:]
!tempcc          do row_ind=1,col_ind
!tempcc            fac = sum(.contraction_wfs(row_ind)[:,:]*temp_ket_j)
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res(row_ind)=fac !permit to set to zero numbers below a threshold
!tempcc            end
!tempcc          end
!tempcc          nullify(temp_ket_j)
!tempcc        end
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        temp_bra_q => .bra(dim)[:,:]
!tempcc        reorder_ket.create(dim-1)
!tempcc        temp_qa_ja.create(.n_bf,.n_bf)
!tempcc        temp_qb_jb.create(.n_bf,.n_bf)
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc          DIE_IF(j==1,"ket of contraction 1 has already appeared")
!tempcc          if (.special_ket(j)[1]>0) then
!tempcc            bj1 = .special_ket(j)[1]
!tempcc            bj2 = .special_ket(j)[2]
!tempcc ! Case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!tempcc !debug              if(.special_ket(k)[1]==0) then
!tempcc !debug     write(*,*) "j special but not k"
!tempcc !debug     stdout.show("dim=",dim)
!tempcc !debug     do l=1,dim
!tempcc !debug       stdout.show("l=",l)
!tempcc !debug       stdout.show("order_ket(l)=",order_ket(l))
!tempcc !debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!tempcc !debug     end
!tempcc !debug     stop
!tempcc !debug     end
!tempcc !assume special_ket's are also ordered at the end in the initial guess
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) = k 
!tempcc              bk1 = .special_ket(k)[1]
!tempcc              bk2 = .special_ket(k)[2]
!tempcc              if(bj1/=bk1 OR bj2/=bk2) then
!tempcc                fac=temp_bra_q(bk1,bj2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                  .special_ket(k)[1] = bj1
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                  .special_ket(k)[1] = bk1
!tempcc                end
!tempcc                fac=temp_bra_q(bj1,bk2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc               !  .special_ket(k)[1] = bk1
!tempcc                  .special_ket(k)[2] = bj2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                  .special_ket(k)[2] = bk2
!tempcc                end
!tempcc              else ! bj1==bk1 AND bj2==bk2
!tempcc                fac=TWO * temp_bra_q(bk1,bk2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc               !  .special_ket(k)[1] = bk1
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                end
!tempcc              end ! bj1==bk1 AND bj2==bk2
!tempcc            end !do kk
!tempcc ! Case 1
!tempcc          !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc            fac = temp_bra_q(bj1,bj2)
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc            end
!tempcc          else !j not special
!tempcc            temp_ket_j => .ket(j)[:,:]
!tempcc            do bj1=1,.n_bf
!tempcc            do bq1=1,.n_bf
!tempcc              temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc              temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc            end
!tempcc            end
!tempcc ! Case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) = k 
!tempcc              if (.special_ket(k)[1]>0) then ! k special
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                do bj1 = 1,bk1-1
!tempcc                  fac=temp_qb_jb(bk1,bj1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                    res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                end
!tempcc                do bj1 = bk1+1,.n_bf
!tempcc                  fac=temp_qb_jb(bk1,bj1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                    res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                end
!tempcc                do bj2 = 1,bk2-1
!tempcc                  fac=temp_qa_ja(bk2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                end
!tempcc                do bj2 = bk2+1,.n_bf
!tempcc                  fac=temp_qa_ja(bk2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                end
!tempcc                fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                ! .special_ket(k)[1] = bk1
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                end
!tempcc              else ! k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc                do bk2 = 1,.n_bf
!tempcc                do bj1 = 1,.n_bf
!tempcc                  fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc                  end
!tempcc                end
!tempcc                end
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc                nullify(temp_ket_k)
!tempcc              end  ! if (.special_ket(k)
!tempcc            end !do kk
!tempcc ! Case 1
!tempcc          !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc            fac = temp_qb_jb.trace
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
!tempcc            end
!tempcc            nullify(temp_ket_j)
!tempcc          end !j not special
!tempcc        end  !do jj=dim,1,-1
!tempcc      temp_qa_ja.destroy
!tempcc      temp_qb_jb.destroy
!tempcc      reorder_ket.destroy
!tempcc      nullify(temp_bra_q)
!tempcc      end ! if(dim==1)
!tempcc    end
!tempcc 
!tempcc    overlap_for(order_ket,row_ind,col_ind) result (res) ::: recursive
!tempcc    ! Standard recursive function which evaluates the overlap integrals matrix
!tempcc    ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!tempcc !comments:
!tempcc !special_ket are always created at the end so that if ii is a special ket,
!tempcc !than jj>ii is also a special ket. This allows some simplifications but may be a
!tempcc !bit limitative in the future.
!tempcc      row_ind, col_ind :: INT, IN
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      res :: REAL
!tempcc      ENSURE(.special_ket(1)[1]==0,"1 special")
!tempcc      ENSURE(order_ket.dim>0,"dim negative or zero")
!tempcc      ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
!tempcc      ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
!tempcc      jj,j,kk,k,dim,bq1,bj1,bj2,bk1,bk2 :: INT
!tempcc      reorder_ket :: VEC{INT}*
!tempcc      fac :: REAL
!tempcc      temp_bra_q :: MAT{REAL}*
!tempcc      temp_ket_j :: MAT{REAL}*
!tempcc      temp_ket_k :: MAT{REAL}*
!tempcc      temp_qa_ja :: MAT{REAL}*
!tempcc      temp_qb_jb :: MAT{REAL}*
!tempcc 
!tempcc      dim = order_ket.dim
!tempcc      res = ZERO
!tempcc 
!tempcc      if (dim==1) then ! Only Case 1
!tempcc        j = order_ket(1)
!tempcc        if (.special_ket(j)[1]>0) then             
!tempcc          bj1 = .special_ket(j)[1]                 
!tempcc          bj2 = .special_ket(j)[2]                
!tempcc          fac = .contraction_wfs(row_ind)[bj1,bj2]
!tempcc        else if(.special_ket(j)[1]==0 AND j==1) then
!tempcc          fac = sum(.contraction_wfs(row_ind)[:,:]*.contraction_wfs(col_ind)[:,:])
!tempcc        else if (.special_ket(j)[1]==0 AND j/=1) then
!tempcc          fac = sum(.contraction_wfs(row_ind)[:,:]*.ket(j)[:,:])
!tempcc        end
!tempcc        if (NOT fac.is_zero(.tol)) then
!tempcc           res = fac
!tempcc !debug       write(*,*)'coucou5',res
!tempcc        end
!tempcc        return
!tempcc      else ! dim > 1
!tempcc        temp_bra_q => .bra(dim)[:,:]
!tempcc        reorder_ket.create(dim-1)
!tempcc        temp_qa_ja.create(.n_bf,.n_bf)
!tempcc        temp_qb_jb.create(.n_bf,.n_bf)
!tempcc        do jj = dim,1,-1
!tempcc          j = order_ket(jj)
!tempcc !debug    write(*,*) 'jj,j',jj,j
!tempcc          if (j==1 AND .special_ket(1)[1]==0) then ! 1 not special
!tempcc            temp_ket_j => .contraction_wfs(col_ind)[:,:]
!tempcc            do bj1=1,.n_bf
!tempcc            do bq1=1,.n_bf
!tempcc              temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc              temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc            end
!tempcc            end
!tempcc ! Case 2
!tempcc            reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc            do kk = dim,jj+1,-1
!tempcc              k = order_ket(kk)
!tempcc !debug    write(*,*) 'kk,k',kk,k
!tempcc              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc              reorder_ket(dim-1) = k 
!tempcc              if (.special_ket(k)[1]>0) then ! k special
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                do bj1 = 1,bk1-1
!tempcc                  fac=temp_qb_jb(bk1,bj1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                end
!tempcc                do bj1 = bk1+1,.n_bf
!tempcc                  fac=temp_qb_jb(bk1,bj1)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                end
!tempcc                do bj2 = 1,bk2-1
!tempcc                  fac=temp_qa_ja(bk2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                end
!tempcc                do bj2 = bk2+1,.n_bf
!tempcc                  fac=temp_qa_ja(bk2,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                end
!tempcc                fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                if (NOT fac.is_zero(.tol)) then
!tempcc                ! .special_ket(k)[1] = bk1
!tempcc                ! .special_ket(k)[2] = bk2
!tempcc                  res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                end
!tempcc !debug                 write(*,*) 'case 2 kspecial',dim,res
!tempcc              else ! k not special
!tempcc                temp_ket_k => .ket(k)[:,:]
!tempcc                do bk2 = 1,.n_bf
!tempcc                do bj1 = 1,.n_bf
!tempcc                  fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1 
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                  end
!tempcc                end
!tempcc                end
!tempcc !debug           write(*,*) 'case 2 k not special',dim,res
!tempcc                .special_ket(k)[1] = 0 
!tempcc                .special_ket(k)[2] = 0
!tempcc                nullify(temp_ket_k)
!tempcc              end  ! if (.special_ket(k)
!tempcc            end !do kk
!tempcc ! Case 1
!tempcc         !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc            reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc            fac = temp_qb_jb.trace
!tempcc            if (NOT fac.is_zero(.tol)) then
!tempcc              res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc            end
!tempcc !debug      write(*,*) 'case 1 j=1 not special',dim,fac,res
!tempcc            nullify(temp_ket_j)
!tempcc          else ! j>1 or 1 special
!tempcc            if (.special_ket(j)[1]>0) then
!tempcc              bj1 = .special_ket(j)[1]
!tempcc              bj2 = .special_ket(j)[2]
!tempcc ! Case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc !debug    write(*,*) 'kk,k',kk,k
!tempcc                DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!tempcc !debug              if(.special_ket(k)[1]==0) then
!tempcc !debug     write(*,*) "j special but not k"
!tempcc !debug     stdout.show("dim=",dim)
!tempcc !debug     do l=1,dim
!tempcc !debug       stdout.show("l=",l)
!tempcc !debug       stdout.show("order_ket(l)=",order_ket(l))
!tempcc !debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!tempcc !debug     end
!tempcc !debug     stop
!tempcc !debug     end
!tempcc !assume special_ket's are also ordered at the end in the initial guess
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                bk1 = .special_ket(k)[1]
!tempcc                bk2 = .special_ket(k)[2]
!tempcc                if(bj1/=bk1 OR bj2/=bk2) then
!tempcc                  fac=temp_bra_q(bk1,bj2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                    .special_ket(k)[1] = bj1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[1] = bk1
!tempcc                  end
!tempcc                  fac=temp_bra_q(bj1,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1
!tempcc                    .special_ket(k)[2] = bj2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    .special_ket(k)[2] = bk2
!tempcc                  end
!tempcc                else ! bj1==bk1 AND bj2==bk2
!tempcc    !res should be zero if any of the two equalities hold, then and the
!tempcc    !expression simplified accordingly and testing suggested by Thierry
!tempcc    !less necessary
!tempcc                  fac=TWO * temp_bra_q(bk1,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                 !  .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                  end
!tempcc                end ! bj1==bk1 AND bj2==bk2
!tempcc !debug      write(*,*) 'case 2 j et k special',dim,res
!tempcc              end !do kk
!tempcc ! Case 1
!tempcc             ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_bra_q(bj1,bj2)
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc              end
!tempcc !debug      write(*,*) 'case 1 j special',dim,res
!tempcc            else !j not special
!tempcc              temp_ket_j => .ket(j)[:,:]
!tempcc              do bj1=1,.n_bf
!tempcc              do bq1=1,.n_bf
!tempcc                temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
!tempcc                temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
!tempcc              end
!tempcc              end
!tempcc ! Case 2
!tempcc              reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!tempcc              do kk = dim,jj+1,-1
!tempcc                k = order_ket(kk)
!tempcc !debug    write(*,*) 'kk,k',kk,k
!tempcc                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!tempcc                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!tempcc                reorder_ket(dim-1) = k 
!tempcc                if (.special_ket(k)[1]>0) then ! k special
!tempcc                  bk1 = .special_ket(k)[1]
!tempcc                  bk2 = .special_ket(k)[2]
!tempcc                  do bj1 = 1,bk1-1
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj1 = bk1+1,.n_bf
!tempcc                    fac=temp_qb_jb(bk1,bj1)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[2] = bk2
!tempcc                      .special_ket(k)[1] = bj1
!tempcc                      res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[1] = bk1
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = 1,bk2-1
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  do bj2 = bk2+1,.n_bf
!tempcc                    fac=temp_qa_ja(bk2,bj2)
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                    ! .special_ket(k)[1] = bk1
!tempcc                      .special_ket(k)[2] = bj2
!tempcc                      res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                    end
!tempcc                  end
!tempcc                  fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!tempcc                  if (NOT fac.is_zero(.tol)) then
!tempcc                  ! .special_ket(k)[1] = bk1
!tempcc                  ! .special_ket(k)[2] = bk2
!tempcc                    res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                  end
!tempcc !debug      write(*,*) 'case 2 k  special',dim,res
!tempcc                else ! k not special
!tempcc                  temp_ket_k => .ket(k)[:,:]
!tempcc                  do bk2 = 1,.n_bf
!tempcc                  do bj1 = 1,.n_bf
!tempcc                    fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
!tempcc                    if (NOT fac.is_zero(.tol)) then
!tempcc                      .special_ket(k)[1] = bj1 
!tempcc                      .special_ket(k)[2] = bk2
!tempcc                      res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc                    end
!tempcc                  end
!tempcc                  end
!tempcc                  .special_ket(k)[1] = 0 
!tempcc                  .special_ket(k)[2] = 0
!tempcc                  nullify(temp_ket_k)
!tempcc                end  ! if (.special_ket(k)
!tempcc !debug      write(*,*) 'case 2 k not special',dim,res
!tempcc              end !do kk
!tempcc ! Case 1
!tempcc           !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!tempcc              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!tempcc              fac = temp_qb_jb.trace
!tempcc !debug      write(*,*) 'avant'
!tempcc !debug      write(*,*) 'case 1 j not special',dim,fac,res
!tempcc              if (NOT fac.is_zero(.tol)) then
!tempcc                res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
!tempcc              end
!tempcc !debug      write(*,*) 'apres'
!tempcc !debug      write(*,*) 'case 1 j not special',dim,fac,res
!tempcc              nullify(temp_ket_j)
!tempcc            end !j not special
!tempcc          end !if(j==1 AND .special_ket(1)==0) else
!tempcc        end  !do jj=dim,1,-1
!tempcc        temp_qa_ja.destroy
!tempcc        temp_qb_jb.destroy
!tempcc        reorder_ket.destroy
!tempcc        nullify(temp_bra_q)
!tempcc      end ! if(dim==1)
!tempcc    end
!tempcc 
!tempcc !  ====================
!tempcc !  geminal MFCI methods
!tempcc !  ====================
!tempcc 
!tempcc    do_hamiltonian(print_hamiltonian)
!tempcc    ! Evaluate the hamiltonian in a geminal induced basis set
!tempcc    ! built over orthonormal orbitals, and  print it if print_hamiltonian is true.
!tempcc      print_hamiltonian :: BIN, optional, IN
!tempcc      !res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc      res :: MAT{REAL}*
!tempcc !     eigenvalues :: VEC{REAL}* 
!tempcc !     R :: MAT{REAL}* 
!tempcc      print_default :: BIN
!tempcc      print_default = FALSE
!tempcc      if (present(print_hamiltonian)) print_default = print_hamiltonian
!tempcc      res.create(.n_bas,.n_bas)
!tempcc      res = .hamiltonian
!tempcc      if(print_default) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("The Hamiltonian is ")
!tempcc        stdout.put(res)
!tempcc      end
!tempcc !     eigenvalues.create(.n_bas) 
!tempcc !     R.create(.n_bas,.n_bas) 
!tempcc !     res.solve_eigenproblem(eigenvalues,R) 
!tempcc      stdout.text(" ")
!tempcc !     stdout.text("eigenvalues") 
!tempcc !     stdout.put(eigenvalues) 
!tempcc !     eigenvalues.destroy 
!tempcc !     R.destroy 
!tempcc !     res.destroy 
!tempcc    end
!tempcc 
!tempcc    do_overlap
!tempcc    ! Evaluate the 1-electron overlap integrals in a geminal induced basis set
!tempcc    ! built over orthonormal orbitals and print the result
!tempcc       res :: MAT{REAL}(.n_bas,.n_bas)
!tempcc       res = .overlap
!tempcc       stdout.text(" ")
!tempcc       stdout.text("The overlap matrix is ")
!tempcc       stdout.put(res)
!tempcc    end
!tempcc 
!tempcc    do_step_0(use_brillouin,print_hamiltonian,truncation_threshold,do_electric_dipole) 
!tempcc    ! implement step 0 of geminal scf
!tempcc      use_brillouin :: BIN, IN
!tempcc      print_hamiltonian :: BIN, IN
!tempcc      truncation_threshold :: REAL, IN
!tempcc      do_electric_dipole :: BIN, IN
!tempcc      ham :: MAT{REAL}*
!tempcc      indices :: VEC{INT}*
!tempcc      increasing_vec :: VEC{MAT_{REAL}}*
!tempcc      increasing_values :: VEC{REAL}*
!tempcc     ! j,k :: INT
!tempcc      j :: INT
!tempcc      n_nonzero,n_total :: INT
!tempcc      n_bas,n_geminals,n_bf :: INT
!tempcc      eigenvec :: MAT{REAL}*
!tempcc      new_wfs :: VEC{MAT_{REAL}}*
!tempcc      n_geminals=.n_geminals
!tempcc      n_bf=.n_bf
!tempcc      .put
!tempcc      stdout.text(" ")
!tempcc      n_total=.n_bas
!tempcc      n_nonzero=n_total-.n_dependent
!tempcc !     stdout.show("n_dependent",.n_dependent)
!tempcc      if(use_brillouin) then
!tempcc        n_bas=n_nonzero-n_bf+n_geminals 
!tempcc      else
!tempcc        n_bas=n_nonzero
!tempcc      end
!tempcc      .n_bas=n_bas
!tempcc      ham.create(n_bas,n_bas)
!tempcc      ham=ZERO
!tempcc      ham = .hamiltonian
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("The Hamiltonian is ")
!tempcc        stdout.text(" ")
!tempcc        stdout.put(ham)
!tempcc        stdout.text(" ")
!tempcc      end
!tempcc      eigenvec.create(n_bas,n_bas)
!tempcc      ham.solve_symmetric_eigenproblem(.contraction_energies(1:n_bas),eigenvec) 
!tempcc      ham.destroy 
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("eigenvectors") 
!tempcc        stdout.text(" ")
!tempcc        stdout.put(eigenvec) 
!tempcc        stdout.text(" ")
!tempcc      end
!tempcc      new_wfs.create(n_bas)
!tempcc      do j=1,n_bas
!tempcc        new_wfs(j).element.create(n_bf,n_bf)
!tempcc      end
!tempcc      new_wfs.to_product_of(eigenvec,.contraction_wfs(1:n_bas),TRUE)
!tempcc      eigenvec.destroy 
!tempcc      do j=1,n_bas
!tempcc        .contraction_wfs(j).element=new_wfs(j).element
!tempcc      end
!tempcc      new_wfs.destroy 
!tempcc      if(do_electric_dipole) then
!tempcc        .make_gs_electric_dipole
!tempcc      end
!tempcc      if(use_brillouin) then
!tempcc        .n_bas=n_nonzero
!tempcc        do j=n_nonzero-n_bf+n_geminals+1,n_nonzero
!tempcc          .contraction_energies(j)=.hamiltonian(j,j)
!tempcc        end
!tempcc      end
!tempcc      .contraction_energies=.contraction_energies+.nuclear_repulsion_energy
!tempcc !sorting eigenvalues and eigenvectors
!tempcc      indices.create(n_total)
!tempcc      .contraction_energies.quick_sort(indices)
!tempcc      increasing_vec.create(n_total)
!tempcc      increasing_values.create(n_total)
!tempcc      do j=1,n_total
!tempcc        increasing_vec(j).element.create(n_bf,n_bf)
!tempcc        increasing_vec(j).element = .contraction_wfs(indices(j)).element
!tempcc        increasing_values(j) = .contraction_energies(indices(j))
!tempcc      end
!tempcc      indices.destroy
!tempcc      do j=1,n_total
!tempcc        .contraction_wfs(j).element=increasing_vec(j).element
!tempcc      end
!tempcc      .contraction_energies=increasing_values
!tempcc      increasing_vec.destroy 
!tempcc      increasing_values.destroy 
!tempcc !printing eigenvalues and eigenvectors
!tempcc      stdout.text(" ")
!tempcc      stdout.show("first eigenvalue = ",.contraction_energies(1),12)
!tempcc      stdout.text(" ")
!tempcc      stdout.text("Active function energies (in Hartree)") 
!tempcc      stdout.text(" ")
!tempcc      stdout.put(.contraction_energies) 
!tempcc      stdout.text(" ")
!tempcc      if(truncation_threshold==ZERO) then
!tempcc        .n_bas=n_total
!tempcc      else
!tempcc        stdout.show("truncation threshold for this step = ",truncation_threshold,12)
!tempcc        .n_bas=maxloc(.contraction_energies,1,mask= &
!tempcc          .contraction_energies < truncation_threshold)
!tempcc      end
!tempcc      stdout.show("number of states saved at this step",.n_bas)
!tempcc      stdout.show("the tolerance was = ",.tol,12)
!tempcc      stdout.text(" ")
!tempcc   !   .put_max_bas
!tempcc      .put_wfs
!tempcc      .put_ground_state
!tempcc    end
!tempcc 
!tempcc    remove_dependencies(orthogonality_type,print_hamiltonian) 
!tempcc    ! remove linear dependencies in the contraction basis set
!tempcc    ! take advantage of the possible truncation of the basis set
!tempcc      orthogonality_type :: STR, IN
!tempcc      print_hamiltonian :: BIN, IN
!tempcc      word :: STR
!tempcc      i,j,k :: INT
!tempcc      n_bas,n_bf :: INT
!tempcc      ov :: MAT{REAL}*
!tempcc      norms :: VEC{REAL}*
!tempcc      keep,int_vec :: VEC{MAT_{REAL}}*
!tempcc      RDM,eigenvectors :: MAT{REAL}*
!tempcc      order_ket :: VEC{INT}*
!tempcc      old_dim,new_dim :: INT
!tempcc      n_geminals :: INT
!tempcc      n_singlet :: INT
!tempcc      .get_wfs
!tempcc      n_bf=.n_bf
!tempcc      n_singlet=n_bf*(n_bf+1)/2
!tempcc      n_bas=.n_bas
!tempcc      n_geminals=.n_geminals
!tempcc      if(n_bas==1) then 
!tempcc        stdout.text(" ")
!tempcc        stdout.text("n_bas=1, just normalizes")
!tempcc        ov.create(n_bas,n_bas)
!tempcc        ov= .overlap
!tempcc        if(print_hamiltonian) then
!tempcc          stdout.text("The overlap matrix is ")
!tempcc          stdout.text(" ")
!tempcc          stdout.put(ov)
!tempcc          stdout.text(" ")
!tempcc        end
!tempcc        .contraction_wfs(1).element=.contraction_wfs(1).element/dsqrt(ov(1,1)) 
!tempcc        ov.destroy 
!tempcc        .put_max_bas
!tempcc        .put_wfs
!tempcc        return
!tempcc      end
!tempcc      keep.create(1,n_bas)
!tempcc      do i=1,n_bas
!tempcc        keep(i).element.create(n_bf,n_bf)
!tempcc        keep(i).element=.contraction_wfs(i).element
!tempcc      end
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("before orthonomalise ")
!tempcc      ! .put
!tempcc      end
!tempcc      word = orthogonality_type
!tempcc      word.to_lower_case
!tempcc      select case (word)
!tempcc        case ("one_orthogonality     ")
!tempcc        case ("sp_two_orthogonality  ")
!tempcc          stdout.text(" ")
!tempcc          stdout.text("use two_orthogonality with respect to each spectator geminal")
!tempcc          stdout.text("and each pair of spectator geminal product")
!tempcc          stdout.text(" ")
!tempcc          old_dim=n_geminals-1
!tempcc          int_vec.create(old_dim)
!tempcc          do k=1,old_dim
!tempcc            int_vec(k).element.create(n_bf,n_bf)
!tempcc            int_vec(k).element=.bra(k+1).element
!tempcc          end
!tempcc          order_ket.create(2)
!tempcc          do i=2,n_geminals-1
!tempcc            order_ket(1)=i
!tempcc            do j=i+1,n_geminals
!tempcc              order_ket(2)=j
!tempcc              RDM.create(n_singlet,n_singlet)
!tempcc              .make_2RDM_singlet(order_ket,RDM)
!tempcc              RDM.internal_vectors(eigenvectors,.ig_tol)
!tempcc              RDM.destroy
!tempcc              if(print_hamiltonian) then
!tempcc                stdout.text(" ")
!tempcc                stdout.text("internal eigenvectors ")
!tempcc                stdout.text(" ")
!tempcc                stdout.put(transpose(eigenvectors))
!tempcc              end
!tempcc              new_dim=eigenvectors.dim1+old_dim
!tempcc              int_vec.expand(new_dim)
!tempcc              eigenvectors.unflatten(int_vec(old_dim+1:new_dim))
!tempcc              old_dim=new_dim
!tempcc              eigenvectors.destroy
!tempcc            end
!tempcc          end
!tempcc          .contraction_wfs(2:).weak_two_orthonormalise(int_vec)
!tempcc          int_vec.destroy
!tempcc          order_ket.destroy
!tempcc          if(print_hamiltonian) then
!tempcc            stdout.text(" ")
!tempcc            stdout.text("after two_orthonormalise ")
!tempcc            stdout.text(" ")
!tempcc          ! .put
!tempcc          end
!tempcc        case ("sf_two_orthogonality  ")
!tempcc          stdout.text(" ")
!tempcc          stdout.text("use two_orthogonality with respect to each spectator geminal")
!tempcc          stdout.text(" ")
!tempcc          .contraction_wfs(2:).weak_two_orthonormalise(.bra(2:))
!tempcc        case  default 
!tempcc          stdout.text(" ")
!tempcc          stdout.text("no orthogonality enforced")
!tempcc          stdout.text(" ")
!tempcc      end
!tempcc      ov.create(n_bas,n_bas)
!tempcc      ov= .overlap
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text("The overlap matrix is ")
!tempcc        stdout.text(" ")
!tempcc        stdout.put(ov)
!tempcc        stdout.text(" ")
!tempcc      end
!tempcc      norms.create(n_bas)
!tempcc      .contraction_wfs.schmidt_orthonormalise(ov,keep,norms,.n_dependent,.ld_tol)
!tempcc      !keep not necessary in fact if no orthogonality enforced
!tempcc      ov.destroy 
!tempcc      keep.destroy 
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("The scaling values are ")
!tempcc        stdout.text(" ")
!tempcc        stdout.put(norms)
!tempcc        stdout.text(" ")
!tempcc      end
!tempcc      norms.destroy 
!tempcc      .put_max_bas
!tempcc      .put_wfs
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("after sorting ")
!tempcc      ! .put
!tempcc      end
!tempcc      .n_bas=.n_bas-.n_dependent !supposed set as such by calling routine
!tempcc      if(print_hamiltonian) then
!tempcc        ov.create(.n_bas,.n_bas)
!tempcc        ov= .overlap
!tempcc        stdout.text(" ")
!tempcc        stdout.show("is unit matrix =",ov.is_unit_matrix(TOL(6)))
!tempcc        stdout.text(" ")
!tempcc        ov.destroy
!tempcc        stdout.show("n_dependent =",.n_dependent)
!tempcc      end
!tempcc    end
!tempcc 
!tempcc    remove_triplet_dependencies(print_hamiltonian) ::: leaky 
!tempcc    ! remove linear dependencies in the contraction basis set
!tempcc    !  leaky because of the set_active_triplet_defaults
!tempcc      print_hamiltonian :: BIN, IN
!tempcc      i,n_bas :: INT
!tempcc      ov :: MAT{REAL}*
!tempcc      eigenvalues :: VEC{REAL}*
!tempcc      orthovec :: MAT{REAL}*
!tempcc    !  unorthovec :: MAT{REAL}*
!tempcc      .set_active_triplet_defaults
!tempcc      n_bas=.n_bas
!tempcc      ov.create(n_bas,n_bas)
!tempcc      ov= .overlap
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("before orthonomalise ")
!tempcc      ! .put
!tempcc        stdout.text("The overlap matrix is ")
!tempcc        stdout.text(" ")
!tempcc        stdout.put(ov)
!tempcc        stdout.text(" ")
!tempcc      end
!tempcc      eigenvalues.create(n_bas)
!tempcc      eigenvalues=ZERO
!tempcc      orthovec.create(n_bas,n_bas)
!tempcc      orthovec=ZERO
!tempcc      ov.solve_symmetric_eigenproblem(eigenvalues,orthovec) 
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("The overlap matrix eigenvalues are ")
!tempcc        stdout.text(" ")
!tempcc        stdout.put(eigenvalues)
!tempcc        stdout.text(" ")
!tempcc      end
!tempcc !     unorthovec.create(n_bas,n_bas)
!tempcc !     .contraction_wfs.flatten_triplet(unorthovec) 
!tempcc      orthovec=transpose(orthovec)
!tempcc      do i=1,orthovec.dim1
!tempcc        orthovec(i,:)=orthovec(i,:)/sqrt(eigenvalues(i))
!tempcc      end
!tempcc      orthovec.unflatten_triplets(.contraction_wfs) 
!tempcc      orthovec.destroy
!tempcc      eigenvalues.destroy 
!tempcc      if(print_hamiltonian) then
!tempcc        stdout.text(" ")
!tempcc        stdout.text("after sorting ")
!tempcc      ! .put
!tempcc !     .n_bas=.n_bas-.n_dependent
!tempcc        ov= .overlap
!tempcc        stdout.text(" ")
!tempcc        stdout.show("is unit matrix =",ov.is_unit_matrix(TOL(6)))
!tempcc !       stdout.text("Check: overlap matrix is ")
!tempcc !       stdout.text(" ")
!tempcc !       stdout.put(ov)
!tempcc        stdout.text(" ")
!tempcc      end
!tempcc      ov.destroy
!tempcc    end
!tempcc 
!tempcc    make_2RDM_singlet(order_ket,res)
!tempcc    !calculate the 2nd order RDM  in a singlet basis set
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      res :: MAT{REAL}(.n_bf*(.n_bf+1)/2,.n_bf*(.n_bf+1)/2)
!tempcc 
!tempcc    ENSURE(order_ket.dim==2,"no product for >2 gems")
!tempcc 
!tempcc      int1,int2 :: MAT{REAL}(.n_bf,.n_bf)
!tempcc      b1,b2,b3,b4 :: INT
!tempcc      count1,count2 :: INT
!tempcc      n_bf :: INT
!tempcc 
!tempcc      n_bf=.n_bf
!tempcc      count1=0
!tempcc      count2=0
!tempcc      do b1=1,n_bf
!tempcc        count1=count1+1
!tempcc        int1= .interior_product_by_geminal_ab_singlet(order_ket,b1,b1)
!tempcc        count2=0
!tempcc        do b3=1,n_bf
!tempcc          count2=count2+1
!tempcc          int2= .interior_product_by_geminal_ab_singlet(order_ket,b3,b3)
!tempcc          res(count1,count2)=sum(int1*int2)
!tempcc        end
!tempcc        do b3=2,n_bf
!tempcc          do b4=1,b3-1
!tempcc            count2=count2+1
!tempcc            int2= .interior_product_by_geminal_ab_singlet(order_ket,b3,b4)
!tempcc            res(count1,count2)=sum(int1*int2)
!tempcc          end
!tempcc        end
!tempcc      end
!tempcc      do b1=2,n_bf
!tempcc        do b2=1,b1-1
!tempcc          count1=count1+1
!tempcc          int1= .interior_product_by_geminal_ab_singlet(order_ket,b1,b2)
!tempcc          count2=0
!tempcc          do b3=1,n_bf
!tempcc            count2=count2+1
!tempcc            int2= .interior_product_by_geminal_ab_singlet(order_ket,b3,b3)
!tempcc            res(count1,count2)=sum(int1*int2)
!tempcc          end
!tempcc          do b3=2,n_bf
!tempcc            do b4=1,b3-1
!tempcc              count2=count2+1
!tempcc              int2= .interior_product_by_geminal_ab_singlet(order_ket,b3,b4)
!tempcc              res(count1,count2)=sum(int1*int2)
!tempcc            end
!tempcc          end
!tempcc        end
!tempcc      end
!tempcc      DIE_IF(count1/=n_bf*(n_bf+1)/2,"count1 not equal to n_bf*(n_bf+1)/2")
!tempcc      DIE_IF(count2/=n_bf*(n_bf+1)/2,"count2 not equal to n_bf*(n_bf+1)/2")
!tempcc    end
!tempcc 
!tempcc    interior_product_by_special_geminal_ab(order_ket,b1,b2) result(res) 
!tempcc    ! Evaluate the interior product of the product of two geminals
!tempcc    ! by an alpha-beta special geminal b1, b2 and put the result in res
!tempcc      res :: MAT{REAL}(.n_bf,.n_bf)
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      b1,b2 :: INT, IN
!tempcc      ENSURE(order_ket.dim==2,"no product for >2 gems")
!tempcc      g1,g2 :: MAT{REAL}*
!tempcc      n_bf :: INT
!tempcc      b3,b4 :: INT
!tempcc      n_bf=.n_bf
!tempcc      g1=>.ket(order_ket(1)).element
!tempcc      g2=>.ket(order_ket(2)).element
!tempcc      res=ZERO
!tempcc      res=res+g1(b1,b2)*g2
!tempcc      res=res+g2(b1,b2)*g1
!tempcc      do b3=1,n_bf
!tempcc        do b4=1,n_bf
!tempcc          res(b3,b4)=res(b3,b4)-g1(b1,b4)*g2(b3,b2)-g2(b1,b4)*g1(b3,b2)
!tempcc        end
!tempcc      end
!tempcc      nullify(g1)
!tempcc      nullify(g2)
!tempcc    end
!tempcc 
!tempcc    interior_product_by_geminal_ab_singlet(order_ket,b1,b2) result(res) 
!tempcc    ! Evaluate the interior product of the product of two singlet geminals
!tempcc    ! by an alpha-beta normalized singlet geminal b1, b2 and put the result in res
!tempcc      res :: MAT{REAL}(.n_bf,.n_bf)
!tempcc      order_ket :: VEC{INT}, IN
!tempcc      b1,b2 :: INT, IN
!tempcc      ENSURE(order_ket.dim==2,"no product for >2 gems")
!tempcc      g1,g2 :: MAT{REAL}*
!tempcc      n_bf :: INT
!tempcc      b3,b4 :: INT
!tempcc      n_bf=.n_bf
!tempcc      g1=>.ket(order_ket(1)).element
!tempcc      g2=>.ket(order_ket(2)).element
!tempcc      res=ZERO
!tempcc      if(b1==b2) then
!tempcc        res=res+g1(b1,b1)*g2
!tempcc        res=res+g2(b1,b1)*g1
!tempcc        do b3=1,n_bf
!tempcc          res(b3,b3)=res(b3,b3)-g1(b1,b3)*g2(b3,b1)-g2(b1,b3)*g1(b3,b1)
!tempcc          do b4=1,b3-1
!tempcc            res(b3,b4)=res(b3,b4)-g1(b1,b4)*g2(b3,b1)-g2(b1,b4)*g1(b3,b1)
!tempcc            res(b4,b3)=res(b3,b4)
!tempcc          end
!tempcc        end
!tempcc      else
!tempcc      !  res=res+(g1(b1,b2)*g2+g1(b2,b1)*g2+g2(b1,b2)*g1+g2(b2,b1)*g1)/sqrt(TWO)
!tempcc        res=res+(g1(b1,b2)*g2+g2(b1,b2)*g1)*sqrt(TWO)
!tempcc        do b3=1,n_bf
!tempcc          !res(b3,b3)=res(b3,b3)-(g1(b1,b3)*g2(b3,b2)+g1(b2,b3)*g2(b3,b1)+ &
!tempcc          !g2(b1,b3)*g1(b3,b2)+g2(b2,b3)*g1(b3,b1))/sqrt(TWO)
!tempcc          res(b3,b3)=res(b3,b3)-(g1(b1,b3)*g2(b3,b2)+g1(b2,b3)*g2(b3,b1))*sqrt(TWO)
!tempcc          do b4=1,b3-1
!tempcc            res(b3,b4)=res(b3,b4)-(g1(b1,b4)*g2(b3,b2)+g1(b2,b4)*g2(b3,b1)+ &
!tempcc            g2(b1,b4)*g1(b3,b2)+g2(b2,b4)*g1(b3,b1))/sqrt(TWO)
!tempcc            res(b4,b3)=res(b3,b4)
!tempcc          end
!tempcc        end
!tempcc      end
!tempcc      nullify(g1)
!tempcc      nullify(g2)
!tempcc    end
!tempcc 
!tempcc    make_gs_electric_dipole 
!tempcc    ! make ground state electric dipole moment for geminal product
!tempcc    ! function
!tempcc      dip :: MAT{REAL}*
!tempcc      n_bas :: INT
!tempcc      n_bas=.n_bas
!tempcc      .n_bas=1
!tempcc      dip.create(1,1)
!tempcc      dip=ZERO
!tempcc      dip=.electric_dipole_x+.nuclear_electric_dipole(1)
!tempcc      stdout.text(" ")
!tempcc      stdout.show("The electric dipole x-component is (in a.u.):",dip(1,1))
!tempcc      stdout.text(" ")
!tempcc      stdout.show("The electric dipole x-component is (in Debye):",dip(1,1).to_units("debye"))
!tempcc      stdout.text(" ")
!tempcc      dip=ZERO
!tempcc      dip=.electric_dipole_y+.nuclear_electric_dipole(2)
!tempcc      stdout.text(" ")
!tempcc      stdout.show("The electric dipole y-component is (in a.u.):",dip(1,1))
!tempcc      stdout.text(" ")
!tempcc      stdout.show("The electric dipole y-component is (in Debye):",dip(1,1).to_units("debye"))
!tempcc      stdout.text(" ")
!tempcc      dip=ZERO
!tempcc      dip=.electric_dipole_z+.nuclear_electric_dipole(3)
!tempcc      stdout.text(" ")
!tempcc      stdout.show("The electric dipole z-component is (in a.u.):",dip(1,1))
!tempcc      stdout.text(" ")
!tempcc      stdout.show("The electric dipole z-component is (in Debye):",dip(1,1).to_units("debye"))
!tempcc      stdout.text(" ")
!tempcc      dip.destroy 
!tempcc      .n_bas=n_bas
!tempcc    end
!tempcc 
end
