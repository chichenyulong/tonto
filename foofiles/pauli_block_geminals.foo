!-------------------------------------------------------------------------------
!
! PAULI_BLOCK_GEMINALS
!
! Copyright (C) Patrick Cassam-Chenai and Thomas Perez, 2018
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module PAULI_BLOCK_GEMINALS

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!===============================================================================
!                             Create and Destroy Routines
!===============================================================================

   create ::: leaky
   ! Create a pauli_block_geminals
      self :: PTR
      nullify(self)
      allocate(self)
   !   .nullify_ptr_part
   end

   create(vec,n_geminals) ::: leaky
   ! Create a set of PBT
     vec :: VEC{PAULI_BLOCK_TENSOR}*
     n_geminals :: INT

     nullify(vec)
     allocate(vec(n_geminals))

   end


   create(vec,n) ::: leaky
   ! Create a vector of 2RDM non zero elements
     vec :: VEC{PAULI_BLOCK_2RDM_ELT}*
     n :: INT

     nullify(vec)
     allocate(vec(n))

   end


 
!tempcc    destroy_ptr_part  ::: leaky
!tempcc    ! Destroy the pointer parts of self
!tempcc       .bra.destroy
!tempcc       .ket.destroy
!tempcc       .special_ket.destroy
!tempcc    end
!tempcc 
!tempcc    create_copy(b) ::: leaky
!tempcc    ! Create a copy of "b".
!tempcc      self :: PTR
!tempcc      b :: GEMINAL_MF_SPECTRUM, IN
!tempcc 
!tempcc      .create(b.name,b.nuclear_repulsion_energy,b.n_geminals,b.i_geminals,b.n_bf)
!tempcc      .copy(b)
!tempcc 
!tempcc    end
!tempcc 
!tempcc    copy(b) ::: leaky
!tempcc    ! Copy a basis "b" to "self". Make sure pointer parts are first
!tempcc    ! destroyed or nullified, as you want.
!tempcc       b :: GEMINAL_MF_SPECTRUM, IN
!tempcc       self = b
!tempcc       if (b.bra.created) .bra.create_copy(b.bra)
!tempcc       if (b.ket.created) .ket.create_copy(b.ket)
!tempcc       if (b.special_ket.created) .special_ket.create_copy(b.special_ket)
!tempcc       if (b.contraction_wfs.created) .contraction_wfs.create_copy(b.contraction_wfs)
!tempcc       if (b.contraction_energies.created) .contraction_energies.create_copy(b.contraction_energies)
!tempcc    end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   destroy_ptr_part ::: leaky
   ! destroy the pointer parts of a PAULI_BLOCK_GEMINALS object
     i,n :: INT
     new_item :: VEC_INT_LIST*
     
     .nonzero_coef_ind.destroy
     .nonzero_coef_prod.destroy
     new_item=>.int_term_ind
     do
       if (NOT associated(new_item)) exit
       .int_term_ind.item.destroy
       new_item=>.int_term_ind.next
       deallocate(.int_term_ind)
       .int_term_ind=>new_item
     end
     nullify(new_item)
     .nonzero_1ortho_ind.destroy
     .rdm_1.destroy
     if(associated(.rdm_2_ab)) then 
       deallocate(.rdm_2_ab)
     end
     if(associated(.rdm_2_aa)) then 
       deallocate(.rdm_2_aa)
     end
     if(associated(.rdm_2_bb)) then 
       deallocate(.rdm_2_bb)
     end
     .orbital_block_mapping.destroy
     .block_types.destroy
     .block_1orthos.destroy

   end

!  ===========
!  Set methods
!  ===========

!   set_defaults(n_geminals,n_blocks,mat_size,mol_name,bra_is_ket,spin_restricted) ::: leaky
!   ! Create sets of geminals for bra and ket
!      self :: PTR
!      n_geminals,n_blocks,mat_size :: INT, optional
!      mol_name :: STR, optional
!      bra_is_ket :: BIN, optional
!      spin_restricted :: BIN, optional
!      .bra_is_ket = TRUE
!      .spin_restricted = TRUE
!      if (present(n_geminals)) .n_geminals = n_geminals
!      if (present(n_blocks)) .n_blocks=n_blocks
!      if (present(mat_size)) .mat_size=mat_size
!      if (present(mol_name)) .name = mol_name
!      if (present(bra_is_ket)) .bra_is_ket = bra_is_ket
!      if (present(spin_restricted)) .spin_restricted = spin_restricted
!      
!   end
      
! davide: 16-11-2018
   set_defaults(n_el,n_bf,mol_name, nuclear_repulsion_energy)
   ! set defaults for n_geminals, n_blocks, mat_size, 
   ! n_1ortho_blocks, bra_is_ket, spin_restricted, mol_name
   n_el, n_bf :: INT, IN
   mol_name :: STR, IN
   nuclear_repulsion_energy :: REAL, IN
   nn, dif :: INT
     
     ! set nuclear_repulsion_energy
     .nuclear_repulsion_energy=nuclear_repulsion_energy
     ! set n_geminals
     .n_geminals = (n_el+1)/2
     ! set n_blocks 
     .n_blocks = .n_geminals+(n_bf-.n_geminals+1)/2
     ! set mat_size (PBT size)
     nn = (n_el/2)*2
     if (nn /= n_el) then
        .mat_size = n_bf+1
     else
        .mat_size = n_bf
     end
     ! set n_1ortho_blocks (number of 1-orthogonal blocks in each PBT)
     dif = n_bf-.n_geminals
     nn = (dif/2)*2
     if (nn /= dif) then  
       .n_1ortho_blocks = .n_geminals+1
     else
       .n_1ortho_blocks = .n_geminals
     end
     ! set bra_is_ket (if bra set is equal to ket set)
     .bra_is_ket = TRUE
     ! set spin_restricted
     .spin_restricted = TRUE
     ! set mol_name
     .name = mol_name

   end
! de

   set_matrix_form
   ! make matrix form from coef and block types for bra_set and ket_set if different
     .make_matrix_form(.bra_set)
     if (NOT .bra_is_ket) then
       .make_matrix_form(.ket_set)
     end
   end
      
!tempcc 
!tempcc    set_to_zero_energies
!tempcc    ! set to zero contraction_energies
!tempcc      .contraction_energies = ZERO
!tempcc    end

!  ===============
!  INPUT Routines
!  ===============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

!pcc   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
!pcc   ! Read in and process list-based keywords from "stdin". List-based keywords
!pcc   ! are those that are intended to apply to each individual element of the list
!pcc   ! through a list of "keys" stored in the associated list-element type module.
!pcc   ! NOTE: this routine will create the list, if required.
!pcc      self :: PTR  
!pcc   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
 !      case ("do_overlap              "); .do_overlap
 !      case ("do_hamiltonian          "); .do_hamiltonian
       case ("junk=                   "); .read_junk
 !      case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       case ("units=                  "); .read_units
       case ("n_geminals=             "); .read_n_geminals
       case ("n_blocks=               "); .read_n_blocks
       case ("bra_is_ket=             "); .read_bra_is_ket
       case ("bra_set=                "); .read_bra_set
       case ("ket_set=                "); .read_ket_set
       case ("readin_mos=             "); .read_readin_mos
       case ("set_matrix_form         "); .set_matrix_form
       case ("spin_restricted=        "); .read_spin_restricted
       case ("first_block=            "); .read_first_block
       case ("n_1orthogonal_blocks=   "); .read_n_1orthogonal_blocks
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_n_geminals
   ! Read number of geminals
   !  self :: PTR
     n_geminals :: INT
     stdin.read(n_geminals)
     .n_geminals=n_geminals
   end

   read_n_blocks
   ! Read number of blocks
   !  self :: PTR
     n_blocks :: INT
     stdin.read(n_blocks)
     .n_blocks=n_blocks
   end 

   read_bra_is_ket
   ! Read TRUE if the bra and the ket have the same geminals, else read FALSE
   !  self :: PTR
     bra_is_ket :: BIN
     stdin.read(bra_is_ket)
     .bra_is_ket=bra_is_ket
   end 

   read_bra_set ::: leaky
   ! Read all the blocks of the geminals of the bra
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i,j,counter :: INT
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.bra_set.vec(.n_geminals))
     .bra_set.set_size=.n_geminals
     .bra_set.n_blocks_max=.n_blocks
     .bra_set.n_1ortho=.n_1ortho_blocks
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       .bra_set.vec(i).block_type.create(.n_blocks)
       .bra_set.vec(i).block_dim.create(.n_blocks)
       .bra_set.vec(i).block_dim=2
       .bra_set.vec(i).coef.create(.n_blocks)
       .bra_set.vec(i).block_type=blocks
       .bra_set.vec(i).coef=coeffs
       counter=0
       do j=1,.n_blocks
         if(blocks(j)=='ID1') then
           .bra_set.vec(i).block_dim(j)=1
           counter=counter+1
         end
       end
       .bra_set.vec(i).n_blocks(1)=counter
       .bra_set.vec(i).n_blocks(2)=.n_blocks-counter
       .bra_set.vec(i).block_spaces_size(1)=.n_1ortho_blocks 
       .bra_set.vec(i).block_spaces_size(2)=.mat_size-.n_1ortho_blocks 
     end
     .make_type_numbers(.bra_set)
   end

   read_ket_set ::: leaky
   ! Read all the blocks of the geminals of the ket
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i,j,counter :: INT
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.ket_set.vec(.n_geminals))
     .ket_set.set_size=.n_geminals
     .ket_set.n_blocks_max=.n_blocks
     .ket_set.n_1ortho=.n_1ortho_blocks
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       if (.bra_is_ket) then
         stdout.text("WARNING: .bra_is_ket has been set to TRUE !")
         stdout.show("For ket ", i)
         stdout.text("read in information will be ignored")
       else
         .ket_set.vec(i).block_type.create(.n_blocks)
         .ket_set.vec(i).block_dim.create(.n_blocks)
         .ket_set.vec(i).block_dim=2
         .ket_set.vec(i).coef.create(.n_blocks)
         .ket_set.vec(i).block_type=blocks
         .ket_set.vec(i).coef=coeffs
         counter=0
         do j=1,.n_blocks
           if(blocks(j)=='ID1') then
             .ket_set.vec(i).block_dim(j)=1
             counter=counter+1
           end
         end
         .ket_set.vec(i).n_blocks(1)=counter
         .ket_set.vec(i).n_blocks(2)=.n_blocks-counter
         .ket_set.vec(i).block_spaces_size(1)=.n_1ortho_blocks 
         .ket_set.vec(i).block_spaces_size(2)=.mat_size-.n_1ortho_blocks 
       end
     end
     .make_type_numbers(.ket_set)
   end

   read_readin_mos
   ! Read yes if MO's are to be read in, else the flag is set to FALSE and scf orbitals
   ! are used
     readin_mos :: BIN
     stdin.read(readin_mos)
     .readin_mos=readin_mos
   end 

   read_spin_restricted
   ! Read TRUE if the spin-restricted approach is selected, else read FALSE
   !  self :: PTR
     spin_restricted :: BIN
     stdin.read(spin_restricted)
     .spin_restricted=spin_restricted
   end 

   read_first_block
   ! Read 0 if there is a 1-orthogonal part and 1 if there are only Pauli blocks
   ! self :: PTR
     first_block :: INT
     stdin.read(first_block)
     .first_block=first_block
   end 
     
   read_n_1orthogonal_blocks
   ! Read number of 1-orthogonal blocks in each geminal
   !  self :: PTR
     i :: INT
     n_1ortho_blocks :: INT

     stdin.read(n_1ortho_blocks)
     .n_1ortho_blocks=n_1ortho_blocks

!     do i=1,.n_geminals
!       .bra_set.vec(i).block_spaces_size(1)=.n_1ortho_blocks 
!       .bra_set.vec(i).block_spaces_size(2)=.mat_size-.n_1ortho_blocks 
!       if (NOT .bra_is_ket) then
!         .ket_set.vec(i).block_spaces_size(1)=.n_1ortho_blocks 
!         .ket_set.vec(i).block_spaces_size(2)=.mat_size-.n_1ortho_blocks 
!       end
!     end

   end 

!tempcc    read_geminal(j,mat) ::: private, leaky
!tempcc    ! Read in a new value of ".n_bf", which must be smaller than the initial
!tempcc    ! basis set size. Truncate the coefficient matrices.
!tempcc      j :: INT
!tempcc      mat :: MAT{REAL}*
!tempcc !     ENSURE(.bra.created,"no bra")
!tempcc !     ENSURE(.bra(1).element.created,"no bra elements")
!tempcc !     ENSURE(.ket.created,"no ket")
!tempcc !     ENSURE(.ket(1).element.created,"no ket elements")
!tempcc !     ENSURE(.contraction_wfs.created,"no contraction_wfs")
!tempcc !     ENSURE(.contraction_wfs(1).element.created,"no contraction_wfs elements")
!tempcc      in :: TEXTFILE*
!tempcc      i,k,n,m :: INT
!tempcc      name :: STR
!tempcc 
!tempcc      if (FALSE) self = self
!tempcc 
!tempcc      name="readin_geminal_"//j.to_str.trim
!tempcc      in.create(name)
!tempcc      in.open_for("read")
!tempcc      in.read(n)
!tempcc 
!tempcc      mat = ZERO
!tempcc      do m=1,n
!tempcc        in.read(i)
!tempcc        in.read(k)
!tempcc        in.read(mat(i,k))
!tempcc        !if (in.end_of_file) exit
!tempcc      end
!tempcc 
!tempcc      in.close  
!tempcc      in.destroy
!tempcc 
!tempcc    end
!tempcc 
!tempcc    get_wfs ::: leaky
!tempcc    ! get wave functions from an archive file
!tempcc      wfs_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      j :: INT
!tempcc      
!tempcc      name="wfs_"//.i_geminals.to_str.trim
!tempcc      wfs_archive.set(.name,name)
!tempcc      .get_max_bas
!tempcc      if(.contraction_energies.created) then
!tempcc        .contraction_energies.destroy
!tempcc        .contraction_wfs.destroy
!tempcc      end
!tempcc      .contraction_energies.create(.n_bas)
!tempcc      .set_to_zero_energies
!tempcc      .contraction_wfs.create(.n_bas)
!tempcc      do j=1,.n_bas
!tempcc        .contraction_wfs(j).element.create(.n_bf,.n_bf)
!tempcc      end
!tempcc      wfs_archive.read(.contraction_wfs)
!tempcc    end
!tempcc 
!tempcc    get_ground_state
!tempcc    ! get ground state wave function from an archive file
!tempcc      ground_state_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="ground_state_"//.i_geminals.to_str.trim
!tempcc      ground_state_archive.set(.name,name)
!tempcc      ground_state_archive.read(.bra(.i_geminals).element)
!tempcc      .ket(.i_geminals).element=.bra(.i_geminals).element
!tempcc    end
!tempcc 
!tempcc    get_max_bas
!tempcc    ! get number of basis functions from an archive file
!tempcc      max_bas_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="max_bas_"//.i_geminals.to_str.trim
!tempcc      max_bas_archive.set(.name,name)
!tempcc      max_bas_archive.read(.n_bas)
!tempcc    end

!  ===============
!  other Routines
!  ===============

   make_matrix_form(mat_set)
   ! make matrix form from coef and block types
     mat_set :: PAULI_BLOCK_TENSOR_SET
     i,j,last :: INT
     do i=1,.n_geminals
       allocate(mat_set.vec(i).matrix_form(.mat_size,.mat_size))
       mat_set.vec(i).matrix_form=ZERO
       last=0
       do j=1,.n_blocks         
         select case (mat_set.vec(i).block_type(j))
           case ("ID1");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("ID2");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("SX");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(last,last-1)=mat_set.vec(i).coef(j)
           case ("ISY");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(last,last-1)=-mat_set.vec(i).coef(j)
           case ("SZ");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=-mat_set.vec(i).coef(j)
           case ("E11");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last-1)=mat_set.vec(i).coef(j)
           case ("E22");
             last=last+2
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("S+");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
           case ("S-");
             last=last+2
             mat_set.vec(i).matrix_form(last,last-1)=mat_set.vec(i).coef(j)
           case  default ; stdout.text("unknown matrix type")
             stop
         end
       end
     end           
   end


   make_type_numbers(subset) ::: leaky
   ! make type_numbers for each block of a subset of pauli_block_tensor
     subset :: PAULI_BLOCK_TENSOR_SET
     n_gem,i :: INT
     n_blocks,j :: INT

     n_gem=subset.vec.dim
     n_blocks=subset.vec(1).block_type.dim
     
     if(NOT subset.type_nb.created) then
       subset.type_nb.create(n_blocks)
     end
     do j=1,n_blocks
       subset.type_nb(j).element.create(9)
       subset.type_nb(j).element=0
     end
     
     do i=1,n_gem
       do j=1,n_blocks
         select case (subset.vec(i).block_type(j))       
         case("ID1"); 
           subset.type_nb(j).element(1)=subset.type_nb(j).element(1)+1     
         case("ID2");                                               
           subset.type_nb(j).element(2)=subset.type_nb(j).element(2)+1     
         case("E11");                                              
           subset.type_nb(j).element(3)=subset.type_nb(j).element(3)+1     
         case("E22");                                              
           subset.type_nb(j).element(4)=subset.type_nb(j).element(4)+1     
         case("S+");                                               
           subset.type_nb(j).element(5)=subset.type_nb(j).element(5)+1
         case("S-");                                               
           subset.type_nb(j).element(6)=subset.type_nb(j).element(6)+1
         case("SX");                                               
           subset.type_nb(j).element(7)=subset.type_nb(j).element(7)+1     
         case("ISY");                                              
           subset.type_nb(j).element(8)=subset.type_nb(j).element(8)+1     
         case("SZ"); 
           subset.type_nb(j).element(9)=subset.type_nb(j).element(9)+1
         case default ;
         end
       end
     end
   end


   put_type_numbers(bra_subset,ket_subset)
   ! make type_numbers for a pair of bra subset and ket subset
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks,j :: INT
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
   !  .make_type_numbers(bra_subset)
   !  .make_type_numbers(ket_subset)
     stdout.text("bra type numbers")
     do j=1,n_blocks
       stdout.show("j",j)
       stdout.put(bra_subset.type_nb(j).element)
     end
     stdout.text("ket type numbers")
     do j=1,n_blocks
       stdout.show("j",j)
       stdout.put(ket_subset.type_nb(j).element)
     end
   end

! davide: 16-11-2018
   check_spin_multiplicity(spin_multiplicity)
   ! check if the spin multiplicity of the molecule is lower or equal to 3;
   ! if not the program execution is stopped
   spin_multiplicity :: INT, IN

     if (spin_multiplicity > 3) then
       stdout.text("Spin multiplicity greater than 3.")
       stdout.text("Spin multiplicities beyond triplets")
       stdout.text("not yet implemented in geminal model.")
!need to implement geminal with Sz=+/-1 in order to do that
!that is to say 2 extra matrices corresponding to .n_bf-dimensional  
! diagonal blocks of a (2*.n_bf)-dimensional matrix of geminal
! coefficients. The current .n_bf-dimensional matrix used corresponds
! to a symmetrical or antisymmetrical (triplet) linear combination of
! the off-diagonal blocks
       stop
     end

   end
! de

! davide: 26-10-2018
   check_size
   ! check if the size of the geminal matrices is equal to the sum of
   ! the pauli block sizes
     stdout.text(" ")
     stdout.text("Checking size of bra set of geminals")
     .check_size(.bra_set,.mat_size)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking size of ket set of geminals")
      ! stdout.text("checking ket set of geminals")
       .check_size(.ket_set,.mat_size)
     end
   end

   check_size(pb_tensor_set,pb_mat_size)
   ! check if, for each pauli_block_matrix, the sum of block 
   ! sizes is equal to the matrix size
     pb_tensor_set :: PAULI_BLOCK_TENSOR_SET
     pb_mat_size :: INT
     i :: INT
     do i=1,.n_geminals
      stdout.show("geminal", i)
      .check_size(pb_tensor_set.vec(i),pb_mat_size) 
     end
   end

   check_size(pb_tensor,pb_mat_size)
   ! check if, for each pauli_block_matrix, the sum of block 
   ! sizes is equal to the matrix size
   pb_tensor :: PAULI_BLOCK_TENSOR
   pb_mat_size :: INT
   nb1, nb2, chk_size :: INT
     nb1 = pb_tensor.n_blocks(1) 
     nb2 = pb_tensor.n_blocks(2) 
     chk_size = nb1 + nb2*2
     if (chk_size == pb_mat_size) then 
        stdout.text("passed")
     else
        stdout.text("not passed")
     end
   end
! de

! davide: 26-10-2018
   check_block_sizes
   ! check if geminal matrices have the same block sizes
     stdout.text(" ")
     stdout.text("Checking block sizes of bra set of geminals")
     .check_block_sizes(.bra_set,.n_blocks)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking block sizes of ket set of geminals")
       .check_block_sizes(.ket_set,.n_blocks)
       stdout.text(" ")
       stdout.text("checking block sizes homogeneity of ket and bra 1st geminals")
       .check_block_sizes(.bra_set.vec(1),.ket_set.vec(1),.n_blocks)
     end
   end

   check_block_sizes(pb_tensor_set,nb)
   !
     pb_tensor_set :: PAULI_BLOCK_TENSOR_SET
     nb :: INT
     i :: INT
     do i=2,.n_geminals
       stdout.show("geminals 1 and", i)
       .check_block_sizes(pb_tensor_set.vec(1),pb_tensor_set.vec(i),nb)
     end
   end

   check_block_sizes(pbt1,pbt2,nb)
   !
     pbt1, pbt2 :: PAULI_BLOCK_TENSOR
     nb :: INT
     i :: INT
     chk_bsize :: BIN 
     chk_bsize = pbt1.block_dim.equals(pbt2.block_dim)
     if(chk_bsize) then
       stdout.text("passed")
     else
       stdout.text("not passed for blocks:")
       do i=1,nb 
         if ( pbt1.block_dim(i) /= pbt2.block_dim(i) ) then
           stdout.show(" ", i)
         end
       end
     end
   end
! de

! davide: 12-11-2018
   check_blocks_order
   ! check if in each PBT the blocks are ordered in this way:
   ! first the blocks of size 1, then the blocks of size 2
     stdout.text(" ")
     stdout.text("Checking blocks order in bra set of geminals")
     .check_blocks_order(.bra_set)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking blocks order in ket set of geminals")
       .check_blocks_order(.ket_set)
     end
   end
  
   check_blocks_order(pbt_set)
   ! call to the routine checking the order of blocks in each PBT
   pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
   ng, i :: INT
     ng = size(pbt_set.vec)
     do i=1,ng
       stdout.show("geminal", i)
       .check_blocks_order(pbt_set.vec(i))
     end
   end
  
   check_blocks_order(pbt)
   ! check if in the PBT the blocks are ordered in this way:
   ! first the blocks of size 1, then the blocks of size 2
   pbt :: PAULI_BLOCK_TENSOR, IN
   i :: INT
   test :: BIN 
     test = TRUE
     do i=1,pbt.n_blocks(1)
       if (pbt.block_dim(i) /= 1) then
         test = FALSE
         exit
       end
     end
     if (test) then
       do i=pbt.n_blocks(1)+1,pbt.n_blocks(2)
         if (pbt.block_dim(i) /= 2) then
           test = FALSE
           exit
         end
       end
     end
     if (NOT test) then
       stdout.text("not passed")
     else
       stdout.text("passed")
     end
   end
! de

!! davide: 12-11-2018
!   check_size1_blocks
!   ! check if in the i-th PBT among the blocks of size 1
!   ! only the i-th block has a nonzero coefficient
!     stdout.text(" ")
!     stdout.text("Checking blocks of size 1 in bra set of geminals")
!     .check_size1_blocks(.bra_set)
!     if (NOT .bra_is_ket) then
!       stdout.text(" ")
!       stdout.text("Checking blocks of size 1 in ket set of geminals")
!       .check_size1_blocks(.ket_set)
!     end
!   end
!  
!   check_size1_blocks(pbt_set)
!   ! call to the routine which checks the blocks 
!   ! of size 1 in each PBT
!   pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
!   ng, i :: INT
!     ng = size(pbt_set.vec)
!     do i=1,ng
!       stdout.show("geminal", i)
!       .check_size1_blocks(pbt_set.vec(i),i)
!     end
!   end
!  
!   check_size1_blocks(pbt,ind)
!   ! check if in the PBT among the blocks of size 1
!   ! only the ind-th block has a nonzero coefficient
!   pbt :: PAULI_BLOCK_TENSOR, IN
!   ind :: INT, IN
!   nb, j, check_ind, counter :: INT
!     nb = size(pbt.block_dim)
!     counter = 0
!     do j=1,nb
!       if (pbt.block_dim(j) == 1 AND abs(pbt.coef(j)) > TOL(15)) then
!         counter = counter + 1
!         check_ind = j
!       end
!     end
!     if (counter == 1 AND check_ind == ind) then
!       stdout.text("passed")
!     else
!       stdout.text("not passed")
!     end
!   end
!! de

!! davide: 17-11-2018
!   check_nonzero_1ortho_blocks_position
!   ! check if in the i-th PBT the 1-orthogonal blocks with nonzero
!   ! coefficient are consecutive, with the first nonzero coefficient in
!   ! position i (for each i=1,...,n_geminals)
!     stdout.text(" ")
!     stdout.text("Checking position of nonzero coefficients")
!     stdout.text("in 1-orthogonal blocks space of bra set")
!     .check_nonzero_1ortho_blocks_position(.bra_set)
!     if (NOT .bra_is_ket) then
!       stdout.text(" ")
!       stdout.text("Checking position of nonzero coefficients")
!       stdout.text("in 1-orthogonal blocks space of ket set")
!       .check_nonzero_1ortho_blocks_position(.ket_set)
!     end
!   end
!  
!   check_nonzero_1ortho_blocks_position(pbt_set)
!   ! call to the routine which checks the position of nonzero
!   ! 1-orthogonal blocks in each PBT
!   pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
!   i :: INT
!     do i=1,pbt_set.set_size
!       stdout.show("geminal", i)
!       .check_nonzero_1ortho_blocks_position(pbt_set.vec(i),i)
!     end
!   end
!  
!   check_nonzero_1ortho_blocks_position(pbt,ind)
!   ! check if in the PBT the 1-orthogonal blocks with nonzero
!   ! coefficient are consecutive, with the first nonzero coefficient 
!   ! in position "ind"
!     pbt :: PAULI_BLOCK_TENSOR, IN
!     ind :: INT, IN
!     j, check_ind :: INT
!     test :: BIN
!  
!   !  test = TRUE
!   !  check_ind = ind
!   !!  stdout.show("Size of 1-ortho. blocks space =", pbt.block_spaces_size(1))
!   !  do j=1,pbt.block_spaces_size(1)
!   !    if (abs(pbt.coef(j)) > TOL(15)) then
!   !      if (check_ind == j) then
!   !        check_ind = check_ind + 1
!   !      else
!   !        test = FALSE
!   !        exit
!   !      end 
!   !    end 
!   !  end
!     test = TRUE
!     check_ind = ind
!     do j=1,pbt.block_spaces_size(1)
!       if (abs(pbt.coef(j)) < TOL(15)) then
!         cycle
!       else if (check_ind == j) then
!         check_ind = check_ind + 1
!       else
!         test = FALSE
!         exit
!       end 
!     end
!  
!     if (test) then
!       stdout.text("passed")
!     else
!       stdout.text("not passed")
!     end
!  
!   end
!! de

! davide: 01-11-2018
   check_ortho
   ! check if geminals satisfy 1-orthogonality and 2-orthogonality 
     stdout.text(" ")
     stdout.text("Checking 1-orthogonality on bra set")
     .check_1ortho(.bra_set)
     stdout.text(" ")
     stdout.text("Checking 2-orthogonality on bra set")
     .check_2ortho(.bra_set)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking 1-orthogonality on ket set")
       .check_1ortho(.ket_set)
       stdout.text(" ")
       stdout.text("Checking 2-orthogonality on ket set")
       .check_2ortho(.ket_set)
     end
   end

   check_1ortho(pbt_set,only_1,pbt_constr)
   ! call to routines checking 1-orthogonality
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     only_1 :: BIN, optional
     pbt_constr :: BIN, optional
     ng, nb :: INT
     i, j :: INT
     only_n_1ortho_blocks :: BIN

     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks_max
     if (present(only_1) AND present(pbt_constr)) then
       only_n_1ortho_blocks = only_1
       do i=1,ng-1
         do j=i+1,ng
           stdout.text("geminals:")
           stdout.show(" ", i)
           stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb, only_n_1ortho_blocks, pbt_constr)
         end
       end
     else if (present(only_1)) then
       only_n_1ortho_blocks = only_1
       do i=1,ng-1
         do j=i+1,ng
           stdout.text("geminals:")
           stdout.show(" ", i)
           stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb, only_n_1ortho_blocks)
         end
       end
     else
       do i=1,ng-1
         do j=i+1,ng
           stdout.text("geminals:")
           stdout.show(" ", i)
           stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb)
         end
       end
     end

   end

   check_1ortho(pbt1,pbt2,nb,only_1,pbt_constr)
   ! check 1-orthogonality
   ! if only_1 is present and TRUE,
   ! the 1-orthogonality is checked only for the
   ! first .n_1ortho_blocks of each PBT
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
   nb :: INT
   only_1 :: BIN, optional
   pbt_constr :: BIN, optional
   i, counter :: INT
   bb :: VEC{INT}*
   only_n_1ortho_blocks :: BIN

     if (present(only_1)) then
       only_n_1ortho_blocks = only_1
     else
       only_n_1ortho_blocks = FALSE
     end

     counter = 0
     allocate(bb(nb))
     if (only_n_1ortho_blocks) then
       do i=1,pbt1.block_spaces_size(1)  ! loop over the first .n_1ortho_blocks
         if (abs(pbt1.coef(i)) > TOL(15) AND abs(pbt2.coef(i)) > TOL(15)) then
           counter = counter + 1
           bb(counter) = i
         end
       end
     else
       do i=1,nb                         ! loop over all the blocks
         if (abs(pbt1.coef(i)) > TOL(15) AND abs(pbt2.coef(i)) > TOL(15)) then
           counter = counter + 1
           bb(counter) = i
         end
       end
     end

     if (counter == 0) then
       stdout.text("passed")
     else
       stdout.text("not passed for blocks:")
       do i=1,counter
         stdout.show(" ", bb(i))
       end
       if (present(pbt_constr)) then
         pbt_constr = FALSE
       end
     end
     deallocate(bb)
   end

! davide: 18-11-2018
   check_2ortho(pbt_set)
   ! call to routines checking 2-orthogonality
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   ng, nb :: INT
   i, j :: INT
     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks_max
     do i=1,ng-1
       do j=i+1,ng
         stdout.text("geminals:")
         stdout.show(" ", i)
         stdout.show(" ", j)
         .check_2ortho(pbt_set.vec(i), pbt_set.vec(j), nb)
       end
     end
   end
! de

! davide: 03-11-2018
   check_2ortho(pbt1, pbt2, nb)
   ! check 2-orthogonality
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
   nb :: INT
   i :: INT
   check, tr :: REAL
     check = ZERO
     do i=1,nb
       if (pbt1.block_dim(i) == 1) then
         check = check + pbt1.coef(i)*pbt2.coef(i)  
       else
         tr = .calc_tr( pbt1.block_type(i), pbt2.block_type(i) )
         check = check + pbt1.coef(i)*pbt2.coef(i)*tr  
       end
     end
     if (abs(check) < TOL(15)) then
       stdout.text("passed")
     else
       stdout.text("not passed")
     end
   end
 
   calc_tr(bty1, bty2) result (tr)
   ! compute trace of product of two blocks
   ! of type ID2, E11, E22, S+, S-, SX, ISY or SZ
   bty1, bty2 :: STR, IN
   tr :: REAL
     if (bty1 == bty2) then
       if (bty1=="ID2" OR bty1=="SX" OR bty1=="ISY" OR bty1=="SZ") then
         tr = TWO
       else if (bty1=="E11" OR bty1=="E22" OR bty1=="S+" OR bty1=="S-") then
         tr = ONE 
       else
         stdout.text("unknown block type in calc_tr")
         stop
       end
     else
       if (bty1=="ID2" AND (bty2=="E11" OR bty2=="E22")) then 
         tr = ONE
       else if (bty2=="ID2" AND (bty1=="E11" OR bty1=="E22")) then 
         tr = ONE
       else if (bty1=="SX" AND (bty2=="S+" OR bty2=="S-")) then
         tr = ONE
       else if (bty2=="SX" AND (bty1=="S+" OR bty1=="S-")) then
         tr = ONE
       else if ((bty1=="ISY" AND bty2=="S+") OR (bty2=="ISY" AND bty1=="S+")) then
         tr = ONE
       else if ((bty1=="ISY" AND bty2=="S-") OR (bty2=="ISY" AND bty1=="S-")) then
         tr = -ONE
       else if ((bty1=="SZ" AND bty2=="E11") OR (bty2=="SZ" AND bty1=="E11")) then
         tr = ONE
       else if ((bty1=="SZ" AND bty2=="E22") OR (bty2=="SZ" AND bty1=="E22")) then
         tr = -ONE
       else
         tr = ZERO
       end
     end
   end
! de

! davide: 08-11-2018
   check_bra_ket_homogeneity
   ! check if the i-th bra and ket geminals
   ! have the same block structure and zero coefficients
   ! for the same blocks
   i :: INT
     .homogeneous = TRUE
     stdout.text(" ")
     stdout.text("Checking homogeneity of bra and ket sets")
     do i=1,.n_geminals
       stdout.text(" ")
       stdout.show("bra and ket geminals", i)
       stdout.text("block structure test")
       .check_block_structure(.bra_set.vec(i), .ket_set.vec(i),.homogeneous)
       stdout.text("zero coefficients test")
       .check_nonzero_coef(.bra_set.vec(i), .ket_set.vec(i),.homogeneous)
     end
   end
 
   check_block_structure(pbt1,pbt2,hom)
   ! check if the two geminals (PBT) have the same block structure,
   ! i.e. the same block types in the same positions
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR, IN
   hom :: BIN
   i, nb :: INT
   passed :: BIN
     passed= TRUE
     nb = size(pbt1.block_dim)
     do i=1,nb
       if (pbt1.block_type(i) /= pbt2.block_type(i)) then
         stdout.show("block structure test not passed for block:",i)
         passed= FALSE
         hom= FALSE
       end
     end
     if (passed) stdout.text("passed")
   end
 
   check_nonzero_coef(pbt1,pbt2,hom)
   ! check if the two geminals have zero coefficients in the same
   ! positions, i.e. for the same blocks 
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR, IN
   hom :: BIN
   i, nb :: INT
   passed, test1, test2 :: BIN
     passed = TRUE
     nb = size(pbt1.block_dim)
     do i=1,nb
      ! if (abs(pbt1.coef(i)) < TOL(15) AND abs(pbt2.coef(i)) > TOL(15) &
      ! & OR abs(pbt1.coef(i)) > TOL(15)  AND abs(pbt2.coef(i)) < TOL(15)) then
       test1 = FALSE
       test2 = FALSE
       if (abs(pbt2.coef(i))>TOL(15) AND abs(pbt1.coef(i))<TOL(15)) then
          test1 = TRUE 
       end
       if (abs(pbt1.coef(i))>TOL(15) AND abs(pbt2.coef(i))<TOL(15)) then
          test2 = TRUE 
       end
       if (test1 OR test2) then
         stdout.show("not passed for block:",i)
         passed = FALSE
         hom = FALSE
       end
     end
     if (passed) stdout.text("passed")
   end
! de

! davide: 18-11-2018
   check_pbt_constraints
   ! check if geminals satisfy the following constraints:
   ! 1-orthogonality for the first .n_1ortho_blocks and
   ! model constraints for the remaining blocks
     n :: INT

     .pbt_constraints = TRUE

     stdout.text(" ")
     stdout.text("Checking pbt constraints on bra set")
     stdout.text(" ")
     stdout.show("1-orthogonality test on the first", .n_1ortho_blocks)
     stdout.text("blocks:")
     .check_1ortho(.bra_set, TRUE, .pbt_constraints)

     n = .n_blocks - .n_1ortho_blocks
     stdout.text(" ")
     stdout.show("model constraints test on the remaining", n)
     stdout.text("blocks:")
     .check_model_constraints(.bra_set, TRUE, .pbt_constraints)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Checking pbt constraints on ket set")
       stdout.text(" ")
       stdout.show("1-orthogonality test on the first", .n_1ortho_blocks)
       stdout.text("blocks:")
       .check_1ortho(.ket_set, TRUE, .pbt_constraints)
       stdout.text(" ")
       stdout.show("model constraints test on the remaining", n)
       stdout.text("blocks:")
       .check_model_constraints(.ket_set, TRUE, .pbt_constraints)
      ! .check_bra_ket_homogeneity
      ! if (NOT .homogeneous) then
      !   stdout.text("bra and ket not homogeneous")
      !   stop
      ! end
     end
   end

   check_model_constraints(pbt_set, only_2, pbt_constr)
   ! call to the routine which checks the model constraints
   pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
   only_2 :: BIN, optional
   pbt_constr :: BIN, optional
   ng, nb :: INT
   i, j :: INT
     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks_max
     if (present(only_2) AND present(pbt_constr)) then
       do i=1,ng-1
         do j=i+1,ng
           stdout.text("geminals:")
           stdout.show(" ", i)
           stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2, pbt_constr)
         end
       end
     else if (present(only_2)) then
       do i=1,ng-1
         do j=i+1,ng
           stdout.text("geminals:")
           stdout.show(" ", i)
           stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2)
         end
       end
     else
       do i=1,ng-1
         do j=i+1,ng
           stdout.text("geminals:")
           stdout.show(" ", i)
           stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2)
         end
       end
     end

   end

   check_model_constraints(pbt1,pbt2,nb,only_2,pbt_constr)
   ! check model constraints
   ! if only_2 is present and TRUE, the model constraints are checked
   ! only for the last (.n_blocks-.n_1ortho_blocks) blocks
     pbt1, pbt2 :: PAULI_BLOCK_TENSOR
     nb :: INT
     only_2 :: BIN, optional
     pbt_constr :: BIN, optional
     i, counter :: INT
     bb :: VEC{INT}*
     only_last_blocks :: BIN

     if (present(only_2)) then
       only_last_blocks = only_2
     else
       only_last_blocks = FALSE
     end

     counter = 0
     allocate( bb(nb) )
     if (only_last_blocks) then
       do i=pbt1.block_spaces_size(1)+1,nb ! loop over the last pbt.block_spaces_size(2) blocks
         if (pbt1.block_type(i) == pbt2.block_type(i)) then
           if (abs(pbt1.coef(i)) > TOL(15)  AND  abs(pbt2.coef(i)) > TOL(15)) then
             counter = counter + 1
             bb(counter) = i
           end
         end
       end
     else
       do i=1,nb                          ! loop over all the blocks
         if (pbt1.block_type(i) == pbt2.block_type(i)) then
           if (abs(pbt1.coef(i)) > TOL(15)  AND  abs(pbt2.coef(i)) > TOL(15)) then
             counter = counter + 1
             bb(counter) = i
           end
         end
       end
     end

     if (counter == 0) then
       stdout.text("passed")
     else
       stdout.text("not passed for blocks:")
       do i=1,counter
         stdout.show(" ", bb(i))
       end
       if (present(pbt_constr)) then 
         pbt_constr = FALSE
       end
     end
     deallocate(bb)

   end
! de

! davide: 30-10-2018
   norm_gem
   ! normalization of geminals
     stdout.text(" ")
     stdout.text("Normalization of bra set of geminals")
     stdout.text("Normalized geminals - coefficients:")
     .norm_gem(.bra_set,.n_blocks)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Normalization of ket set of geminals")
       stdout.text("Normalized geminals - coefficients:")
       .norm_gem(.ket_set,.n_blocks)
     end
   end

   norm_gem(pbt_set,nb)
   ! call to the normalization routine for each geminal
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   nb :: INT
   i :: INT
     do i=1,.n_geminals
       stdout.show("geminal", i)
       .norm_gem(pbt_set.vec(i),nb)
     end
   end

   norm_gem(pbt,nb)
   ! normalization of one geminal
   pbt :: PAULI_BLOCK_TENSOR
   nb :: INT
   i :: INT
   bty :: STR
   norm :: REAL
   norm = ZERO
     do i=1,nb 
       bty = pbt.block_type(i)
       if (bty=="ID1" OR bty=="S+" OR bty=="S-" OR bty=="E11" OR bty=="E22") then
         norm = norm + pbt.coef(i)*pbt.coef(i)
       else if (bty=="ID2" OR bty=="SX" OR bty=="ISY" OR bty=="SZ") then
         norm = norm + pbt.coef(i)*pbt.coef(i)*TWO
       else
         stdout.text("unknown block type in norm_gem(pbt,nb)")
         stop
       end
     end
     norm = sqrt(norm)
     pbt.coef = pbt.coef/norm
     stdout.put(pbt.coef)
   end
! de

! davide: 31-10-2018
   find_nonzero_coef
   ! identification of nonzero coefficients in each geminal 
     stdout.text(" ")
     stdout.text("Bra set of geminals - blocks with nonzero coefficient")
     .find_nonzero_coef(.bra_set)
     if (NOT .bra_is_ket) then
       stdout.text(" ")
       stdout.text("Ket set of geminals - blocks with nonzero coefficient")
       .find_nonzero_coef(.ket_set)
     end
   end

   find_nonzero_coef(pbt_set)
   ! call to the routine for identification of nonzero coefficients
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, ng :: INT

     .nonzero_1ortho_ind.create(.n_1ortho_blocks)
     .nonzero_1ortho_ind=0

     do i=1,pbt_set.set_size
       stdout.text(" ")
       stdout.show("geminal", i)
       .find_nonzero_coef(pbt_set.vec(i),i)
     end

   end

   find_nonzero_coef(pbt,g)
   ! identification and storing of nonzero 
   ! coefficients in one geminal 
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT
     i, counter :: INT
     nb, n_1ortho :: INT

     nb = size(pbt.block_type) 
!     ! in case this routine is called two or more times
!     ! in the same calculation
!     if (allocated(pbt.nonzero_coef_ind)) then
!        deallocate(pbt.nonzero_coef_ind)
!     end
!     if (allocated(pbt.red_coef)) then
!        deallocate(pbt.red_coef)
!     end
!     !
     allocate(pbt.nonzero_coef_ind(nb))
     allocate(pbt.red_coef(nb))
     pbt.red_coef(nb) = ZERO
     counter = 0
     n_1ortho = pbt.block_spaces_size(1)
     do i=1,n_1ortho   ! loop over 1-orthogonal blocks
        if (abs(pbt.coef(i)) > TOL(15)) then
           counter = counter + 1
           pbt.nonzero_coef_ind(counter) = 0
           pbt.red_coef(counter) = pbt.coef(i)
           .nonzero_1ortho_ind(i) = g  ! geminal g has a nonzero coef. in 1-ortho. block i
        end
     end
     pbt.n_nonzero_1ortho = counter   ! number of nonzero 1-orthogonal blocks
     if(counter==0) pbt.first_block=1
     do i=n_1ortho+1,nb   ! loop over Pauli blocks
        if (abs(pbt.coef(i)) > TOL(15)) then
           counter = counter + 1
           pbt.nonzero_coef_ind(counter) = i - n_1ortho
           pbt.red_coef(counter) = pbt.coef(i)
        end
     end
     pbt.nonzero_coef_ind.shrink(counter)
     pbt.red_coef.resize(counter)

     do i=1,counter
        stdout.show( "index =", pbt.nonzero_coef_ind(i) )
        stdout.show( "coef. =", pbt.red_coef(i) )
     end
   end

! davide: 09-11-2018
 prep_nonzero_coef_ind
 ! prepare lists of block indices with nonzero coefficients
 ! (one list for each geminal)
  i, siz, j :: INT
   .nonzero_coef_ind.create(.n_geminals)
   stdout.text(" ")
   stdout.text("Indices of blocks with nonzero coefficient:")
   !stdout.text("(nonzero_coef_ind vectors)")
   do i=1,.n_geminals
     siz = size(.bra_set.vec(i).nonzero_coef_ind)
     .nonzero_coef_ind(i).element.create(siz)
     .nonzero_coef_ind(i).element = .bra_set.vec(i).nonzero_coef_ind
     stdout.show("bra and ket geminals", i)
     do j=1,siz
       stdout.show(" ",.nonzero_coef_ind(i).element(j))
     end
   end
 end
! de

   prep_nonzero_coef
   ! prepare indices and products of coefficients
   ! of nonzero blocks for the calculation of integral formulas
   ! (overlap and matrix elements between PBT sets)
     i, j :: INT
     siz_ind, siz_prod, siz :: INT
     !ind1, ind2 :: INT
     ind, ind_prod :: INT
     ng, n_nonzero_1ortho, n_nonzero_blocks :: INT
     p_coef_1ortho :: REAL
     n_pauli_blocks :: INT

     stdout.text(" ")
     stdout.text("Indices and products of coefficients")
     stdout.text("of nonzero blocks:")
     
     ng = .n_geminals
     .nonzero_coef_ind.create(ng)
     .nonzero_coef_prod.create(ng)
     if (.bra_is_ket) then
        do i=1,ng
           ! create vector of nonzero block indices
           n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
           n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
           siz_ind = n_nonzero_blocks - n_nonzero_1ortho + 1 -.first_block
           .nonzero_coef_ind(i).element.create(siz_ind)
           ! create vector of coefficient products
           n_pauli_blocks = .n_blocks-.n_1ortho_blocks
           siz_prod = n_pauli_blocks+1-.first_block
           .nonzero_coef_prod(i).element.create(siz_prod)
           .nonzero_coef_prod(i).element = ZERO
           .nonzero_coef_ind(i).element(1) = 0
           if (.first_block == 0) then 
             p_coef_1ortho = ZERO
             do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
                p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)
             end
             .nonzero_coef_prod(i).element(1) = p_coef_1ortho
           end
           ind = 1-.first_block
           do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
              ind = ind + 1
              .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
              ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
              .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)*TWO
           end
        end
     else
        do i=1,ng
           n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
           n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
           siz_ind = n_nonzero_blocks - n_nonzero_1ortho + 1 -.first_block
           .nonzero_coef_ind(i).element.create(siz_ind)
           ! create vector of coefficient products
           n_pauli_blocks = .n_blocks-.n_1ortho_blocks
           siz_prod = n_pauli_blocks+1-.first_block
           .nonzero_coef_prod(i).element.create(siz_prod)
           .nonzero_coef_prod(i).element = ZERO
           .nonzero_coef_ind(i).element(1) = 0
           if (.first_block == 0) then 
             p_coef_1ortho = ZERO
             do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
                p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)
             end
             .nonzero_coef_prod(i).element(1) = p_coef_1ortho
           end
           ind = 1-.first_block
           do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
              ind = ind + 1
              .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
              ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
              .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)*TWO
           end
        end
     end

     do i=1,ng
        stdout.text(" ")
        stdout.show("geminal",i)
        siz = size(.nonzero_coef_ind(i).element)
        do j=1,siz
           stdout.show("block index", .nonzero_coef_ind(i).element(j))
           !stdout.show("coef. product", .nonzero_coef_prod(i).element(j-1))
           ind_prod = .nonzero_coef_ind(i).element(j) + 1 -.first_block
           stdout.show("coef. product", .nonzero_coef_prod(i).element(ind_prod))
        end
     end

   end

   prep_nonzero_coef(ang)
   ! prepare indices and products of coefficients
   ! of nonzero blocks for the calculation of integral formulas
   ! (overlap and matrix elements between PBT sets)
     ang :: VEC{REAL}(.mat_size-.n_1ortho_blocks), IN
     i, j :: INT
     siz_ind, siz_prod, siz :: INT
     !ind1, ind2 :: INT
     ind, ind_prod :: INT
     ng, n_nonzero_1ortho, n_nonzero_blocks :: INT
     p_coef_1ortho :: REAL
     n_pauli_blocks :: INT

     stdout.text(" ")
     stdout.text("Indices and products of coefficients")
     stdout.text("of nonzero blocks:")
     
     ng = .n_geminals
     .nonzero_coef_ind.create(ng)
     .nonzero_coef_prod.create(ng)
     if (.bra_is_ket) then
        do i=1,ng
           ! create vector of nonzero block indices
           n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
           n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
           siz_ind = n_nonzero_blocks - n_nonzero_1ortho + 1 -.first_block
           .nonzero_coef_ind(i).element.create(siz_ind)
           ! create vector of coefficient products
           n_pauli_blocks = .n_blocks-.n_1ortho_blocks
           siz_prod = n_pauli_blocks+1-.first_block
           .nonzero_coef_prod(i).element.create(siz_prod)
           .nonzero_coef_prod(i).element = ZERO
           .nonzero_coef_ind(i).element(1) = 0
           if (.first_block == 0) then 
             p_coef_1ortho = ZERO
             do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
                p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)
             end
             .nonzero_coef_prod(i).element(1) = p_coef_1ortho
           end
           ind = 1-.first_block
           do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
              ind = ind + 1
              .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
              ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
              if (i == .block_types(ind_prod).element(1) OR i == .block_types(ind_prod).element(3)) then
                 .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)*(1-ang(ind_prod)*ang(ind_prod))*TWO
              else if (i == .block_types(ind_prod).element(2) OR i == .block_types(ind_prod).element(4)) then
                 .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)*(1-ang(ind_prod)*ang(ind_prod))*TWO
              end
           end
        end
     else
        do i=1,ng
           n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
           n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
           siz_ind = n_nonzero_blocks - n_nonzero_1ortho + 1 -.first_block
           .nonzero_coef_ind(i).element.create(siz_ind)
           ! create vector of coefficient products
           n_pauli_blocks = .n_blocks-.n_1ortho_blocks
           siz_prod = n_pauli_blocks+1-.first_block
           .nonzero_coef_prod(i).element.create(siz_prod)
           .nonzero_coef_prod(i).element = ZERO
           .nonzero_coef_ind(i).element(1) = 0
           if (.first_block == 0) then 
             p_coef_1ortho = ZERO
             do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
                p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)
             end
             .nonzero_coef_prod(i).element(1) = p_coef_1ortho
           end
           ind = 1-.first_block
           do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
              ind = ind + 1
              .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
              ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
              if (i == .block_types(ind_prod).element(1) OR i == .block_types(ind_prod).element(3)) then
                 .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)*(1-ang(ind_prod)*ang(ind_prod))*TWO
              else if (i == .block_types(ind_prod).element(2) OR i == .block_types(ind_prod).element(4)) then
                 .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)*(1-ang(ind_prod)*ang(ind_prod))*TWO
              end
           end
        end
     end

     do i=1,ng
        stdout.text(" ")
        stdout.show("geminal",i)
        siz = size(.nonzero_coef_ind(i).element)
        do j=1,siz
           stdout.show("block index", .nonzero_coef_ind(i).element(j))
           !stdout.show("coef. product", .nonzero_coef_prod(i).element(j-1))
           ind_prod = .nonzero_coef_ind(i).element(j) + 1 -.first_block
           stdout.show("coef. product", .nonzero_coef_prod(i).element(ind_prod))
        end
     end

   end
! de

! davide: 11-11-2018/12-11-2018
   make_int_term_list(check_arg,prep_arg,write_arg)
   ! make the list of non zero block indices combinations for integral
   ! formula relevant to the standard PBT model
     check_arg :: BIN, optional
     prep_arg :: BIN, optional
     write_arg :: BIN, optional
     current_list :: VEC_INT_LIST*
     new_item :: VEC_INT_LIST*
     new_list :: VEC_INT_LIST*
     i, j, k :: INT
     siz :: INT
     parity :: INT
     list_ind :: VEC{INT}*
     check :: BIN
     prep :: BIN
     writ :: BIN

     check = TRUE
     if (present(check_arg)) then
        check = check_arg
     end

     prep = TRUE
     if (present(prep_arg)) then
        prep = prep_arg
     end

     writ = TRUE
     if (present(write_arg)) then
        writ = write_arg
     end
  
     if (check) then
        .check_pbt_constraints
        if (NOT .pbt_constraints) then
          stdout.text(" ")
          stdout.text("PBT constraints not enforced")
          stop
        end
        
        if (NOT .bra_is_ket) then
          .check_bra_ket_homogeneity
          if (NOT .homogeneous) then
            stdout.text(" ")
            stdout.text("bra and ket not homogeneous")
            stop
          end
        end
     end

     if (prep) then
        .prep_nonzero_coef
     end
  
     ! initialize combinations with geminal 1 nonzero coef
     nullify(current_list)
     nullify(new_item)
     do i=1,size(.nonzero_coef_ind(1).element)
       allocate(new_item)
       allocate(new_item.item(.n_geminals))
       new_item.item(1) = .nonzero_coef_ind(1).element(i)
       new_item.next => current_list
       current_list => new_item
     end
    
     ! produce combinations
     parity = 1 ! parity used to construct combinations always in increasing index order
     do j=2,.n_geminals
       nullify(new_list)
       siz = size(.nonzero_coef_ind(j).element)
       allocate(list_ind(siz))
       list_ind = .nonzero_coef_ind(j).element(1:siz)
       do
         if (NOT associated(current_list)) exit
         if (parity == -1) then 
           ! for i=1 block number can be 0 and if so must not be eliminated
           if (list_ind(1) == 0 OR all(current_list.item(1:j-1) /= list_ind(1))) then 
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(1)
             new_item.next => new_list
             new_list => new_item
           end
           do i=2,siz ! loop on blocks where geminal j has nonzero coef
             if (any(current_list.item(1:j-1) == list_ind(i))) cycle
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(i)
             new_item.next => new_list
             new_list => new_item
           end
         else
           do i=siz,2,-1 ! loop on blocks where geminal j has nonzero coef
             if (any(current_list.item(1:j-1) == list_ind(i))) cycle
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(i)
             new_item.next => new_list
             new_list => new_item
           end 
           ! for i=1 block number can be 0 and if so must not be eliminated
           if (list_ind(1) == 0 OR all(current_list.item(1:j-1) /= list_ind(1))) then 
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(1)
             new_item.next => new_list
             new_list => new_item
           end
         end
         ! deallocating the previous list
         new_item=>current_list
         current_list => current_list.next
         deallocate(new_item.item)
         deallocate(new_item)
       end
       current_list => new_list
       parity = -parity
       deallocate(list_ind)
     end
  
     nullify(.int_term_ind)
     .int_term_ind => current_list
    
     ! write combinations produced
     if (writ) then
        stdout.text(" ")
        stdout.text("List of block indices combinations for integral")
        stdout.text("formula relevant to the standard PBT model:")
        i = 0
        current_list => .int_term_ind
        do
           if (NOT associated(current_list)) exit
           i = i + 1
           stdout.show("Combination", i)
           stdout.put(current_list.item)
           current_list => current_list.next 
        end
     end
  
   end

   make_int_term_list(check_arg,prep_arg,write_arg,ang)
   ! make the list of non zero block indices combinations for integral
   ! formula relevant to the standard PBT model
     check_arg :: BIN, optional
     prep_arg :: BIN, optional
     write_arg :: BIN, optional
     ang :: VEC{REAL}(.mat_size-.n_1ortho_blocks), IN
     current_list :: VEC_INT_LIST*
     new_item :: VEC_INT_LIST*
     new_list :: VEC_INT_LIST*
     i, j, k :: INT
     siz :: INT
     parity :: INT
     list_ind :: VEC{INT}*
     check :: BIN
     prep :: BIN
     writ :: BIN

     check = TRUE
     if (present(check_arg)) then
        check = check_arg
     end

     prep = TRUE
     if (present(prep_arg)) then
        prep = prep_arg
     end

     writ = TRUE
     if (present(write_arg)) then
        writ = write_arg
     end
  
     if (check) then
        .check_pbt_constraints
        if (NOT .pbt_constraints) then
          stdout.text(" ")
          stdout.text("PBT constraints not enforced")
          stop
        end
        
        if (NOT .bra_is_ket) then
          .check_bra_ket_homogeneity
          if (NOT .homogeneous) then
            stdout.text(" ")
            stdout.text("bra and ket not homogeneous")
            stop
          end
        end
     end

     if (prep) then
        .prep_nonzero_coef(ang)
     end
  
     ! initialize combinations with geminal 1 nonzero coef
     nullify(current_list)
     nullify(new_item)
     do i=1,size(.nonzero_coef_ind(1).element)
       allocate(new_item)
       allocate(new_item.item(.n_geminals))
       new_item.item(1) = .nonzero_coef_ind(1).element(i)
       new_item.next => current_list
       current_list => new_item
     end
    
     ! produce combinations
     parity = 1 ! parity used to construct combinations always in increasing index order
     do j=2,.n_geminals
       nullify(new_list)
       siz = size(.nonzero_coef_ind(j).element)
       allocate(list_ind(siz))
       list_ind = .nonzero_coef_ind(j).element(1:siz)
       do
         if (NOT associated(current_list)) exit
         if (parity == -1) then 
           ! for i=1 block number can be 0 and if so must not be eliminated
           if (list_ind(1) == 0 OR all(current_list.item(1:j-1) /= list_ind(1))) then 
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(1)
             new_item.next => new_list
             new_list => new_item
           end
           do i=2,siz ! loop on blocks where geminal j has nonzero coef
             if (any(current_list.item(1:j-1) == list_ind(i))) cycle
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(i)
             new_item.next => new_list
             new_list => new_item
           end
         else
           do i=siz,2,-1 ! loop on blocks where geminal j has nonzero coef
             if (any(current_list.item(1:j-1) == list_ind(i))) cycle
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(i)
             new_item.next => new_list
             new_list => new_item
           end 
           ! for i=1 block number can be 0 and if so must not be eliminated
           if (list_ind(1) == 0 OR all(current_list.item(1:j-1) /= list_ind(1))) then 
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(1)
             new_item.next => new_list
             new_list => new_item
           end
         end
         ! deallocating the previous list
         new_item=>current_list
         current_list => current_list.next
         deallocate(new_item.item)
         deallocate(new_item)
       end
       current_list => new_list
       parity = -parity
       deallocate(list_ind)
     end
  
     nullify(.int_term_ind)
     .int_term_ind => current_list
    
     ! write combinations produced
     if (writ) then
        stdout.text(" ")
        stdout.text("List of block indices combinations for integral")
        stdout.text("formula relevant to the standard PBT model:")
        i = 0
        current_list => .int_term_ind
        do
           if (NOT associated(current_list)) exit
           i = i + 1
           stdout.show("Combination", i)
           stdout.put(current_list.item)
           current_list => current_list.next 
        end
     end
  
   end
! de

! davide: 19-11-2018
   calc_overlap_integral(overlap_value,wrt_arg)
   ! compute the overlap integral between the bra and ket
   ! PBT sets
     overlap_value :: REAL, optional
     wrt_arg :: BIN, optional
     comb_list :: VEC_INT_LIST*
     term, overlap :: REAL 
     bra_coef, ket_coef :: REAL
     i :: INT
     j :: INT
     wrt :: BIN

     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end

     nullify(comb_list)
     comb_list => .int_term_ind

     overlap = ZERO

     do
        if (NOT associated(comb_list)) exit
        term = ONE
        do i=1,.n_geminals
           !comb_list.item(i) = comb_list.item(i)+1
           !term = term*.nonzero_coef_prod(i).element(comb_list.item(i))
           j = comb_list.item(i)+1-.first_block
           term = term*.nonzero_coef_prod(i).element(j)
        end
        overlap = overlap + term
        comb_list => comb_list.next 
     end

     if (present(overlap_value)) then
        overlap_value = overlap
     end

     if (wrt) then
        stdout.text(" ")
        stdout.show("Overlap integral between bra and ket PBT sets =", overlap)
     end 

   end
! de

! davide: 28-11-2018
   calc_1rdm
   ! compute the 1-reduced density matrix
   ! for a set of PBT
     i, j :: INT
     trace :: REAL

     allocate(.rdm_1(.mat_size,.mat_size))
     .rdm_1 = ZERO

     .prep_orbital_block_mapping
     .prep_block_types

     stdout.text(" ")
     stdout.text("Calculation of the 1-reduced density matrix")

     ! 1-orthogonal blocks space
     do i=1,.n_1ortho_blocks
        .calc_1rdm_element(i,i)
     end

     ! Pauli blocks space
     do i=.n_1ortho_blocks+1,.mat_size-1,2
        .calc_1rdm_element(i,i)
        j = i+1
        .rdm_1(j,j) = .rdm_1(i,i)
     end

     ! write 1-RDM
     stdout.text(" ")
     stdout.text("1-reduced density alpha-(or beta-)matrix:")
     stdout.text(" ")
     stdout.put(.rdm_1)

     ! compute 1-RDM trace
     trace = ZERO
     do i=1,.mat_size
        trace = trace + .rdm_1(i,i)
     end
     stdout.text(" ")
     stdout.show("Trace of the 1-RDM alpha-(or beta-)matrix", trace)
     stdout.text(" ")
     stdout.show("Trace of the total 1-RDM matrix", trace+trace)
     
   end

   calc_1rdm_element(row,col) 
   ! compute element (row,col) of the 1-reduced 
   ! density matrix (1-RDM) for a set of PBT
     row, col :: INT, IN
     red_pbg :: PAULI_BLOCK_GEMINALS 
     ng :: INT
     overlap :: REAL
     coef_prod, coef1, coef2 :: REAL
     block :: INT
     geminal :: INT
     term :: VEC{REAL}(4)
     j :: INT
     problem :: BIN

     ng = .n_geminals-1
     red_pbg.n_geminals = ng
     red_pbg.nonzero_coef_ind.create(ng)
     red_pbg.nonzero_coef_prod.create(ng)
     red_pbg.first_block=.first_block

     if (row == col AND row <= .n_1ortho_blocks) then  ! 1-orthogonal blocks space - diagonal element
        if (.nonzero_1ortho_ind(row) /= 0) then
           stdout.show("geminal to be skipped", .nonzero_1ortho_ind(row))
           stdout.show("nonzero 1-ortho. block", row)
           ! compute product of coefficients of the bra and ket
           ! geminals ".nonzero_1ortho_ind(row)" (1-ortho. block "row")
           coef1 = .bra_set.vec(.nonzero_1ortho_ind(row)).coef(row)
           if (.bra_is_ket) then
              coef_prod = coef1*coef1
           else
              coef2 = .ket_set.vec(.nonzero_1ortho_ind(row)).coef(row)
              coef_prod = coef1*coef2
           end
           .prep_red_pbg(red_pbg,.nonzero_1ortho_ind(row))
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           .rdm_1(row,col) = coef_prod*overlap
           stdout.text(" ")
           stdout.show("Calculation of 1-RDM diagonal element", row)
           stdout.show("product of coef.", coef_prod)
           stdout.show("overlap", overlap)
           stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
           stdout.show("normalized matrix element", .rdm_1(row,col))
        end
     else if (row == col AND row > .n_1ortho_blocks) then ! Pauli blocks space - diagonal element
        stdout.text(" ")
        stdout.show("Calculation of 1-RDM diagonal element", row)
        block = .orbital_block_mapping(row)
        do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block" are skipped
           stdout.show("term", j)
           geminal = .block_types(block).element(j) 
           stdout.show("geminal to be skipped", geminal)
           stdout.show("Pauli block to be skipped", block)
           !if (.block_types(block).element(j) /= 0) then
           if (geminal /= 0) then
              !geminal = .block_types(block).element(j) 
              ! product of coefficients from the bra and the ket 
              ! for geminal "geminal" and block "block"
              coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
              .prep_red_pbg(red_pbg, geminal, block, problem) ! geminal "geminal" and block "block" are skipped
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 term(j) = coef_prod*overlap
                 stdout.show("product of coef.", coef_prod)
                 stdout.show("overlap", overlap)
              else
                 term(j) = ZERO
              end
           else
              term(j) = ZERO
           end
           stdout.show("term", term(j))
        end
        .rdm_1(row,col) = sum(term)
        stdout.show("matrix element", .rdm_1(row,col))
        .rdm_1(row,col) = .rdm_1(row,col)/.overlap
        stdout.show("normalized matrix element", .rdm_1(row,col))
     else
        .rdm_1(row,col) = ZERO
        stdout.text(" ")
        stdout.text("Calculation of 1-RDM off-diagonal element")
        stdout.show(" ", row)
        stdout.show(" ", col)
        stdout.show("matrix element", .rdm_1(row,col))
     end
     red_pbg.destroy_ptr_part

   end

   calc_1rdm(ang)
   ! compute the 1-reduced density matrix
   ! for a set of PBT
     ang :: VEC{REAL}(.mat_size-.n_1ortho_blocks), IN
     i, j :: INT
     trace :: REAL

     allocate(.rdm_1(.mat_size,.mat_size))
     .rdm_1 = ZERO

     .prep_orbital_block_mapping
     .prep_block_types

     stdout.text(" ")
     stdout.text("Calculation of the 1-reduced density matrix")

     ! 1-orthogonal blocks space
     do i=1,.n_1ortho_blocks
        .calc_1rdm_element(i,i,ang)
     end

     ! Pauli blocks space
     do i=.n_1ortho_blocks+1,.mat_size-1,2
        .calc_1rdm_element(i,i,ang)
        j = i+1
        .rdm_1(j,j) = .rdm_1(i,i)
        .calc_1rdm_element(i,j,ang)
        .rdm_1(j,i) = .rdm_1(i,j)
     end

     ! write 1-RDM
     stdout.text(" ")
     stdout.text("1-reduced density alpha-(or beta-)matrix:")
     stdout.text(" ")
     stdout.put(.rdm_1)

     ! compute 1-RDM trace
     trace = ZERO
     do i=1,.mat_size
        trace = trace + .rdm_1(i,i)
     end
     stdout.text(" ")
     stdout.show("Trace of the 1-RDM alpha-(or beta-)matrix", trace)
     stdout.text(" ")
     stdout.show("Trace of the total 1-RDM matrix", trace+trace)
     
   end

   calc_1rdm_element(row,col,ang) 
   ! compute element (row,col) of the 1-reduced 
   ! density matrix (1-RDM) for a set of PBT
     row, col :: INT, IN
     ang :: VEC{REAL}(.mat_size-.n_1ortho_blocks), IN
     red_pbg :: PAULI_BLOCK_GEMINALS 
     ng :: INT
     overlap :: REAL
     coef_prod, coef1, coef2 :: REAL
     block :: INT
     b :: INT
     geminal :: INT
     term :: VEC{REAL}(4)
     j :: INT
     problem :: BIN

     ng = .n_geminals-1
     red_pbg.n_geminals = ng
     red_pbg.nonzero_coef_ind.create(ng)
     red_pbg.nonzero_coef_prod.create(ng)
     red_pbg.first_block=.first_block

     if (row == col AND row <= .n_1ortho_blocks) then  ! 1-orthogonal blocks space - diagonal element
        if (.nonzero_1ortho_ind(row) /= 0) then
           stdout.show("geminal to be skipped", .nonzero_1ortho_ind(row))
           stdout.show("nonzero 1-ortho. block", row)
           ! compute product of coefficients of the bra and ket
           ! geminals ".nonzero_1ortho_ind(row)" (1-ortho. block "row")
           coef1 = .bra_set.vec(.nonzero_1ortho_ind(row)).coef(row)
           if (.bra_is_ket) then
              coef_prod = coef1*coef1
           else
              coef2 = .ket_set.vec(.nonzero_1ortho_ind(row)).coef(row)
              coef_prod = coef1*coef2
           end
           .prep_red_pbg(red_pbg,.nonzero_1ortho_ind(row))
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE,ang)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           .rdm_1(row,col) = coef_prod*overlap
           stdout.text(" ")
           stdout.show("Calculation of 1-RDM diagonal element", row)
           stdout.show("product of coef.", coef_prod)
           stdout.show("overlap", overlap)
           stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
           stdout.show("normalized matrix element", .rdm_1(row,col))
        end
     else if (row == col AND row > .n_1ortho_blocks) then ! Pauli blocks space - diagonal element
        stdout.text(" ")
        stdout.show("Calculation of 1-RDM diagonal element", row)
        block = .orbital_block_mapping(row)
        do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block" are skipped
           stdout.show("term", j)
           geminal = .block_types(block).element(j) 
           stdout.show("geminal to be skipped", geminal)
           stdout.show("Pauli block to be skipped", block)
           !if (.block_types(block).element(j) /= 0) then
           if (geminal /= 0) then
              !geminal = .block_types(block).element(j) 
              ! product of coefficients from the bra and the ket 
              ! for geminal "geminal" and block "block"
              b = block-.first_block+1
              if (j == 1 OR j == 3) then
                 coef_prod = .nonzero_coef_prod(geminal).element(b)*(1+3*ang(b)*ang(b))/TWO
              else if (j == 2 OR j == 4) then
                 coef_prod = .nonzero_coef_prod(geminal).element(b)*(1-ang(b)*ang(b))/TWO
              end
              .prep_red_pbg(red_pbg, geminal, block, problem) ! geminal "geminal" and block "block" are skipped
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE,ang)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 term(j) = coef_prod*overlap
                 stdout.show("product of coef.", coef_prod)
                 stdout.show("overlap", overlap)
              else
                 term(j) = ZERO
              end
           else
              term(j) = ZERO
           end
           stdout.show("term", term(j))
        end
        .rdm_1(row,col) = sum(term)
        stdout.show("matrix element", .rdm_1(row,col))
        .rdm_1(row,col) = .rdm_1(row,col)/.overlap
        stdout.show("normalized matrix element", .rdm_1(row,col))
     else if (row+1 == col AND row > .n_1ortho_blocks) then
        stdout.text(" ")
        stdout.show("Calculation of 1-RDM diagonal element", row)
        block = .orbital_block_mapping(row)
        do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block" are skipped
           stdout.show("term", j)
           geminal = .block_types(block).element(j) 
           stdout.show("geminal to be skipped", geminal)
           stdout.show("Pauli block to be skipped", block)
           !if (.block_types(block).element(j) /= 0) then
           if (geminal /= 0) then
              !geminal = .block_types(block).element(j) 
              ! product of coefficients from the bra and the ket 
              ! for geminal "geminal" and block "block"
              b = block-.first_block+1
              if (j == 1 OR j == 3) then
                 coef_prod = .nonzero_coef_prod(geminal).element(b)*ang(b)*(3+ang(b)*ang(b))/TWO
              else if (j == 2 OR j == 4) then
                 coef_prod = .nonzero_coef_prod(geminal).element(b)*ang(b)*(1-ang(b)*ang(b))/TWO
              end
              .prep_red_pbg(red_pbg, geminal, block, problem) ! geminal "geminal" and block "block" are skipped
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE,ang)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 term(j) = coef_prod*overlap
                 stdout.show("product of coef.", coef_prod)
                 stdout.show("overlap", overlap)
              else
                 term(j) = ZERO
              end
           else
              term(j) = ZERO
           end
           stdout.show("term", term(j))
        end
        .rdm_1(row,col) = sum(term)
        stdout.show("matrix element", .rdm_1(row,col))
        .rdm_1(row,col) = .rdm_1(row,col)/.overlap
        stdout.show("normalized matrix element", .rdm_1(row,col))
     else
        .rdm_1(row,col) = ZERO
        stdout.text(" ")
        stdout.text("Calculation of 1-RDM off-diagonal element")
        stdout.show(" ", row)
        stdout.show(" ", col)
        stdout.show("matrix element", .rdm_1(row,col))
     end
     red_pbg.destroy_ptr_part

   end


   calc_2rdm
   ! compute the 2-reduced density matrix
   ! for a set of PBT   
     ng_1, ng_2 :: INT
     size_ab, size_aa :: INT
     i, i_a, i_b :: INT
     r, s :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     trace :: REAL
     mat_ab, mat_aa, mat_bb :: MAT{REAL}*
     eigenval_ab, eigenval_aa, eigenval_bb :: VEC{REAL}*
     nonzero_eigenval_ab, nonzero_eigenval_aa, nonzero_eigenval_bb :: VEC{REAL}*
     s_ab, s_aa, s_bb :: INT
     eigenvec_ab, eigenvec_aa, eigenvec_bb :: MAT{REAL}*
     j_1, j_2 :: INT

     stdout.text(" ")
     stdout.text("Calculation of the 2-reduced density matrix")

     .prep_orbital_block_mapping
     .prep_block_types
     
     size_ab = 4*.mat_size*.mat_size
     size_aa = .mat_size*(.mat_size-1)*2
     
     .create(.rdm_2_ab,size_ab)
     .create(.rdm_2_aa,size_aa)
     .create(.rdm_2_bb,size_aa)

     

     ng_1 = .n_geminals-1
     red_pbg_1.n_geminals = ng_1
     red_pbg_1.nonzero_coef_ind.create(ng_1)
     red_pbg_1.nonzero_coef_prod.create(ng_1)
     red_pbg_1.first_block=.first_block

     ng_2 = .n_geminals-2
     red_pbg_2.n_geminals = ng_2
     red_pbg_2.nonzero_coef_ind.create(ng_2)
     red_pbg_2.nonzero_coef_prod.create(ng_2)
     red_pbg_2.first_block=.first_block

     ! same_block = TRUE

     i = 0

     .calc_2rdm_same_block(i, ng_1, red_pbg_1)

     ! same_block = FALSE

     ! cases where we "skip" at least one 1-orthogonal block 

     i = i+1
     i_a = 1
     i_b = 1

     .calc_2rdm_one_1_ortho(i, i_a, i_b, ng_1, red_pbg_1, ng_2, red_pbg_2)
    
     ! cases where we have at least one Pauli Block

     .calc_2rdm_one_pauli(i, i_a, i_b, ng_1, red_pbg_1, ng_2, red_pbg_2)

     .nonzero_terms_ab = i-1
     .nonzero_terms_aa = i_a-1
     .nonzero_terms_bb = i_b-1
     
     trace = ZERO
     mat_ab.create(.mat_size*.mat_size,.mat_size*.mat_size)
     eigenval_ab.create(.mat_size*.mat_size)
     nonzero_eigenval_ab.create(.mat_size*.mat_size)
     eigenvec_ab.create(.mat_size*.mat_size,.mat_size*.mat_size)
     mat_aa.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
     eigenval_aa.create(.mat_size*(.mat_size-1)*2)
     nonzero_eigenval_aa.create(.mat_size*(.mat_size-1)*2)
     eigenvec_aa.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
     mat_bb.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
     eigenval_bb.create(.mat_size*(.mat_size-1)*2)
     nonzero_eigenval_bb.create(.mat_size*(.mat_size-1)*2)
     eigenvec_bb.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
     mat_ab = ZERO
     mat_aa = ZERO
     mat_bb = ZERO

     do r=1,.nonzero_terms_ab
        j_1 = (.rdm_2_ab(r).indices(1)-1)*.mat_size+.rdm_2_ab(r).indices(2)
        j_2 = (.rdm_2_ab(r).indices(3)-1)*.mat_size+.rdm_2_ab(r).indices(4)
        mat_ab(j_1,j_2) = .rdm_2_ab(r).coefficient
        if (.rdm_2_ab(r).indices(1) == .rdm_2_ab(r).indices(3) AND .rdm_2_ab(r).indices(2) == .rdm_2_ab(r).indices(4)) then
           trace = trace + .rdm_2_ab(r).coefficient
        end
     end
     mat_ab.solve_symmetric_eigenproblem(eigenval_ab,eigenvec_ab) 
     s = 0
     do r=1,.mat_size*.mat_size
        if (eigenval_ab(r) > TOL(15)) then
           s = s+1
           nonzero_eigenval_ab(s) = eigenval_ab(r)
        end
     end
     s_ab = s

     do r=1,.nonzero_terms_aa
        j_1 = (.rdm_2_aa(r).indices(1)-1)*.mat_size+.rdm_2_aa(r).indices(2)
        j_2 = (.rdm_2_aa(r).indices(3)-1)*.mat_size+.rdm_2_aa(r).indices(4)
        mat_aa(j_1,j_2) = .rdm_2_aa(r).coefficient
        if (.rdm_2_aa(r).indices(1) == .rdm_2_aa(r).indices(3) AND .rdm_2_aa(r).indices(2) == .rdm_2_aa(r).indices(4)) then
           trace = trace + .rdm_2_aa(r).coefficient
        end
     end
     mat_aa.solve_symmetric_eigenproblem(eigenval_aa,eigenvec_aa) 
     s = 0
     do r=1,.mat_size*(.mat_size-1)*2
        if (abs(eigenval_aa(r)) > TOL(15)) then
           s = s+1
           nonzero_eigenval_aa(s) = eigenval_aa(r)
        end
     end
     s_aa = s

     do r=1,.nonzero_terms_bb
        j_1 = (.rdm_2_bb(r).indices(1)-1)*.mat_size+.rdm_2_bb(r).indices(2)
        j_2 = (.rdm_2_bb(r).indices(3)-1)*.mat_size+.rdm_2_bb(r).indices(4)
        mat_bb(j_1,j_2) = .rdm_2_bb(r).coefficient
        if (.rdm_2_bb(r).indices(1) == .rdm_2_bb(r).indices(3) AND .rdm_2_bb(r).indices(2) == .rdm_2_bb(r).indices(4)) then
           trace = trace + .rdm_2_bb(r).coefficient
        end
     end
     mat_bb.solve_symmetric_eigenproblem(eigenval_bb,eigenvec_bb) 
     s = 0
     do r=1,.mat_size*(.mat_size-1)*2
        if (eigenval_bb(r) > TOL(15)) then
           s = s+1
           nonzero_eigenval_bb(s) = eigenval_aa(r)
        end
     end
     s_bb = s

     stdout.text(" ")
     stdout.show("Number of nonzero coefficients of the 2-RDM alpha-beta matrix", .nonzero_terms_ab)
     stdout.show("Number of nonzero eigenvalues of the 2-RDM alpha-beta matrix", s_ab)
     stdout.text("Nonzero eigenvalues of the 2-RDM alpha-beta matrix")
     stdout.put(nonzero_eigenval_ab(1:s_ab))
     stdout.text(" ")
     stdout.show("Number of nonzero coefficients of the 2-RDM alpha-alpha matrix", .nonzero_terms_aa)
     stdout.show("Number of nonzero eigenvalues of the 2-RDM alpha-alpha matrix", s_aa)
     stdout.text("Nonzero eigenvalues of the 2-RDM alpha-alpha matrix")
     stdout.put(nonzero_eigenval_aa(1:s_aa))
     stdout.text(" ")
     stdout.show("Number of nonzero coefficients of the 2-RDM beta-beta matrix", .nonzero_terms_bb)
     stdout.show("Number of nonzero eigenvalues of the 2-RDM beta-beta matrix", s_bb)
     stdout.text("Nonzero eigenvalues of the 2-RDM beta-beta matrix")
     stdout.put(nonzero_eigenval_bb(1:s_bb))
     stdout.text(" ")
     stdout.show("Trace of the total 2-RDM matrix", trace)  
     stdout.show("Sum of eigenvalues", sum(nonzero_eigenval_ab(1:s_ab))+sum(nonzero_eigenval_aa(1:s_aa))+sum(nonzero_eigenval_bb(1:s_bb)))   

     red_pbg_1.destroy_ptr_part
     red_pbg_2.destroy_ptr_part
   
   end

   calc_2rdm_same_block(i,ng_1,red_pbg_1)
   !
     i :: INT
     ng_1 :: INT
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     j :: INT
     g, b :: INT
     block, geminal, siz :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN

     do b=1,.n_1ortho_blocks
        g = .nonzero_1ortho_ind(b)
        if (g == 0) cycle
        coef_1 = .bra_set.vec(g).coef(b)
        if (.bra_is_ket) then
           coef_prod = coef_1*coef_1
        else
           coef_2 = .ket_set.vec(g).coef(b)
           coef_prod = coef_1*coef_2
        end
        .prep_red_pbg(red_pbg_1,g)
        red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
        red_pbg_1.calc_overlap_integral(overlap,FALSE)
        i = i+1
        .rdm_2_ab(i).same_block = TRUE
        .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
        .rdm_2_ab(i).indices = (/ b,b,b,b /)
        .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
        .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
        stdout.text(" ")
        stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
        stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
     end
     do b=.n_1ortho_blocks+1,.n_blocks
        block = b - .n_1ortho_blocks
        ind_1 = .n_1ortho_blocks+2*(block-1)+1
        ind_2 = .n_1ortho_blocks+2*(block-1)+2
        do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block" are skipped
           geminal = .block_types(block).element(j) 
           if (geminal /= 0) then
              coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
              .prep_red_pbg(red_pbg_1, geminal, block, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg_1.calc_overlap_integral(overlap,FALSE)
                 term(j) = coef_prod*overlap
              else
                 term(j) = ZERO
              end
           else
              term(j) = ZERO
           end
        end
        if (term(1)+term(2) /= 0) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_1,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_ab(i).coefficient = (term(1)+term(2))/.overlap
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
           stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_2,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
           stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
        if (term(3)+term(4) /= 0) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_1,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_ab(i).coefficient = (term(3)+term(4))/.overlap
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
           stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_2,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
           stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
        if (term(1)-term(2) /= 0) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_2,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_ab(i).coefficient = (term(1)-term(2))/.overlap
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
           stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_1,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
           stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
        if (term(3)-term(4) /= 0) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_2,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_ab(i).coefficient = (term(3)-term(4))/.overlap
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
           stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_1,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
           stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
     end
   end


  calc_2rdm_one_1_ortho(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2)
  !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     j :: INT
     r, s :: INT
     g, b :: INT
     block, geminal, siz :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2, coef_3, coef_4 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN

     do r=1,.n_1ortho_blocks-1
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef_1 = .bra_set.vec(geminal).coef(r)
        if (NOT .bra_is_ket) then
           coef_2 = .ket_set.vec(geminal).coef(r)
        end 
        do b=r+1,.n_1ortho_blocks
           g = .nonzero_1ortho_ind(b)
           if (g == 0) cycle
           if (g == geminal) then
              coef_3 = .bra_set.vec(g).coef(b)
              if (NOT .bra_is_ket) then
                 coef_4 = .ket_set.vec(g).coef(b)
              end
              .prep_red_pbg(red_pbg_1,g)
              red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg_1.calc_overlap_integral(overlap,FALSE)

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ r,r,b,b /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              if (.bra_is_ket) then
                 .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
              else
                 .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
              end            
              stdout.text(" ")
              stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
              stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ b,b,r,r /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              if (.bra_is_ket) then
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              else
                 .rdm_2_ab(i).coefficient = coef_2*coef_3*overlap/.overlap
              end  
              stdout.text(" ")
              stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
              stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           else if (g /= geminal) then
              coef_3 = .bra_set.vec(g).coef(b)
              if (.bra_is_ket) then
                 coef_prod = coef_1*coef_1*coef_3*coef_3
              else
                 coef_4 = .ket_set.vec(g).coef(b)
                 coef_prod = coef_1*coef_2*coef_3*coef_4
              end
              .prep_red_pbg_g(red_pbg_2,geminal,g)
              red_pbg_2.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg_2.calc_overlap_integral(overlap,FALSE)

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ r,b,r,b /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
              stdout.text(" ")
              stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
              stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
              stdout.text(" ")
              stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
              stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
              stdout.text(" ")
              stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
              stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ b,r,b,r /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              stdout.text(" ")
              stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
              stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           end
        end
     end

     do r=1,.n_1ortho_blocks
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef_1 = .bra_set.vec(geminal).coef(r)
        if (NOT .bra_is_ket) then
           coef_2 = .ket_set.vec(geminal).coef(r)
        end  
        siz = size(.nonzero_coef_ind(geminal).element)
        do s=2,siz
           block = .nonzero_coef_ind(geminal).element(s)
           b = block + .n_1ortho_blocks
           ind_1 = .n_1ortho_blocks+2*(block-1)+1
           ind_2 = .n_1ortho_blocks+2*(block-1)+2
           .prep_red_pbg(red_pbg_1, geminal, block, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg_1.calc_overlap_integral(overlap,FALSE)
              coef_3 = .bra_set.vec(geminal).coef(b)
              if (NOT .bra_is_ket) then
                 coef_4 = .ket_set.vec(geminal).coef(b)
              end

              if (geminal == .block_types(block).element(1)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1
              end

              if (geminal == .block_types(block).element(2)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1
              end

              if (geminal == .block_types(block).element(3)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

              end

              if (geminal == .block_types(block).element(4)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                 stdout.text(" ")
                 stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                 stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

              end
           end
        end
     end
   end


  calc_2rdm_one_pauli(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2)
  !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     j :: INT
     r, s :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal, geminal_1, geminal_2 :: INT
     ind_1, ind_2 :: INT
     ind_3, ind_4 :: INT
     coef_1, coef_2, coef_3, coef_4 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN

     do b1=.n_1ortho_blocks+1,.n_blocks
        block_1 = b1 - .n_1ortho_blocks
        ind_1 = .n_1ortho_blocks+2*(block_1-1)+1
        ind_2 = .n_1ortho_blocks+2*(block_1-1)+2
        do b2=1,.n_1ortho_blocks
           geminal_2 = .nonzero_1ortho_ind(b2)
           if (geminal_2 == 0) cycle
           coef_1 = .bra_set.vec(geminal_2).coef(b2)
           if (NOT .bra_is_ket) then
              coef_2 = .ket_set.vec(geminal_2).coef(b2)
           end
           do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block_1" are skipped
              geminal_1 = .block_types(block_1).element(j) 
              if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_1*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 else
                    coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 end
                 .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_1))) then
                    red_pbg_2.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg_2.calc_overlap_integral(overlap,FALSE)
                    term(j) = coef_prod*overlap
                 else
                    term(j) = ZERO
                 end
              else
                 term(j) = ZERO
              end
           end
           if (sum(term) /= 0) then

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_1,b2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = sum(term)/.overlap
              stdout.text(" ")
              stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
              stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
              stdout.text(" ")
              stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
              stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
              stdout.text(" ")
              stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
              stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_2,b2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              stdout.text(" ")
              stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
              stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
              stdout.text(" ")
              stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
              stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
              stdout.text(" ")
              stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
              stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_1,b2,ind_1,b2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
              stdout.text(" ")
              stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
              stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_2,b2,ind_2,b2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
              stdout.text(" ")
              stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
              stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

           end
        end
     end

     do b1=.n_1ortho_blocks+1,.n_blocks-1
        block_1 = b1 - .n_1ortho_blocks
        ind_1 = .n_1ortho_blocks+2*(block_1-1)+1
        ind_2 = .n_1ortho_blocks+2*(block_1-1)+2

        do b2=b1+1,.n_blocks
           block_2 = b2 - .n_1ortho_blocks
           ind_3 = .n_1ortho_blocks+2*(block_2-1)+1
           ind_4 = .n_1ortho_blocks+2*(block_2-1)+2

           ! case "i1 = j1 and i2 = j2"          
           do r=1,2
              if (.block_types(block_1).element(r) /= 0) then
                 do s=1,2
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end          

           ! case "i1 /= j1 and i2 /= j2"
         
           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end     

           ! cases "i1 = j1 and i2 /= j2" + "i1 /= j1 and i2 = j2"

           do r=1,2
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                          stdout.show("block_1", block_1)
                          stdout.show("block_2", block_2)
                          stdout.show("geminal", geminal)
                          stdout.show("coef_1", coef_1)
                          stdout.show("coef_2", coef_2)
                          stdout.show("overlap", overlap)

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                          if (r+2 /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                          if (r+2 /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end 

           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=1,2
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                          if (r /= s+2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                          if (r /= s+2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          stdout.text(" ")
                          stdout.show("2-RDM element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                          stdout.show("2-RDM element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end

           ! case "i1 = i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 = j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 = i2 and j1 = j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

        end
     end
   end

  
   calc_2rdm_elt_i_jj(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1ortho_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1ortho_blocks
     term = (/ ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IZ_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IZ_DD_aa(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_XY_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_DD_bb(two_rdm_elt,k)
     end
     
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     if (sum(term) /= ZERO) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
           stdout.text(" ")
           stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
           stdout.text(" ")
           stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end


   calc_2rdm_elt_ii_j(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1ortho_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1ortho_blocks
     term = (/ ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_DD_IZ_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_IZ_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_IZ_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_DD_XY_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_XY_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_XY_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     if (sum(term) /= ZERO) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
           stdout.text(" ")
           stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
           stdout.text(" ")
           stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end


   calc_2rdm_elt_ii_jj(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1ortho_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1ortho_blocks
     term = (/ ZERO,ZERO,ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IX_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IX_DD_aa(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IY_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IY_DD_aa(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_ZX_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_ZX_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_ZX_DD_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_ZY_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_ZY_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_ZY_DD_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     if (sum(term) /= ZERO) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
           stdout.text(" ")
           stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
           stdout.text(" ")
           stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end


   calc_2rdm_elt_i_j(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     j, s :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(18)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1ortho_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1ortho_blocks
     k = 0
     t = k
     term = ZERO
     if (n == 1 OR n == 2) then
        .sum_set_info_IZXY_IZ_ab_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_IZXY_IZ_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_IZXY_XY_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IZXY_XY_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_IZXY_XY_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
           red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg.calc_overlap_integral(overlap,FALSE)
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)*overlap
        else
           term(k) = ZERO
        end
     end

     k = 2
     do j=1,4
        if (.block_types(block_1).element(j) /= 0) then
           geminal_1 = .block_types(block_1).element(j)
           do s=1,4
              if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
                 geminal_2 = .block_types(block_2).element(s)
                 .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    term(k) = coef_prod_1*coef_prod_2*overlap
                 end
              end
           end
        end
     end

     if (sum(term) /= ZERO) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
           stdout.text(" ")
           stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
           stdout.text(" ")
           stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
           stdout.text(" ")
           stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
           stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end


   prep_red_pbg(red_pbg,g) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g;
   ! this new PBG will be used to compute an element of the 1RDM or 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g :: INT, IN
     i, j, siz :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminal g
     do i=1,.n_geminals
        if (i < g) then
           ! create vector of nonzero block indices
           siz = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(i).element.create(siz)
           red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
           stdout.show("block indices, geminal", i)
           stdout.put(red_pbg.nonzero_coef_ind(i).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(i).element.destroy
           red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
           stdout.show("coefficient products, geminal", i)
           stdout.put(red_pbg.nonzero_coef_prod(i).element)
        else if (i > g) then
           j = i-1
           ! create vector of nonzero block indices
           siz = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(j).element.create(siz)
           red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
           stdout.show("block indices, geminal", i)
           stdout.put(red_pbg.nonzero_coef_ind(j).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.destroy
           red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
           stdout.show("coefficient products, geminal", i)
           stdout.put(red_pbg.nonzero_coef_prod(j).element)
        end
     end
   end

   prep_red_pbg_g(red_pbg,g,gg) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg :: INT, IN
     i, j, k, l, siz :: INT
     t, tt :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminals g and gg

     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        if (i < t) then
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(i).element.create(siz)
           red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
           stdout.show("block indices, geminal", i)
           stdout.put(red_pbg.nonzero_coef_ind(i).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(i).element.destroy
           red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
           stdout.show("coefficient products, geminal", i)
           stdout.put(red_pbg.nonzero_coef_prod(i).element)
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(j).element.create(siz)
           red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
           stdout.show("block indices, geminal", i)
           stdout.put(red_pbg.nonzero_coef_ind(j).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.destroy
           red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
           stdout.show("coefficient products, geminal", i)
           stdout.put(red_pbg.nonzero_coef_prod(j).element)
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(k).element.create(siz)
           red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
           stdout.show("block indices, geminal", i)
           stdout.put(red_pbg.nonzero_coef_ind(k).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(k).element.destroy
           red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
           stdout.show("coefficient products, geminal", i)
           stdout.put(red_pbg.nonzero_coef_prod(k).element)
        end
     end
   end

   prep_red_pbg(red_pbg,g,b,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g;
   ! this new PBG will be used to compute an element of the 1RDM or 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, b :: INT, IN
     problem :: BIN
     i, j, k, siz :: INT
     presence :: BIN
     ind :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminal g
     ! and block b

     problem = FALSE

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence = FALSE
        do k=1,siz
           if (.nonzero_coef_ind(i).element(k) == b) then
              presence = TRUE
              ind = k
              exit
           end
        end
        if (i < g) then
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(i).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
        else if (i > g) then  ! to skip geminal g and shift the geminals with i > g by -1
           j = i-1
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vectors of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(j).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create list of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (NOT presence) then
              ! create vectors of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create list of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg(red_pbg,g,b,bb,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, b, bb :: INT, IN
     problem :: BIN
     i, j, l, siz :: INT
     b1, b2 :: INT
     presence1, presence2 :: BIN
     ind1, ind2 :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminal g
     ! and blocks b and bb

     problem = FALSE

     if (b < bb) then
        b1=b
        b2=bb
     else if (b > bb) then
        b1=bb
        b2=b
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence1 = FALSE
        presence2 = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b1) then
              presence1 = TRUE
              ind1 = l
              exit
           end
        end
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b2) then
              presence2 = TRUE
              ind2 = l
              exit
           end
        end
        if (i < g) then
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz-2)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > g) then ! to skip geminal g and shift the following geminals by -1
           j = i-1
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz-2)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg_g(red_pbg,g,gg,b,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg, b :: INT, IN
     problem :: BIN
     i, j, k, l, siz :: INT
     t, tt :: INT
     presence :: BIN
     ind :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminals g and gg
     ! and block b

     problem = FALSE

     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b) then
              presence = TRUE
              ind = l
              exit
           end
        end

        if (i < t) then
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(i).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(j).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(k).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.create(siz)
              red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg(red_pbg,g,gg,b,bb,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg, b, bb :: INT, IN
     problem :: BIN
     i, j, k, l, siz :: INT
     t, tt, b1, b2 :: INT
     presence1, presence2 :: BIN
     ind1, ind2 :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminals g and gg
     ! and blocks b and bb

     problem = FALSE

     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end
     if (b < bb) then
        b1=b
        b2=bb
     else if (b > bb) then
        b1=bb
        b2=b
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence1 = FALSE
        presence2 = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b1) then
              presence1 = TRUE
              ind1 = l
              exit
           end
        end
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b2) then
              presence2 = TRUE
              ind2 = l
              exit
           end
        end
        if (i < t) then
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz-2)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz-2)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(k).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(k).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.create(siz-2)
              red_pbg.nonzero_coef_ind(k).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(k).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(k).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.create(siz)
              red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
              stdout.show("block indices, geminal", i)
              stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
              stdout.show("coefficient products, geminal", i)
              stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

! davide: 27-11-2018
   prep_orbital_block_mapping
   ! prepare the vector containing the orbital 
   ! to block correspondence 
     i, d :: INT

     .orbital_block_mapping.create(.mat_size)

     ! 1-orthogonal blocks
     do i=1,.n_1ortho_blocks 
        .orbital_block_mapping(i) = 0
     end

     ! Pauli blocks
     do i=.n_1ortho_blocks+1,.mat_size 
         d = i-.n_1ortho_blocks+1
        .orbital_block_mapping(i) = int(d/2)
     end

     stdout.text(" ")
     stdout.text("Orbitals to blocks mapping:")
     stdout.put(.orbital_block_mapping)

   end

   prep_block_types
   ! prepare the vector of vectors containing the indices of geminal
   ! for the 4 Pauli block types ID2, SZ, SX, ISY
     i :: INT
     n_pauli_blocks :: INT
     
     ! create vector of vectors "block_types"
     n_pauli_blocks = .n_blocks-.n_1ortho_blocks 
     .block_types.create(n_pauli_blocks)
     do i=1,n_pauli_blocks
        .block_types(i).element.create(4)
        .block_types(i).element = 0
     end

     ! prepare "block_types"
     do i=1,.n_geminals
        .prep_block_types(.bra_set.vec(i),i)
     end

     ! write "block_types"
     stdout.text(" ")
     stdout.text("Block types vectors:")
     do i=1,n_pauli_blocks
        stdout.text(" ")
        stdout.show("Pauli block", i)
        stdout.put(.block_types(i).element)
     end

   end

   prep_block_types(pbt,g)
   ! prepare "block types", checking each geminal
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT, IN
     i, j, n :: INT

     do i=.n_1ortho_blocks+1,.n_blocks
        if (abs(pbt.coef(i)) > TOL(15)) then
           n = .select_block_type(pbt.block_type(i))
           j = i - .n_1ortho_blocks
           .block_types(j).element(n) = g
        end
     end

   end

   select_block_type(bty) result(n)
   ! select the block type and provide an integer
   ! for the preparation of "block types"
     bty :: STR, IN
     n :: INT

     select case (bty)
        case("ID2") 
           n = 1
        case("SZ") 
           n = 2
        case("SX") 
           n = 3
        case("ISY") 
           n = 4
        case default   
           stdout.text("unrecognized block type")
           stop
     end

   end
! de

   prep_block_1orthos
   ! prepare the vector containing the indices of geminal
   ! for the 1-orthogonal part
     i :: INT
     
     ! create vector "block_1orthos"
     .block_1orthos.create(.n_1ortho_blocks)
     do i=1,.n_1ortho_blocks
        .block_1orthos(i) = 0
     end

     ! prepare "block_1orthos"
     do i=1,.n_geminals
        .prep_block_1orthos(.bra_set.vec(i),i)
     end

     ! write "block_1orthos"
     stdout.text(" ")
     stdout.text("1-orthogonal block vector:")
     do i=1,.n_1ortho_blocks
        stdout.text(" ")
        stdout.show("1-orthogonal block", i)
        stdout.show("geminal", .block_1orthos(i))
     end

   end

   prep_block_1orthos(pbt,g)
   ! prepare "block 1orthos", checking each geminal
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT, IN
     i :: INT

     do i=1,.n_1ortho_blocks
        if (abs(pbt.coef(i)) > TOL(15)) then
           .block_1orthos(i) = g
        end
     end

   end

   sum_set_info_IZ_DD_ab_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(2) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(2)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZ_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(2) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(2)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == x) OR (u == y AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_DD_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == x) OR (u == y AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_DD_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_IZ_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_IZ_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_IZ_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IX_DD_ab_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IX_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IY_DD_ab_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IY_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZY_DD_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end

   sum_set_info_ZY_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZY_DD_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_IZ_ab_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w) OR (u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_IZ_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_XY_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w) OR (u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_XY_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w) OR (u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_XY_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
     stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


! davide: 26-11-2018
   destroy_nonzero_coef
   ! destroy memory created for vectors of vectors
   ! "nonzero_coef_ind" and "nonzero_coef_prod" 
     i, ng :: INT

     ng = .n_geminals
     do i=1,ng
        .nonzero_coef_ind(i).element.destroy
        .nonzero_coef_prod(i).element.destroy
     end

     .nonzero_coef_ind.destroy
     .nonzero_coef_prod.destroy

   end
! de

! davide: 20-11-2018
   random_geminals_generator ::: leaky
   ! generate random geminals which satisfy 
   ! the constraints of the model
   i :: INT

     stdout.text(" ")
     stdout.text("Randomly generated bra set:")
     .make_1ortho_space(.bra_set)
     .make_pauli_space(.bra_set)

     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(.bra_set.vec(i).coef)
     end

     if (.bra_is_ket) then
     ! we should make sure that no memory is lost
        .ket_set.set_size=.n_geminals
        .ket_set.vec=>.bra_set.vec
!to make a copy_pbt_set routine       if (NOT associated(.ket_set.vec)) then
!to make a copy_pbt_set routine         allocate(.ket_set.vec(.n_geminals))
!to make a copy_pbt_set routine         .ket_set.set_size=.n_geminals
!to make a copy_pbt_set routine         do i=1,.n_geminals
!to make a copy_pbt_set routine           .ket_set.vec(i).block_type.create(.n_blocks)
!to make a copy_pbt_set routine           .ket_set.vec(i).coef.create(.n_blocks)
!to make a copy_pbt_set routine           .ket_set.vec(i).block_dim.create(.n_blocks)
!to make a copy_pbt_set routine         end
!to make a copy_pbt_set routine       end
!to make a copy_pbt_set routine       do i=1,.n_geminals
!to make a copy_pbt_set routine         .ket_set.vec(i).block_type=.bra_set.vec(i).block_type
!to make a copy_pbt_set routine         .ket_set.vec(i).coef=.bra_set.vec(i).coef
!to make a copy_pbt_set routine         .ket_set.vec(i).block_dim=.bra_set.vec(i).block_dim
!to make a copy_pbt_set routine         .ket_set.vec(i).n_blocks=.bra_set.vec(i).n_blocks
!to make a copy_pbt_set routine         .ket_set.vec(i).block_spaces_size=.bra_set.vec(i).block_spaces_size 
!to make a copy_pbt_set routine       end
       ! stdout.text(" ")
       ! stdout.text("Randomly generated ket set:")
       ! 
       ! do i=1,.n_geminals
       !    stdout.text(" ")
       !    stdout.show("geminal",i)
       !    stdout.text("block structure:")
       !    stdout.put(.ket_set.vec(i).block_type)
       !    stdout.text("coefficients:")
       !    stdout.put(.ket_set.vec(i).coef)
       ! end
     end

   end

   make_1ortho_space(pbt_set)
   ! make the block structure and generate the coefficients 
   ! for the 1-orthogonal block space of each geminal 
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, j, set_size, n_1ortho :: INT
     num :: REAL

     set_size = pbt_set.set_size  ! set_size = n_geminals
     n_1ortho = pbt_set.n_1ortho  ! n_1ortho = number of 1-orthogonal blocks
     do i=1,set_size 
        ! assign block type ID1 to each "n_1ortho" block
        pbt_set.vec(i).block_type(1:n_1ortho) = "ID1"
        ! generate coefficients for the first "n_geminals" 1-orthogonal blocks
        pbt_set.vec(i).coef(1:n_1ortho) = ZERO
        call random_number(num)
        pbt_set.vec(i).coef(i) = (num - HALF)*TWO
     end
     ! generate coefficients for the last 
     ! (n_1ortho_blocks-n_geminals) 1-orthogonal blocks
     ! (if n_1ortho_blocks > n_geminals)
     do i=set_size+1,n_1ortho
        call random_number(num)
        j = int(num*set_size)+1  ! selection of the j-th geminal
        call random_number(num)                    ! generation of the coefficient for
        pbt_set.vec(j).coef(i) = (num - HALF)*TWO  ! the i-th 1-ortho. block of geminal j
     end

   end

   make_pauli_space(pbt_set)
   ! make the block structure and generate the coefficients 
   ! for the Pauli block space of each geminal 
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, j, k, set_size, n_1ortho, n_blocks :: INT
     set_size_minus_1, set_size_minus_2 :: INT
     gem :: VEC{INT}(3)
     b_typ :: VEC{STR}(3)
     num :: REAL

     set_size = pbt_set.set_size ! set_size = n_geminals
     n_1ortho = pbt_set.n_1ortho ! n_1ortho = number of 1-orthogonal blocks
     n_blocks = pbt_set.n_blocks_max ! n_blocks = total number of blocks

     do i=1,set_size
        pbt_set.vec(i).coef(n_1ortho+1:n_blocks) = ZERO
        pbt_set.vec(i).block_type(n_1ortho+1:n_blocks) = "ID2"
     end

     set_size_minus_1 = set_size-1
     set_size_minus_2 = set_size-2
     do i=n_1ortho+1,n_blocks ! loop over the Pauli blocks
        ! select 3 geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
           if (set_size > 2) then
                ! 3rd geminal
              call random_number(num)
              j = int(num*set_size_minus_2)+1
              if ( j < min(gem(1),gem(2)) ) then
                 gem(3) = j
              else if ( j >= (max(gem(1),gem(2))-1) ) then
                 gem(3) = j+2
              else
                 gem(3) = j+1
              end
           end
        end
        ! assign a type of Pauli block and a coefficient
        ! to each of the 3 selected geminals
        call random_number(num)
        j = int(num*6)
        b_typ = .select_block_types(j)
!        stdout.show("pauli block",i)
!        stdout.text("selected geminals")
!        stdout.put(gem)
!        stdout.text("selected permutation of block types")
!        stdout.put(b_typ)
        do k=1,min(3,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
     end

   end

   select_block_types(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the 3 pauli block types (ID2, SX, SZ)
     integ :: INT, IN
     b_types :: VEC{STR}(3)

     select case (integ)
        case(0)
           b_types(1) = "ID2"
           b_types(2) = "SX"
           b_types(3) = "SZ"
        case(1)
           b_types(1) = "ID2"
           b_types(2) = "SZ"
           b_types(3) = "SX"
        case(2)
           b_types(1) = "SX"
           b_types(2) = "ID2"
           b_types(3) = "SZ"
        case(3)
           b_types(1) = "SX"
           b_types(2) = "SZ"
           b_types(3) = "ID2"
        case(4)
           b_types(1) = "SZ"
           b_types(2) = "ID2"
           b_types(3) = "SX"
        case(5)
           b_types(1) = "SZ"
           b_types(2) = "SX"
           b_types(3) = "ID2"
        case default   
           stdout.text("unrecognized block type code")
           stop
      end

   end
! de

!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

!tempcc !  ===============
!tempcc !  Inquiry methods
!tempcc !  ===============
!tempcc 
!tempcc !   same_as(b) result(res) 
!tempcc !   ! Return TRUE if the basis set "self" is the same as "b". Only the
!tempcc !   ! shell vector is compared to see if they are "really" the same.
!tempcc !      self :: IN
!tempcc !      b :: GEMINAL_MF_SPECTRUM, IN
!tempcc !      res :: BIN
!tempcc !      res = FALSE
!tempcc !   end
!tempcc 
!  ==============
!  Output methods
!  ==============

   put
   ! Print out the object
      n_geminals :: INT
      i :: INT
      bra_is_ket :: BIN

      n_geminals=.n_geminals
      stdout.text(" ")
      stdout.text(" ")
      stdout.text("PBG info:")
      stdout.text(" ")
      stdout.show("number of geminals :",.n_geminals)
      stdout.text(" ")
      stdout.show("number of blocks in each geminal :",.n_blocks)
      stdout.text(" ")
      stdout.show("bra=ket :",.bra_is_ket)
      stdout.text(" ")
      stdout.text(" ")
      do i=1,n_geminals
        stdout.show("block type of bra :",i)
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text(" ")
        stdout.show("block coef. of bra :",i)
        stdout.put(.bra_set.vec(i).coef)
        stdout.text(" ")
        stdout.show("block sizes of bra :",i)
        stdout.put(.bra_set.vec(i).block_dim)
        stdout.text(" ")
        stdout.show("block numbers of bra :",i)
        stdout.put(.bra_set.vec(i).n_blocks)
        stdout.text(" ")
        stdout.show("matrix form of bra :",i)
        stdout.put(.bra_set.vec(i).matrix_form)
        stdout.text(" ")
        stdout.text(" ")
      end
      if(NOT .bra_is_ket) then
        do i=1,n_geminals
          stdout.show("block type of ket :",i)
          stdout.put(.ket_set.vec(i).block_type)
          stdout.text(" ")
          stdout.show("block coef. of ket :",i)
          stdout.put(.ket_set.vec(i).coef)
          stdout.text(" ")
          stdout.show("block sizes of ket :",i)
          stdout.put(.ket_set.vec(i).block_dim)
          stdout.text(" ")
          stdout.show("block numbers of ket :",i)
          stdout.put(.ket_set.vec(i).n_blocks)
          stdout.text(" ")
          stdout.show("matrix form of ket :",i)
          stdout.put(.ket_set.vec(i).matrix_form)
          stdout.text(" ")
          stdout.text(" ")
        end
        .put_type_numbers(.bra_set,.ket_set)
        .make_pauli_trace(.bra_set,.ket_set)
      else
        .put_type_numbers(.bra_set,.bra_set)
        .make_pauli_trace(.bra_set,.bra_set)
      end     
   end


!  ================
!  Integral methods
!  ================

!   make_theorem
!   ! make the formula of our general theorem
!   
!   end


   make_pauli_trace(bra_subset,ket_subset)
   ! make trace of a product of blocks
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks, n_block1, j :: INT
     pauli_trace :: REAL
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
     n_block1=bra_subset.vec(1).n_blocks(1)
     pauli_trace = ZERO
     .make_type_numbers(bra_subset)
     .make_type_numbers(ket_subset)
     select case (n_gem)
       case(1);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
           end
         end
         pauli_trace = 2*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
         end
       case(2);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
           end
         end
         pauli_trace = 8*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
         end
       case(3);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
           end
         end
         pauli_trace = 48*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
         end
       case(4);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
           end
         end
         pauli_trace = 384*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
         end
       case default ;
     end
     stdout.show("trace of product of bra and ket geminals :",pauli_trace)
   end

   make_hamiltonian(ham)
   ! make hamiltonian 
     ham :: REAL
     v :: MAT4{REAL}*
     r,i_1,j_1,i_2,j_2 :: INT
     eri_archive :: ARCHIVE

     eri_archive.set(.name,"h_integrals")
     v.create(.mat_size,.mat_size,.mat_size,.mat_size)
     eri_archive.read(v)

     ham = ZERO

     do r=1,.nonzero_terms_ab
        i_1 = .rdm_2_ab(r).indices(1)
        j_1 = .rdm_2_ab(r).indices(2)
        i_2 = .rdm_2_ab(r).indices(3)
        j_2 = .rdm_2_ab(r).indices(4)
        ham = ham + .rdm_2_ab(r).coefficient*v(i_1,j_1,i_2,j_2)
     end

     do r=1,.nonzero_terms_aa
        i_1 = .rdm_2_aa(r).indices(1)
        j_1 = .rdm_2_aa(r).indices(2)
        i_2 = .rdm_2_aa(r).indices(3)
        j_2 = .rdm_2_aa(r).indices(4)
        ham = ham + .rdm_2_aa(r).coefficient*(v(i_1,j_1,i_2,j_2)-v(i_1,j_1,j_2,i_2))
     end

     do r=1,.nonzero_terms_bb
        i_1 = .rdm_2_bb(r).indices(1)
        j_1 = .rdm_2_bb(r).indices(2)
        i_2 = .rdm_2_bb(r).indices(3)
        j_2 = .rdm_2_bb(r).indices(4)
        ham = ham + .rdm_2_bb(r).coefficient*(v(i_1,j_1,i_2,j_2)-v(i_1,j_1,j_2,i_2))
     end

     v.destroy
     stdout.show("Electronic energy",ham)
     stdout.show("Total energy",ham+.nuclear_repulsion_energy)

   end

!  ====================
!  geminal MFCI methods
!  ====================

end
