!-------------------------------------------------------------------------------
!
! PAULI_BLOCK_GEMINALS
!
! Copyright (C) Patrick Cassam-Chenai and Thomas Perez, 2018
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module PAULI_BLOCK_GEMINALS

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!===============================================================================
!                             Create and Destroy Routines
!===============================================================================

   create ::: leaky
   ! Create a pauli_block_geminals
      self :: PTR
      nullify(self)
      allocate(self)
   !   .nullify_ptr_part
   end

   create(vec,n_geminals) ::: leaky
   ! Create a set of PBT
     vec :: VEC{PAULI_BLOCK_TENSOR}*
     n_geminals :: INT

     nullify(vec)
     allocate(vec(n_geminals))

   end


 
!tempcc  destroy ::: get_from(OBJECT), leaky
!tempcc  ! Destroy an object
!tempcc  end
!tempcc
!tempcc  destroy_ptr_part ::: get_from(OBJECT), leaky
!tempcc  ! Destroy the pointer parts of self
!tempcc  end
!tempcc 
!tempcc    destroy_ptr_part  ::: leaky
!tempcc    ! Destroy the pointer parts of self
!tempcc       .bra.destroy
!tempcc       .ket.destroy
!tempcc       .special_ket.destroy
!tempcc    end
!tempcc 
!tempcc    create_copy(b) ::: leaky
!tempcc    ! Create a copy of "b".
!tempcc      self :: PTR
!tempcc      b :: GEMINAL_MF_SPECTRUM, IN
!tempcc 
!tempcc      .create(b.name,b.nuclear_repulsion_energy,b.n_geminals,b.i_geminals,b.n_bf)
!tempcc      .copy(b)
!tempcc 
!tempcc    end
!tempcc 
!tempcc    copy(b) ::: leaky
!tempcc    ! Copy a basis "b" to "self". Make sure pointer parts are first
!tempcc    ! destroyed or nullified, as you want.
!tempcc       b :: GEMINAL_MF_SPECTRUM, IN
!tempcc       self = b
!tempcc       if (b.bra.created) .bra.create_copy(b.bra)
!tempcc       if (b.ket.created) .ket.create_copy(b.ket)
!tempcc       if (b.special_ket.created) .special_ket.create_copy(b.special_ket)
!tempcc       if (b.contraction_wfs.created) .contraction_wfs.create_copy(b.contraction_wfs)
!tempcc       if (b.contraction_energies.created) .contraction_energies.create_copy(b.contraction_energies)
!tempcc    end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

!  ===========
!  Set methods
!  ===========

   set_defaults(n_geminals,n_bf,mol_name,bra_is_ket) ::: leaky
   ! Create sets of geminals for bra and ket
      self :: PTR
      mol_name :: STR, optional
      n_geminals,n_bf :: INT, optional
      bra_is_ket :: BIN, optional

      if (present(n_geminals)) .n_geminals = n_geminals
      if (present(n_bf)) .n_blocks=int((n_bf+1)/2)
      if (present(mol_name)) .name = mol_name
      if (present(bra_is_ket)) .bra_is_ket = bra_is_ket
      
   end
      

   set_matrix_form
   ! make matrix form from coef and block types for bra_set and ket_set if different
     .make_matrix_form(.bra_set)
     if (NOT .bra_is_ket) then
       .make_matrix_form(.ket_set)
     end
   end
      

!tempcc 
!tempcc    set_to_zero_energies
!tempcc    ! set to zero contraction_energies
!tempcc      .contraction_energies = ZERO
!tempcc    end

!  ===============
!  INPUT Routines
!  ===============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

!pcc   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
!pcc   ! Read in and process list-based keywords from "stdin". List-based keywords
!pcc   ! are those that are intended to apply to each individual element of the list
!pcc   ! through a list of "keys" stored in the associated list-element type module.
!pcc   ! NOTE: this routine will create the list, if required.
!pcc      self :: PTR  
!pcc   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
 !      case ("do_overlap              "); .do_overlap
 !      case ("do_hamiltonian          "); .do_hamiltonian
       case ("junk=                   "); .read_junk
 !      case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       case ("units=                  "); .read_units
       case ("n_geminals=             "); .read_n_geminals
       case ("n_blocks=               "); .read_n_blocks
       case ("bra_is_ket=             "); .read_bra_is_ket
       case ("bra_set=                "); .read_bra_set
       case ("ket_set=                "); .read_ket_set
       case ("set_matrix_form         "); .set_matrix_form
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_n_geminals
   ! Read number of geminals
   !  self :: PTR
     n_geminals :: INT
     stdin.read(n_geminals)
     .n_geminals=n_geminals
   end

   read_n_blocks
   ! Read number of blocks
   !  self :: PTR
     n_blocks :: INT
     stdin.read(n_blocks)
     .n_blocks=n_blocks
   end 

   read_bra_is_ket
   ! Read TRUE if the bra and the ket have the same geminals, else read FALSE
   !  self :: PTR
     bra_is_ket :: BIN
     stdin.read(bra_is_ket)
     .bra_is_ket=bra_is_ket
   end 

   read_bra_set ::: leaky
   ! Read all the blocks of the geminals of the bra
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i :: INT
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.bra_set.vec(.n_geminals))
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       .bra_set.vec(i).block_type.create(.n_blocks)
       .bra_set.vec(i).coef.create(.n_blocks)
       .bra_set.vec(i).block_type=blocks
       .bra_set.vec(i).coef=coeffs
     end
   end

   read_ket_set ::: leaky
   ! Read all the blocks of the geminals of the ket
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i :: INT
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.ket_set.vec(.n_geminals))
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       if (.bra_is_ket) then
         stdout.text("WARNING: .bra_is_ket has been set to TRUE !")
         stdout.show("For ket ", i)
         stdout.text("read in information will be ignored")
       else
         .ket_set.vec(i).block_type.create(.n_blocks)
         .ket_set.vec(i).coef.create(.n_blocks)
         .ket_set.vec(i).block_type=blocks
         .ket_set.vec(i).coef=coeffs
       end
     end
   end

!tempcc    read_geminal(j,mat) ::: private, leaky
!tempcc    ! Read in a new value of ".n_bf", which must be smaller than the initial
!tempcc    ! basis set size. Truncate the coefficient matrices.
!tempcc      j :: INT
!tempcc      mat :: MAT{REAL}*
!tempcc !     ENSURE(.bra.created,"no bra")
!tempcc !     ENSURE(.bra(1).element.created,"no bra elements")
!tempcc !     ENSURE(.ket.created,"no ket")
!tempcc !     ENSURE(.ket(1).element.created,"no ket elements")
!tempcc !     ENSURE(.contraction_wfs.created,"no contraction_wfs")
!tempcc !     ENSURE(.contraction_wfs(1).element.created,"no contraction_wfs elements")
!tempcc      in :: TEXTFILE*
!tempcc      i,k,n,m :: INT
!tempcc      name :: STR
!tempcc 
!tempcc      if (FALSE) self = self
!tempcc 
!tempcc      name="readin_geminal_"//j.to_str.trim
!tempcc      in.create(name)
!tempcc      in.open_for("read")
!tempcc      in.read(n)
!tempcc 
!tempcc      mat = ZERO
!tempcc      do m=1,n
!tempcc        in.read(i)
!tempcc        in.read(k)
!tempcc        in.read(mat(i,k))
!tempcc        !if (in.end_of_file) exit
!tempcc      end
!tempcc 
!tempcc      in.close  
!tempcc      in.destroy
!tempcc 
!tempcc    end
!tempcc 
!tempcc    get_wfs ::: leaky
!tempcc    ! get wave functions from an archive file
!tempcc      wfs_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      j :: INT
!tempcc      
!tempcc      name="wfs_"//.i_geminals.to_str.trim
!tempcc      wfs_archive.set(.name,name)
!tempcc      .get_max_bas
!tempcc      if(.contraction_energies.created) then
!tempcc        .contraction_energies.destroy
!tempcc        .contraction_wfs.destroy
!tempcc      end
!tempcc      .contraction_energies.create(.n_bas)
!tempcc      .set_to_zero_energies
!tempcc      .contraction_wfs.create(.n_bas)
!tempcc      do j=1,.n_bas
!tempcc        .contraction_wfs(j).element.create(.n_bf,.n_bf)
!tempcc      end
!tempcc      wfs_archive.read(.contraction_wfs)
!tempcc    end
!tempcc 
!tempcc    get_ground_state
!tempcc    ! get ground state wave function from an archive file
!tempcc      ground_state_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="ground_state_"//.i_geminals.to_str.trim
!tempcc      ground_state_archive.set(.name,name)
!tempcc      ground_state_archive.read(.bra(.i_geminals).element)
!tempcc      .ket(.i_geminals).element=.bra(.i_geminals).element
!tempcc    end
!tempcc 
!tempcc    get_max_bas
!tempcc    ! get number of basis functions from an archive file
!tempcc      max_bas_archive :: ARCHIVE
!tempcc      name :: STR
!tempcc      
!tempcc      name="max_bas_"//.i_geminals.to_str.trim
!tempcc      max_bas_archive.set(.name,name)
!tempcc      max_bas_archive.read(.n_bas)
!tempcc    end

!  ===============
!  other Routines
!  ===============

   make_matrix_form(mat_set)
   ! make matrix form from coef and block types
     mat_set :: PAULI_BLOCK_TENSOR_SET
     i,j,k :: INT
     do i=1,.n_geminals
       allocate(mat_set.vec(i).matrix_form(2*.n_blocks,2*.n_blocks))
       mat_set.vec(i).matrix_form=ZERO
       do j=1,.n_blocks         
         select case (mat_set.vec(i).block_type(j))
           case ("ID2");
             mat_set.vec(i).matrix_form(2*j-1,2*j-1)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(2*j,2*j)=mat_set.vec(i).coef(j)
           case ("SX");
             mat_set.vec(i).matrix_form(2*j-1,2*j)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(2*j,2*j-1)=mat_set.vec(i).coef(j)
           case ("ISY");
             mat_set.vec(i).matrix_form(2*j-1,2*j)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(2*j,2*j-1)=-mat_set.vec(i).coef(j)
           case ("SZ");
             mat_set.vec(i).matrix_form(2*j-1,2*j-1)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(2*j,2*j)=-mat_set.vec(i).coef(j)
           case  default ; stdout.text("unknown matrix type")
             stop
         end
       end
     end           
   end


   make_type_numbers(subset) ::: leaky
   ! make type_numbers for each block of a subset of pauli_block_tensor
     subset :: PAULI_BLOCK_TENSOR_SET
     n_gem,i :: INT
     n_blocks,j :: INT

     n_gem=subset.vec.dim
     n_blocks=subset.vec(1).block_type.dim
     
     if(NOT subset.type_nb.created) then
       subset.type_nb.create(n_blocks)
     end
     do j=1,n_blocks
       subset.type_nb(j).element.create(8)
       subset.type_nb(j).element=0
     end
     
     do i=1,n_gem
       do j=1,n_blocks
         select case (subset.vec(i).block_type(j))       
         case("ID2"); 
           subset.type_nb(j).element(1)=subset.type_nb(j).element(1)+1     
         case("E11"); 
           subset.type_nb(j).element(2)=subset.type_nb(j).element(2)+1     
         case("E22"); 
           subset.type_nb(j).element(3)=subset.type_nb(j).element(3)+1     
         case("S+"); 
           subset.type_nb(j).element(4)=subset.type_nb(j).element(4)+1
         case("S-"); 
           subset.type_nb(j).element(5)=subset.type_nb(j).element(5)+1
         case("SX"); 
           subset.type_nb(j).element(6)=subset.type_nb(j).element(6)+1     
         case("ISY"); 
           subset.type_nb(j).element(7)=subset.type_nb(j).element(7)+1     
         case("SZ"); 
           subset.type_nb(j).element(8)=subset.type_nb(j).element(8)+1
         case default ;
         end
       end
     end
   end


   make_type_numbers(bra_subset,ket_subset)
   ! make type_numbers for a pair of bra subset and ket subset
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks,j :: INT
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
     .make_type_numbers(bra_subset)
     .make_type_numbers(ket_subset)
     stdout.text("bra type numbers")
     do j=1,n_blocks
       stdout.show("j",j)
       stdout.put(bra_subset.type_nb(j).element)
     end
     stdout.text("ket type numbers")
     do j=1,n_blocks
       stdout.show("j",j)
       stdout.put(ket_subset.type_nb(j).element)
     end
   end


!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

!tempcc !  ===============
!tempcc !  Inquiry methods
!tempcc !  ===============
!tempcc 
!tempcc !   same_as(b) result(res) 
!tempcc !   ! Return TRUE if the basis set "self" is the same as "b". Only the
!tempcc !   ! shell vector is compared to see if they are "really" the same.
!tempcc !      self :: IN
!tempcc !      b :: GEMINAL_MF_SPECTRUM, IN
!tempcc !      res :: BIN
!tempcc !      res = FALSE
!tempcc !   end
!tempcc 
!  ==============
!  Output methods
!  ==============

   put
   ! Print out the object
      n_geminals :: INT
      i :: INT
      bra_is_ket :: BIN
      bra_set :: PAULI_BLOCK_TENSOR_SET

      n_geminals=.n_geminals
      stdout.text(" ")
      stdout.text(" ")
      stdout.text("PBG info:")
      stdout.text(" ")
      stdout.show("number of geminals :",.n_geminals)
      stdout.text(" ")
      stdout.show("number of blocks in each geminal :",.n_blocks)
      stdout.text(" ")
      stdout.show("bra=ket :",.bra_is_ket)
      stdout.text(" ")
      stdout.text(" ")
      do i=1,n_geminals
        stdout.show("block type of bra :",i)
        stdout.put(.bra_set.vec(i).block_type)
      stdout.text(" ")
        stdout.show("block coef. of bra :",i)
        stdout.put(.bra_set.vec(i).coef)
      stdout.text(" ")
        stdout.show("matrix form of bra :",i)
        stdout.put(.bra_set.vec(i).matrix_form)
      stdout.text(" ")
      stdout.text(" ")
      end
      if(NOT .bra_is_ket) then
        do i=1,n_geminals
          stdout.show("block type of ket :",i)
          stdout.put(.ket_set.vec(i).block_type)
          stdout.text(" ")
          stdout.show("block coef. of ket :",i)
          stdout.put(.ket_set.vec(i).coef)
          stdout.text(" ")
          stdout.show("matrix form of ket :",i)
          stdout.put(.ket_set.vec(i).matrix_form)
          stdout.text(" ")
          stdout.text(" ")
        end
        .make_type_numbers(.bra_set,.ket_set)
        .make_pauli_trace(.bra_set,.ket_set)
      else
        .make_type_numbers(.bra_set,.bra_set)
        .make_pauli_trace(.bra_set,.bra_set)
      end     
   end


!  ================
!  Integral methods
!  ================

!   make_theorem
!   ! make the formula of our general theorem
!   
!   end


   make_pauli_trace(bra_subset,ket_subset)
   ! make trace of a product of blocks
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks,j :: INT
     pauli_trace :: REAL
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
     pauli_trace = ZERO
     .make_type_numbers(bra_subset)
     .make_type_numbers(ket_subset)
     select case (n_gem)
       case(1);
         do j=1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
           end
         end
         pauli_trace = 2*pauli_trace
       case(2);
         do j=1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
           end
         end
         pauli_trace = 8*pauli_trace
       case(3);
         do j=1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
           end
         end
         pauli_trace = 48*pauli_trace
       case(4);
         do j=1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
           end
         end
         pauli_trace = 384*pauli_trace
       case default ;
     end
     stdout.show("trace of product of bra and ket geminals :",pauli_trace)
   end


!  ====================
!  geminal MFCI methods
!  ====================

end
