!==============================================================================-
!
! MOLECULE.GEM: An object representation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Patrick Cassam-Chenai
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.gem.foo $
!==============================================================================-


module MOLECULE.GEM

   implicit none

contains

! ============================================
! Geminal Mean Field Configuration Interaction
! ============================================

   read_geminal_mf_scheme ::: leaky 
   ! Read in geminal mean field scheme options

   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT

     .geminal_mf_scheme.create
     .geminal_mf_scheme.set_defaults(.n_a,.n_bf,.name,.BASE:nuclear_repulsion_energy)
     .geminal_mf_scheme.read_keywords

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     ! this routine stops here in most cases
     if(.geminal_mf_scheme.readin_scheme) then
       .geminal_mf_scheme.read_scheme
     end

     if(.geminal_mf_scheme.make_singlet_extremals) then

       n_bf = .n_bf
       make_integrals = .geminal_mf_scheme.make_integrals
       readin_mos     = .geminal_mf_scheme.readin_mos

       if (make_integrals) then

         ! First create the MO integrals on disk
         v.create(n_bf,n_bf,n_bf,n_bf)
         .FOCK:make_ERI_integrals(v)

         new_n_bf = .geminal_mf_scheme.n_orbitals
         DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

         eri_archive.set(.name,"h_integrals")

         if (readin_mos) then

           if (new_n_bf==n_bf) then
             .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           else
             .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           end

         else

           if (new_n_bf==n_bf) then
             .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           else
             .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           end

         end

         v.destroy      

         stdout.text(" ")
         stdout.text("an integral file has been saved on disk")
         stdout.text(" ")

       else

         stdout.text(" ")
         stdout.text("using old integral file")
         stdout.text(" ")

       end

       .geminal_mf_scheme.spectrum.make_singlet_extremals

     end

   end

   do_geminal_mf_scheme ::: leaky 
   ! perform a geminal mean field calculation

   ENSURE(.geminal_mf_scheme.created,"no geminal_mf_scheme info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     do_electric_dipole :: BIN

     n_bf = .n_bf

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     do_electric_dipole = any(.geminal_mf_scheme.do_electric_dipole)
     if (do_electric_dipole) then
       .geminal_mf_scheme.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
     end

     make_integrals = .geminal_mf_scheme.make_integrals
     readin_mos     = .geminal_mf_scheme.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)

       new_n_bf = .geminal_mf_scheme.n_orbitals
       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         if(new_n_bf==n_bf)then
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       else

         if(new_n_bf==n_bf)then
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end

     .geminal_mf_scheme.do_gmf_auto

   end

   restart_geminal_mf_scheme ::: leaky 
   ! perform a geminal mean field calculation

   ENSURE(.geminal_mf_scheme.created,"no geminal_mf_scheme info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     do_electric_dipole :: BIN

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     n_bf = .n_bf

     do_electric_dipole = any(.geminal_mf_scheme.do_electric_dipole)
     if (do_electric_dipole) then
       .geminal_mf_scheme.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
     end

     make_integrals = .geminal_mf_scheme.make_integrals
     readin_mos     = .geminal_mf_scheme.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)

       new_n_bf = .geminal_mf_scheme.n_orbitals

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         if(new_n_bf==n_bf)then
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       else

         if(new_n_bf==n_bf)then
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text("Warning: a restart job may failed")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end

     .geminal_mf_scheme.restart_gmf_auto

   end

   read_pauli_block_geminals ::: leaky 
   ! Read in pauli_block_geminals info

   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     .pauli_block_geminals.create
     .pauli_block_geminals.check_spin_multiplicity(.spin_multiplicity)
 !    .pauli_block_geminals.set_defaults(n_geminals=.n_a,n_blocks=.n_a+(.n_bf-.n_a+1)/2,mat_size=.n_bf,mol_name=.name,bra_is_ket=TRUE)
     !.pauli_block_geminals.set_defaults(n_geminals=.n_a,n_blocks=.n_a+(.n_bf-.n_a+1)/2,mat_size=.n_bf,mol_name=.name)
     .pauli_block_geminals.set_defaults(.n_e, .n_bf, .name, .BASE:nuclear_repulsion_energy)
     .pauli_block_geminals.create(.pauli_block_geminals.bra_set.vec,.pauli_block_geminals.n_geminals)
     .pauli_block_geminals.create(.pauli_block_geminals.ket_set.vec,.pauli_block_geminals.n_geminals)
  !   .pauli_block_geminals.bra_set.type_nb.create(.pauli_block_geminals.n_blocks)
  !   .pauli_block_geminals.ket_set.type_nb.create(.pauli_block_geminals.n_blocks)
     .pauli_block_geminals.read_keywords

      if (.pauli_block_geminals.gen_block)  .pauli_block_geminals.initialize_GD2

! davide: 03-10-2019
      if (.pauli_block_geminals.guess_type == "random") .pauli_block_geminals.random_geminals_generator
! de

! davide: 26-10-2018
     .pauli_block_geminals.check_size
     .pauli_block_geminals.check_block_sizes
! de
! davide: 12-11-2018
     .pauli_block_geminals.check_blocks_order
     !.pauli_block_geminals.check_size1_blocks
 !    .pauli_block_geminals.check_nonzero_1ortho_blocks_position
! de
!! davide: 08-11-2018
!     .pauli_block_geminals.check_bra_ket_homogeneity
!! de
! davide: 01-11-2018/03-11-2018
    ! .pauli_block_geminals.check_ortho
    ! .pauli_block_geminals.check_model_constraints
! de
! davide: 30-10-2018
     .pauli_block_geminals.norm_gem
! de
!! davide: 09-11-2018
!     .pauli_block_geminals.prep_nonzero_coef_ind
!! de

     .pauli_block_geminals.set_matrix_form
!     .pauli_block_geminals.make_trace

! davide: 31-10-2018
     .pauli_block_geminals.find_nonzero_coef
! de
! davide: 11-11-2018
     .pauli_block_geminals.make_int_term_list
! de
   end

   do_PBG_calculations ::: leaky 
   ! perform a geminal mean field calculation

   ENSURE(.pauli_block_geminals.created,"no pauli_block_geminals info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     overlap :: REAL
     ham :: REAL
     nb_pauli_blocks,i :: INT
     S_mat :: MAT{REAL}*
!     do_electric_dipole :: BIN
     norm :: REAL
     timer :: TIME
     timer_ov :: TIME
     timer_1rdm :: TIME
     timer_2rdm :: TIME
     timer_ham :: TIME


     n_bf = .n_bf

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

!     do_electric_dipole = any(.pauli_block_geminals.do_electric_dipole)
!     if (do_electric_dipole) then
!        .pauli_block_geminals.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
!     end

     make_integrals =.pauli_block_geminals.make_integrals
     readin_mos     =.pauli_block_geminals.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)
       .pauli_block_geminals.add_core = TRUE

       new_n_bf = .pauli_block_geminals.mat_size
       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         if (new_n_bf==n_bf)then
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end



       else

         if (new_n_bf==n_bf)then
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end

! davide: 19-11-2018

     timer.start_timing
     
     !.pauli_block_geminals.calc_overlap_integral
     timer_ov.start_timing
     ! step 1
     .pauli_block_geminals.calc_overlap_integral(overlap)
     !
     timer_ov.stop_timing
     stdout.show("Time taken (in sec) ov: ",timer_ov.elapsed_time_s,14)
     .pauli_block_geminals.overlap = overlap
     if (NOT .pauli_block_geminals.gen_block) then
     timer_1rdm.start_timing
        ! step 2
        .pauli_block_geminals.calc_1rdm
        !
     timer_1rdm.stop_timing
     stdout.show("Time taken (in sec) 1rdm: ",timer_1rdm.elapsed_time_s,14)
     timer_2rdm.start_timing
        ! step 3
        .pauli_block_geminals.calc_2rdm
        !
     timer_2rdm.stop_timing
     stdout.show("Time taken (in sec) 2rdm: ",timer_2rdm.elapsed_time_s,14)
     else
        ! steps 2 and 3
        .pauli_block_geminals.calc_1rdm_gen
        .pauli_block_geminals.calc_2rdm_gen
        !
     end
     timer_ham.start_timing
     ! step 4
     .pauli_block_geminals.make_hamiltonian(ham) 
     !
     timer_ham.stop_timing
     stdout.show("Time taken (in sec) ham: ",timer_ham.elapsed_time_s,14)
     timer.stop_timing
     stdout.text(" ")
     stdout.show("Time taken (in sec) : ",timer.elapsed_time_s,14)
     stdout.show("Time taken : ",timer.elapsed_time5,8)
     stdout.text(" ")
     stop  

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!     ! generation of a second set of geminals
!     .pauli_block_geminals.destroy_nonzero_coef
!     !
!     .pauli_block_geminals.random_geminals_generator
!     .pauli_block_geminals.norm_gem
!     !
!     stop  
!     .pauli_block_geminals.set_matrix_form
!     .pauli_block_geminals.find_nonzero_coef
!     .pauli_block_geminals.make_int_term_list
!     !.pauli_block_geminals.calc_overlap_integral
!
!     .pauli_block_geminals.calc_overlap_integral(overlap)
!     .pauli_block_geminals.overlap = overlap
!     .pauli_block_geminals.calc_1rdm
!     .pauli_block_geminals.calc_2rdm   
!     .pauli_block_geminals.make_hamiltonian(ham)  
!
!     !stop
!! de
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   end

end
