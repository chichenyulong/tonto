!---------------------------------------------------------------------------
!
! VEC{TABLE_COLUMN}: A list of TABLE_COLUMN
!
! Copyright (C) Dylan Jayatilaka, 2011
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
! 
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
! 
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

module VEC{TABLE_COLUMN}

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create(dim) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Allocate vector
   end

   create(bounds) ::: leaky, PURE
   ! Allocate the vector with lower and upper bounds in "bounds"
      self :: allocatable, OUT
      bounds :: VEC{INT}(2), IN

   ENSURE(bounds(2)>=bounds(1), "upper bound is smaller than lower bound")

#ifdef USE_PRECONDITIONS
      status :: INT
#endif

#ifdef USE_PRECONDITIONS
      allocate(self(bounds(1):bounds(2)),stat=status)
      ENSURE(status==0,"error in allocating memory")
#else
      allocate(self(bounds(1):bounds(2)))
#endif

   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_columns ::: leaky, PURE
   ! Destroy all the columns
      self :: INOUT

      i :: INT

      do i = 1,.dim
         self(i).destroy_column
      end

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: get_from(VEC{OBJECT}), PURE
   ! Set default values
   end

   set_spacing(val) ::: PURE
   ! Set the free space within each column width
      self :: INOUT
      val :: INT, IN

      i :: INT

      do i = 1,.dim
         self(i).set_spacing(val)
      end

   end

!  ===============
!  Inquiry methods
!  ===============

   no_of_rows result (res) ::: PURE
   ! The number of rows in the list of columns. They must all be the
   ! same to avoid an error.
      self :: IN
      res :: INT

   ENSURE(.has_matching_rows,"mismatching column rows")

      res = self(1).n_rows

   end

   has_matching_rows result (res) ::: private, PURE
   ! Check that the number of rows are all the same
      self :: IN
      res :: BIN

      i,n1 :: INT

      ! No. of rows in col 1
      n1 = self(1).n_rows

      ! Check no. of rows
      res = TRUE
      do i = 2,.dim
         if (self(i).n_rows/=n1) then
            res = FALSE
            exit
         end
      end

   end

   dash_width(label_rows) result (res) ::: private, PURE
   ! The length of the dashed line
      self :: IN
      label_rows :: BIN, optional, IN
      res :: INT

      lr,ls :: INT
      row_labels :: BIN

      row_labels = FALSE
      if (present(label_rows)) row_labels = label_rows

      ! Width of first column
      lr = 0
      if (row_labels) then
         lr = .no_of_rows
         lr = lr.str_length + TABLE_COLUMN_SPACING
      end

      ! Width of spacers
      ls = sum(len_trim(.spacer))

      res = sum(.width) + lr + ls

   end

!  =======
!  Methods
!  =======

   put(label_rows,heading_line)
   ! Put out the table of the columns. "label_rows" tells whether
   ! you want the first column to be the row index (default TRUE)
      self :: IN
      label_rows :: BIN, optional, IN
      heading_line :: BIN, optional, IN
      
      row_labels :: BIN

      row_labels = TRUE
      if (present(label_rows)) row_labels = label_rows

      .put_headings(row_labels,heading_line)
      .put_body(row_labels)
      .put_footer(row_labels)

   end

   put_headings(label_rows,heading_line,no_flush)
   ! Put out the column headings/subheadings
      self :: IN
      label_rows   :: BIN, optional, IN
      heading_line :: BIN, optional, IN
      no_flush     :: BIN, optional, IN

      c,lr :: INT
      row_labels,line,flush :: BIN

      row_labels = FALSE
      if (present(label_rows)) row_labels = label_rows

      flush = TRUE
      if (present(no_flush)) flush = NOT no_flush

      line = TRUE
      if (present(heading_line)) line = heading_line

      ! Horizontal line
      if (line) .put_dash(label_rows,"_")

      ! Flush
      stdout.flush

      ! Row label heading as first column?
      lr = 0
      if (row_labels) then
         lr = .no_of_rows
         lr = lr.str_length + TABLE_COLUMN_SPACING
         stdout.put("#",width=lr)
      end

      ! Top heading
      do c = 1,.dim
         self(c).put_heading
      end
      stdout.flush

      ! Any subheadings?
      if (any(.subheading/=" ")) then

         ! Blank first row subheading
         if (row_labels) stdout.put(" ",width=lr)

         ! Do subheadings
         do c = 1,.dim
            self(c).put_subheading
         end
         stdout.flush

      end

      ! Any sb3headings?
      if (any(.sb3heading/=" ")) then

         ! Blank first row subheading
         if (row_labels) stdout.put(" ",width=lr)

         ! Do subheadings
         do c = 1,.dim
            self(c).put_sb3heading
         end
         stdout.flush

      end

      ! Horizontal line
      if (line) .put_dash(label_rows,"_")

      ! Flush
      if (flush) stdout.flush

   end

   put_body(label_rows)
   ! Put out the body of the table (minus header & footer)
      self :: IN
      label_rows :: BIN, optional, IN

      n_rows,lr, r,c :: INT
      row_labels :: BIN

      row_labels = FALSE
      if (present(label_rows)) row_labels = label_rows

      ! No. of rows
      n_rows = .no_of_rows

      ! Row label width (column 1)
      lr = 0
      if (row_labels) then
         lr = n_rows.str_length + TABLE_COLUMN_SPACING
      end

      ! The table body
      do r = 1,n_rows

         if (row_labels) &
            stdout.put(r,width=lr)

         do c = 1,.dim
            self(c).put_value(r)
         end

         stdout.flush

      end

   end

   put_body(tabl,label_rows)
   ! Put out the body of the table (minus header & footer)
   ! and a dove-tailed second "table" ...
      self :: IN
      tabl :: VEC{TABLE_COLUMN}, IN
      label_rows :: BIN, optional, IN

   ENSURE(tabl.dim<=.dim,"2nd table has more cols")

      n_rows,lr, r,c :: INT
      row_labels :: BIN

      row_labels = FALSE
      if (present(label_rows)) row_labels = label_rows

      ! No. of rows
      n_rows = .no_of_rows

      ! Row label width (column 1)
      lr = 0
      if (row_labels) then
         lr = n_rows.str_length + TABLE_COLUMN_SPACING
      end

      ! The table body
      do r = 1,n_rows

         if (row_labels) &
            stdout.put(r,width=lr)

         do c = 1,.dim
            self(c).put_value(r)
         end
         stdout.flush

         do c = 1,tabl.dim
            tabl(c).put_value(r)
         end
         stdout.flush

      end

   end

   put_last_row
   ! Put out the last row of the table (minus header & footer)
   ! Useful for printing tables one row at a time.
      self :: IN

      n_rows,c :: INT

      ! Last row
      n_rows = .no_of_rows

      ! The table body
      do c = 1,.dim
         self(c).put_value(n_rows)
      end
      stdout.flush

   end

   put_footer(label_rows,flush)
   ! Put out the table footer
      self :: IN
      label_rows :: BIN, optional, IN
      flush   :: BIN, optional, IN

      do_flush :: BIN

      .put_dash(label_rows,"_")

      do_flush = FALSE
      if (present(flush)) do_flush = flush

      ! Flush
      if (do_flush) stdout.flush

   end

   put_dash(label_rows,symbol)
   ! Put out a dashed line of the correct length
      self :: IN
      label_rows :: BIN, optional, IN
      symbol :: STR(len=1), optional, IN

      w :: INT

      w = .dash_width(label_rows)
      stdout.dash(symbol,width=w)

   end


   put_log_table(v,tol) ::: leaky
   ! Put table of log10 values in v"; display values smaller than "tol"
      self :: allocatable, INOUT
      v :: VEC{REAL}, IN
      tol :: REAL, IN

   ENSURE(.deallocated,"self is allocated")

      smallest, X_min,X_max,X_bin :: REAL
      n_s,n_n,i,n_sections :: INT
      lg,bin,W :: VEC{REAL}@
      C :: VEC{INT}@
      style :: STR
      table :: VEC{TABLE_COLUMN}@

      smallest = minval(v)
      n_s = count(abs(v) <= tol ) ! small values
      n_n = count(    v  <= ZERO) ! -ve values

      style = stdout.real_style
      stdout.set_real_style("e")
      stdout.show("Minimum value       =", smallest)
      stdout.show("Smallness tolerance =", tol)
      stdout.set_real_style(style)
      stdout.show("No. of small values =", n_s)
      stdout.show("No. of -ve   values =", n_n)

      ! Log eigenvalues
      lg.create(v.dim)
      lg = log10(abs(v))

      ! Range ...
      X_min = floor(minval(lg))
      X_max = ceiling(maxval(lg))
      X_bin = ONE
      n_sections = nint(X_max-X_min)
      if (n_sections<=1) then
      X_bin = 0.25
      n_sections = nint((1-TOL(4))*(X_max-X_min)/X_bin)
      end

      ! Bin values
      bin.create(n_sections)
      bin = [ (X_min + i*X_bin, i=1,n_sections) ]

      ! GOF
      C.create(n_sections)
      W.create(n_sections)
      W.to_histogram_from_data(lg,lg,X_min,X_max,X_bin,C)
      W.destroy

      ! Table
      stdout.flush
      self.create(2)
      self(1).set_heading("log10 |eig|"); table(1).set_values(bin)
      self(1).set_subhead("max. value")
      self(2).set_heading("No. < max");     table(2).set_values(C)

      ! Put
      self.put
      stdout.flush

      ! Clean
      .destroy
      C.destroy
      bin.destroy
      lg.destroy

   end

end
