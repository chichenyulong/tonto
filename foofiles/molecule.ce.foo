!==============================================================================-
!
! MOLECULE.CE: CrystalExplorer related routines
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!==============================================================================-


module MOLECULE.CE

   implicit none

contains

!  ======================
!  Read CIF block options
!  ======================

   read_CX_file_name 
   ! Read the CX file name
      stdin.read(.CX_file_name)
   end

   read_CX_uses_angstrom 
   ! Read whether CX should use angstroms
      stdin.read(.CX_uses_angstrom)
   end

   read_CX_isosurface ::: leaky
   ! Read in special crystalexplorer isosurface data. This only works
   ! if there is a .saved.cluster created . This CX isosurface differs from a normal
   ! isosurface in that the default box sizes for the isosurface are set from
   ! the cluster fragment (as opposed to the .atom list for normal isosurfaces),
   ! and there is a default isosurface kind, which is the "stockholder_density".
   ! NOTE: the isosurface has its own plotgrid, different from that used in 
   ! normal density plots. 

   ENSURE(.saved.associated,"no saved molecule")
   ENSURE(.saved.cluster.associated,"no saved cluster data")
   ENSURE(.saved.cluster.info_made, "no saved cluster info")
   ENSURE(.saved.atom.associated,"no saved atom list")
   ENSURE(.atom.associated,"no atom list")

      if (.isosurface.disassociated) .isosurface.create(.atom)

      .isosurface.plot_grid.set_defaults(.saved.atom)
      .isosurface.plot_grid.n_x = 2**ISOSURFACE_MINIMUM_SCAN_LEVEL + 1
      .isosurface.plot_grid.set_points_widths_origin

      .isosurface.property = "stockholder_weight"  

      !!!!!!!!!!!!!!!!!!!!!!!!!
      .isosurface.read_keywords
      !!!!!!!!!!!!!!!!!!!!!!!!!

      ! Use unit cell as bbox if requested
      if (.isosurface.plot_grid.use_unit_cell_as_bbox) then
         WARN("resetting plot axes, plot widths from unit cell")
         .isosurface.plot_grid.set_bbox_from_unit_cell(.saved.cluster.crystal.unit_cell)
      end

   end

!  =========================
!  Process CIF block options
!  =========================

   process_CIF_for_CX ::: leaky
   ! Process the entire .cif file by reading *all* acceptable data
   ! blocks (i.e. those with crystal and atom information) and then
   ! writing this information to a CE information file. 
   ! NOTE: on termination, this does NOT produce a valid atom list.
   !       For that, use process_CIF
      self :: PTR

   ENSURE(.CX_file_name/=" ","no CX file name")
   ENSURE(.cif.associated,"no CIF object created")
   ENSURE(.cif.file_name/=" ","no CIF file name specified")

      found,CX_uses_angstrom :: BIN
      cif :: CIF*
      CX_file :: TEXTFILE*

      CX_file.create(.CX_file_name)
      CX_file.open_for("write")

      ! Save .cif outside of self, since it gets destroyed
      cif => .cif   
      nullify(.cif)

      do

         ! Find next data block
         .:find_CIF_crystal_data_block(cif,found)

         ! Any data left?
         if (NOT found) exit 

         ! Read and create in from cif (leaky)
         .XTAL:read_CIF_atoms(cif)            
         .XTAL:read_CIF_crystal(cif)

         ! Create the cluster
         .cluster.create(.crystal)
         .cluster.radius = ZERO       
         .cluster.generation_method = "fragment"
         .cluster.defragment = FALSE
         .cluster.make_info                   
         .cluster.put

         ! Write out 
         .:put_CX_data(CX_file,cif)       

         ! Preserve
         CX_uses_angstrom  = .CX_uses_angstrom
         nullify(.cif)

         ! Destroy self (leaky)
         .BASE:destroy                             
         .BASE:create

         ! Next 
         .CX_uses_angstrom = CX_uses_angstrom
         cif.move_to_end_of_data

      end

      ! Clean
      cif.destroy
      CX_file.destroy

   end

   process_CIF_cell_and_symmetry ::: leaky
   ! Process only the cell and spacegroup from the CIF file.
   ! If ".cif.data_block_name" is not defined, use the first
   ! acceptable data block.
      self :: INOUT

   ENSURE(.cif.associated,"no CIF object created")

      ! Find a data block name
      if (.cif.data_block_name==" ") then
         WARN("No CIF data block as specified")
         WARN("Searching for first acceptable data block")
         .:find_CIF_crystal_data_block(.cif)
      end

      ! Find the data block
      ::open_CIF_at_data_block(.cif)
      
      ! Read crystal info
      .XTAL:read_CIF_crystal(.cif) 

   end

   process_CIF ::: leaky
   ! Process a CIF file: read atom and crystal information.
   ! If ".cif.data_block_name" is not defined, use the first
   ! acceptable data block.
      self :: INOUT

   ENSURE(.cif.associated,"no CIF object created")

      ! Find a data block name
      if (.cif.data_block_name==" ") then
      !  WARN("No CIF data block as specified")
      !  WARN("Searching for first acceptable data block")
         .:find_CIF_crystal_data_block(.cif)
      end

      ! Find the data block
      ::open_CIF_at_data_block(.cif)

      ! Read in atoms of asymmetric unit
      .XTAL:read_CIF_atoms(.cif)   
      
      ! Read crystal info
      .XTAL:read_CIF_crystal(.cif) 

      ! Set dispersion coefficients?
    ! if (.atom.associated) then
    ! if (.crystal.xray_data.associated) then
    ! if (.crystal.xray_data.have_set_wavelength) then
    !    .atom.set_dispersion_coefficients(.crystal.xray_data.wavelength)
    ! end
    ! end
    ! end

      ! Make Hirshfeld info
      if (.scfdata.associated) then
      if (.basis_info_made) then
      if (.atom.associated) then
      if (.crystal.data.associated) then
      if (.crystal.data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end
      end
      end

      ! Reset to finalize next time
      .crystal.finalize = TRUE

   end

   find_CIF_crystal_data_block(cif,found) ::: public
   ! Find the *first* crystal data block in the "cif" file
   ! starting from line cif.start_of_data, and set the locator
   ! "cif.data_block_name". The name of the molecule is set to 
   ! the name of the cif file concatenated with the block name.  
      cif :: CIF
      found :: BIN, optional, OUT

   ENSURE(cif.file.associated,"no CIF file name")
   ENSURE(cif.file.name/=" ","no CIF file name")

      fnd :: BIN
      head :: STR

      head  = cif.file.name.filename_head
      .name = head

      if (NOT cif.file.is_open) cif.open

      cif.find_crystal_data_block(fnd)

      if (present(found)) then
         found = fnd
         if (NOT found) return
      else 
         DIE_IF(NOT fnd,"couldn't find crystal data block")
      end

      ! Set job name
      .name = head.trim // "_" &
           // cif.data_block_name 

    ! WARN("Job name has now been set to: "//.name.trim)

   end

   open_CIF_at_data_block(cif) ::: selfless
   ! Open the "cif" file at the block with name "cif.data_block_name".
      cif :: CIF*

   ENSURE(cif.associated,"no CIF object created")
   ENSURE(cif.file_name/=" ","no CIF file name")
   ENSURE(cif.data_block_name/=" ","no CIF data block name")

      name :: STR

      cif.open

      ! Store: cif.data_block_name is trashed
      name = cif.data_block_name 
      cif.find_data_block(name)

   end

!  ======================
!  New cluster operations
!  ======================

   defragment ::: leaky
   ! Defragment the current atom list, assuming it is read in from CIF
   ! file and may consist of just an asymmetric unit.
      self :: INOUT

   ENSURE(.cif.associated,"no CIF info")
   ENSURE(.crystal.associated,"no crystal")

      ! Defragment any molecules in the CIF
      .crystal.set_generation_method("fragment")
      .crystal.set_radius(ZERO)
      .crystal.set_defragment(TRUE)
      .crystal.make_info

      ! Reset .atom list to the .crystal.geometry
      .atom.destroy
      .crystal.create_atom_list(.atom)

      ! Finalize atom info/bases
      .atom_info_made = FALSE
      .:finalize_atoms

   end

   finalize_atoms ::: leaky
   ! Read in the atom list information
      self :: INOUT

      ! Finalize atom info/basis sets
      .BASE:set_atom_info
      .BASE:finalize_atom_groups
      .BASE:resolve_basis_info

      ! Finalize crystal
      if (associated(.crystal)) then
         .BASE:resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

      ! Make Hirshfeld info
      if (.scfdata.associated) then
      if (.basis_info_made) then
      if (.crystal.associated) then
      if (.crystal.xray_data.associated) then
      if (.crystal.xray_data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end
      end
      end

      ! Destroy stored atoms here
      .isosurface.destroy

   end

!  ===
!  Put
!  ===

   put_CX_data
   ! Output information that Crystal Explorer requires to the file 
   ! with name ".CX_file_name".
      .:put_CX_data(.cif)
   end

   serialize_isosurface_sbf 
   ! Dump sbf file 
      .:serialize_isosurface_sbf(.cif)
   end

   put_CX_data(cif)
   ! Output information that Crystal Explorer requires to the file 
   ! with name ".CX_file_name".
      cif :: CIF*

      CX_file :: TEXTFILE*

      if (.CX_file_name/=" ") then

         CX_file.create(.CX_file_name)
         CX_file.open_for("write")
         .:put_CX_data(CX_file,cif)
         CX_file.close
         CX_file.destroy

      else

         .:put_CX_data(TEXTFILE::stdout,cif)

      end

   end

   serialize_isosurface_sbf(cif)
   ! Output information that Crystal Explorer requires to the file 
   ! with name ".CX_file_name".
      cif :: CIF*

      if(.CX_file_name /= " ") then
         .:serialize_isosurface_sbf(trim(.CX_file_name), cif)
      else
         .:serialize_isosurface_sbf(trim(.name)//"-hs.sbf", cif)
      end if

   end


   put_CX_data(CX_file,cif)
   ! Output information that Crystal Explorer requires to file "CX_file".
   ! NOTE: this requires a "cif" file to have been read, and a valid data block
   ! name to be stored in the "cif" object.
      CX_file :: TEXTFILE*
      cif :: CIF*

 ! ENSURE(cif.associated,"no CIF object created")
 ! ENSURE(cif.data_block_name/=" ","no CIF data block name")

      save :: TEXTFILE*
      CX_label,CX_name,formula,spacegroup :: STR
      done :: BIN

      if (cif.associated) then
         CX_name  = cif.file_name
         CX_label = cif.data_block_name
      else
         CX_name  = "unknown"
         CX_label = "unknown"
      end

      stdout.flush
      stdout.text("Writing Crystal Explorer data file: " // CX_file.name.trim)
      stdout.flush

      ! Redirect stdout to out
      save   => TEXTFILE::stdout                      
      stdout => CX_file

      ! Reset output format
      stdout.save
      stdout.set_int_width(7)
      stdout.set_real_style("f")
      stdout.set_real_precision(5)
      stdout.set_real_width(12)
      stdout.set_using_fields(FALSE)

      stdout.flush
      stdout.text("Crystal Explorer data")

      stdout.flush
      stdout.show("begin CIF ",CX_label,dots=FALSE)
      stdout.show("file_name =",CX_name,dots=FALSE)
      stdout.show("data_block_name =",CX_label,dots=FALSE)
      stdout.text("end CIF")
      stdout.flush

      ! Crystal data and cluster/fragment positions
      ! Try saved cluster first
      done = FALSE
      if (.saved.associated) then
      if (.saved.cluster.associated) then

         ENSURE(.saved.cluster.info_made,"no cluster information")
         ENSURE(.saved.cluster.crystal.associated,"no cluster crystal data")
         ENSURE(.saved.cluster.n_fragment_atoms>0,"no fragment size")

         formula    = .saved.cluster.crystal.CIF_chemical_formula
         spacegroup = .saved.cluster.crystal.spacegroup.HM_symbol

         stdout.show("begin crystal ",CX_label,dots=FALSE)
         .saved.cluster.crystal.put_CX(CX_label,formula,spacegroup) 
         .saved.cluster.put_CX(angstrom=.CX_uses_angstrom)
         stdout.flush
         stdout.text("end crystal")

         done = TRUE

      end
      end

      ! Try normal cluster
      if (NOT done) then
      if (.cluster.associated) then

         ENSURE(.cluster.info_made,"no cluster information")
         ENSURE(.cluster.crystal.associated,"no cluster crystal data")
         ENSURE(.cluster.n_fragment_atoms>0,"no fragment size")

         formula    = .cluster.crystal.CIF_chemical_formula
         spacegroup = .cluster.crystal.spacegroup.HM_symbol

         stdout.show("begin crystal ",CX_label,dots=FALSE)
         .cluster.crystal.put_CX(CX_label,formula,spacegroup) 
         .cluster.put_CX(angstrom=.CX_uses_angstrom)
         stdout.flush
         stdout.text("end crystal")

         done = TRUE

      end
      end

      ! Finally try .crystal and .atom
      if (NOT done) then
      if (.crystal.associated AND .atom.associated) then

         formula    = .crystal.CIF_chemical_formula
         spacegroup = .crystal.spacegroup.HM_symbol

         stdout.show("begin crystal ",CX_label)
         .crystal.put_CX(CX_label,formula,spacegroup) 
         .atom.put_CX(CX_label,angstrom=.CX_uses_angstrom)
         stdout.flush
         stdout.text("end crystal")

         done = TRUE

      end
      end

      ! Isosurface information
      if (.isosurface.associated) then
      if (.isosurface.atom.associated) then 

      ! Try saved cluster first
      done = FALSE
      if (.saved.associated) then
      if (.saved.cluster.associated) then

         stdout.flush
         stdout.show("begin surface ",.isosurface.surface_label.trim,dots=FALSE)
         .isosurface.put_CX(.saved.cluster.fragment_atom_indices &
                           ,.saved.cluster.nonfragment_atom_indices &
                           ,.atom &
                           ,angstrom=.CX_uses_angstrom)
         .saved.cluster.put_CX_atoms
         .isosurface.put_fingerprint_face_atoms(.saved.cluster.fragment_atom_indices &
                           ,.saved.cluster.nonfragment_atom_indices)
         stdout.text("end surface")

         done = TRUE

      end
      end

      ! Try normal cluster
      if (NOT done) then
      if (.cluster.associated) then
         DIE("should we be here?")
         done = TRUE
      end
      end

      ! Finally try isosurface only
      if (NOT done) then
         DIE("should we be here?")
         done = TRUE
      end

      end
      end

      ! Put back stdout
      stdout.unsave
      stdout => save                        

   end

   serialize_isosurface_sbf(filename, cif)
   ! Output information that Crystal Explorer requires to file "CX_file".
   ! NOTE: this requires a "cif" file to have been read, and a valid data block
   ! name to be stored in the "cif" object.
      filename :: STR
      cif :: CIF*
      datafile :: DATAFILE
      CX_label,CX_name :: STR
      points, normals :: MAT{REAL}*
      values,d_e,d_i,d_norm_e,d_norm_i,d_norm,si,cn :: VEC{REAL}*
      d_e_atoms, d_i_atoms :: VEC{INT}*
      atoms_inside, atoms_outside :: MAT{INT}*
      done,has_curvatures :: BIN

      if (cif.associated) then
         CX_name  = cif.file_name
         CX_label = cif.data_block_name
      else
         CX_name  = "unknown"
         CX_label = "unknown"
      end

      stdout.flush
      stdout.text("Writing Crystal Explorer data file: " // filename.trim)
      stdout.flush

      datafile.open(filename)

      ! Isosurface information
      if (.isosurface.associated) then
      if (.isosurface.atom.associated) then 

      ! Try saved cluster first
      done = FALSE
      if (.saved.associated) then
      if (.saved.cluster.associated) then

         points.create_copy(.isosurface.point)
         points = points*ANGSTROM_PER_BOHR
         call datafile%sbf%add_dataset(sbf_Dataset("vertices", points))
         points.destroy

         call datafile%sbf%add_dataset(sbf_Dataset("faces", .isosurface.face))

         normals.create(3,.isosurface.n_pt)
         .isosurface.make_vertex_normals(normals)
         call datafile%sbf%add_dataset(sbf_Dataset("vertex normals", normals))
         normals.destroy

         ! d_i, d_norm_i, d_e, d_norm_e and d_norm
         d_i.create(.isosurface.n_pt)
         d_e.create(.isosurface.n_pt)
         d_norm_i.create(.isosurface.n_pt)
         d_norm_e.create(.isosurface.n_pt)
         d_norm.create(.isosurface.n_pt)
         .isosurface.make_fingerprint_distances(d_e,d_i,d_norm_e &
                                                ,d_norm_i,d_norm &
                                                ,.saved.cluster.fragment_atom_indices &
                                                ,.saved.cluster.nonfragment_atom_indices &
                                                ,.atom,TRUE)

         ! Print it out
         call datafile%sbf%add_dataset(sbf_Dataset("d_i",d_i))
         call datafile%sbf%add_dataset(sbf_Dataset("d_e",d_e))
         call datafile%sbf%add_dataset(sbf_Dataset("d_norm_i",d_norm_i))
         call datafile%sbf%add_dataset(sbf_Dataset("d_norm_e",d_norm_e))
         call datafile%sbf%add_dataset(sbf_Dataset("d_norm",d_norm))

         ! Clean
         d_norm.destroy
         d_norm_e.destroy
         d_norm_i.destroy
         d_e.destroy
         d_i.destroy

         ! Shape index and curvedness
         has_curvatures = .isosurface.point_mean_curvature.associated &
                     AND  .isosurface.point_gaussian_curvature.associated
         if (.isosurface.CX_output_shape_properties AND has_curvatures) then
            si.create(.isosurface.n_pt)
            cn.create(.isosurface.n_pt)
            .isosurface.make_vertex_SI_and_curvedness(si,cn)
            call datafile%sbf%add_dataset(sbf_Dataset("shape_index",si))
            call datafile%sbf%add_dataset(sbf_Dataset("curvedness",cn))
            cn.destroy
            si.destroy
         end

         ! User-requested property?
         if (.isosurface.surface_property_values.associated) then
            ! Create a copy of property
            values.create_copy(.isosurface.surface_property_values)
            ! Chop it if requested
            if (.isosurface.surface_property_lb_set) values.chop_small_values(.isosurface.surface_property_lb)
            if (.isosurface.surface_property_ub_set) values.chop_large_values(.isosurface.surface_property_ub)
            ! Put out the surface property values
            call datafile%sbf%add_dataset(sbf_Dataset(trim(.isosurface.surface_property),values))
            values.destroy
         end

         if (.isosurface.surface_iso_values.associated) then
            call datafile%sbf%add_dataset(sbf_Dataset(trim(.isosurface.property),.isosurface.surface_iso_values))
         end


         atoms_outside => NULL()
         atoms_inside => NULL()
         .saved.cluster.make_CX_atoms(atoms_inside, atoms_outside)
         call datafile%sbf%add_dataset(sbf_Dataset("atoms_inside_surface",atoms_inside))
         if (atoms_outside.associated) call datafile%sbf%add_dataset(sbf_Dataset("atoms_outside_surface",atoms_outside))

         d_i_atoms.create(.isosurface.n_face)
         d_e_atoms.create(.isosurface.n_face)
         .isosurface.make_fingerprint_face_atoms(d_e_atoms,d_i_atoms &
                                                ,.saved.cluster.fragment_atom_indices &
                                                ,.saved.cluster.nonfragment_atom_indices)
         call datafile%sbf%add_dataset(sbf_Dataset("d_i_atoms",d_i_atoms))
         call datafile%sbf%add_dataset(sbf_Dataset("d_e_atoms",d_e_atoms))
         d_e_atoms.destroy
         d_i_atoms.destroy

         done = TRUE
      end
      end

      end
      end

      !call datafile%sbf%add_dataset(sbf_Dataset("cif_filename", trim(CX_name)))
      !call datafile%sbf%add_dataset(sbf_Dataset("data_block_name", trim(CX_label)))
      call datafile%sbf%serialize
      datafile.close

   end

    make_monomer_energies_for_lattice_energy result(res)
        self :: PTR
        res :: VEC{REAL}(4) ! E_en, E_1e, E_ee, E_ex

        J, K, saved_MOs :: OPMATRIX*
        exchange_factor = -HALF :: REAL

        saved_MOs => .molecular_orbitals
        .INTS:make_overlap_matrix
        .SCF:make_core_matrix
        .BASE:make_natural_orbitals
        ! Make integrals
        .molecular_orbitals => .natural_orbitals
        .BASE:make_scf_density_matrix
        .SCF:make_core_matrix
        .nuclear_attraction_matrix.uncompress
        if (.scfdata.is_restricted) then
            exchange_factor = -QUARTER
        end if



        res(1) = .BASE:expectation(.nuclear_attraction_matrix)
        res(2) = .BASE:expectation(.core_matrix)
        J.create(.n_bf, .density_matrix.spinorbital_kind)
        K.create(.n_bf, .density_matrix.spinorbital_kind)
        .FOCK:make_JK_engine(J, K, .density_matrix)
        res(3) = .BASE:expectation(J) * HALF
        res(4) = .BASE:expectation(K) * exchange_factor
        res = -TWO * res
        J.destroy
        K.destroy
        .molecular_orbitals => saved_MOs
    end



    total_lattice_energy
   ! calculate the total lattice energy for this molecule cluster
      self :: PTR

      a,n,i,j,k :: INT
      n_molecules :: INT
      position, separation :: VEC{REAL}(3)
      E, E_tot :: VEC{REAL}(4) ! [ ele, rep, pol, disp ] 
      rot :: MAT{REAL}(3,3)
      t, t_symop :: VEC{REAL}(3)
      unique_symops :: VEC{INT}*
      central_atoms :: VEC{ATOM}@
      monomer_energies :: VEC{REAL}(4) ! E_ele, E_rep
      frac_radius, offset :: VEC{REAL}(3)
      h_min, h_max, prev_h_min, prev_h_max :: VEC{INT}(3)
      occupied_pos :: MAT{REAL}*
      radius, prev_radius, delta, e_iter, e_prev, dist :: REAL
      equivalent :: BIN
      timer, timer_12 :: TIME
      symop_strings :: VEC{STR}*
      time_in_qm :: REAL
      new_mols, cells_skipped :: INT
      wavefunction_filename :: STR
      uc_count :: MAT3{INT}(-10:10,-10:10,-10:10)
      n_iter, n_symops :: INT
      all_atoms :: VEC{ATOM}*
      molecule_bounds :: MAT{REAL}(3,2)
      positions_frac :: MAT{REAL}@
      pair_energies :: VEC{PAIR_ENERGY}*
      p_e :: PAIR_ENERGY

      mol1 :: MOLECULE*
      mol2 :: MOLECULE*


      E = 0
      E_tot = 0
      wavefunction_filename = "urea.fchk"

    ! Central fragment wavefunction stuff
      mol1.BASE:create
      !mol1.BASE:read_g09_FChk_file(trim(wavefunction_filename))
      mol1.scfdata.create_copy(.scfdata)
      mol1.name = trim(.cif.data_block_name)
      .cluster.create_mol_atom_list(mol1.atom, 1)
      central_atoms = mol1.atom

      mol1.BASE:set_atom_info
      mol1.BASE:finalize_atom_groups
      mol1.BASE:resolve_basis_info
      mol1.BASE:set_basis_name(.basis_name)
      mol1.atom.put

      mol1.SCF:make_ANO_data
      !! Do the SCF
      timer.start_timing
      mol1.scfdata.set_output(TRUE)
      mol1.SCF:scf
      mol1.scfdata.set_output(FALSE)
      timer.stop_timing
      stdout.show("time taken for SCF (s) = ", timer.elapsed_time_s)

      !! Make monomer energies and multipoles
      monomer_energies  = mol1.:make_monomer_energies_for_lattice_energy
      mol1.BASE:make_atomic_multipoles

      unique_symops.create_copy(.crystal.asym_symop_for_unit_cell_atom.unique_elements)
      stdout.show("Num unique symops        =", unique_symops)
      n_symops = unique_symops.dim
      symop_strings.create(n_symops)

      do i = 1, n_symops
        .crystal.spacegroup.recode_Jones_Faithful_symbol(symop_strings(i), &
            .crystal.spacegroup.seitz(:,:, unique_symops(i)))
        stdout.show(unique_symops(i).to_str, symop_strings(i))
      end do

      ! calculate how many unit cells we'll need to look in
#define MAX_SEARCH_RADIUS 60.0d0
#define CONVERGENCE_TOLERANCE  0.4
      ! kJ/mol

    ! position of molecule
    occupied_pos.create(3, 1)
    occupied_pos(:, 1) = mol1.atom.center_of_mass
    
    offset = mol1.atom.center_of_mass
    n_iter = 0
    n_molecules = 0
    stdout.text("Starting lattice energy calculation")
    timer.start_timing
    radius = 11.34 ! Roughly 6 angstrom
    e_prev = ZERO
    e_iter = ZERO
    delta = INT_HUGE
    prev_h_min = 0
    prev_h_max = 0
    prev_radius = 0
    time_in_qm = ZERO


    ! keep track of how many molecules in each uc we've added
    uc_count = 0
    cells_skipped = 0
    allocate(positions_frac(3, central_atoms.dim1))
    do i = 1, central_atoms.dim1
        positions_frac(:, i) = central_atoms(i).position
    end do
    positions_frac = matmul(.crystal.unit_cell.inverse_matrix, positions_frac)

    ! min and max fractional coord of molecule
    molecule_bounds(:, 1) = minval(positions_frac, dim=2)
    molecule_bounds(:, 2) = maxval(positions_frac, dim=2)
    deallocate(positions_frac)

    radius = VEC{REAL}:norm(&
        matmul(.crystal.unit_cell.direct_matrix, &
               molecule_bounds(:,2) - molecule_bounds(:,1)))

    radius = min(radius, 13.60) ! 7.2 Angstroms

    stdout.show("Radius", radius * ANGSTROM_PER_BOHR)
    stdout.show("molecule_bounds(:,1)", molecule_bounds(:,1))
    stdout.show("molecule_bounds(:,2)", molecule_bounds(:,2))

    if(.scfdata.scf_kind == "rks") then
        VEC{PAIR_ENERGY}:set_energy_model("ce-b3lyp")
    else
        VEC{PAIR_ENERGY}:set_energy_model("ce-hf")
    end if
    pair_energies.create(0)

    do while (abs(delta) > CONVERGENCE_TOLERANCE)
        e_prev = e_iter
        new_mols = 0

        frac_radius = radius /.cluster.crystal.unit_cell.length
        stdout.show("frac_radius", frac_radius)
        h_max = ceiling(frac_radius + molecule_bounds(:, 2))
        h_min = floor(-frac_radius + molecule_bounds(:, 1))

        h_max = max(h_max, [1,1,1])
        h_max = min(h_max, [10, 10, 10])
        h_min = min(h_min, [-1,-1,-1])
        h_min = max(h_min, [-10, -10, -10])
        ! only search a maximum of 20 unit cells
        n_iter = n_iter + 1
        stdout.show("Iteration", n_iter)
        stdout.show("Within radius (angstroms)", radius * ANGSTROM_PER_BOHR)
        stdout.show("h_min", h_min)
        stdout.show("h_max", h_max)

        !all_atoms.create_copy(central_atoms)
        do n = 1, n_symops
            stdout.show("Symop "//trim(n.to_str)//"/"//trim(n_symops.to_str), symop_strings(n))
            ! convert to cartesian space
            rot = .crystal.spacegroup.seitz(1:3, 1:3, unique_symops(n))
            rot = matmul(rot, .crystal.unit_cell.inverse_matrix)
            rot = matmul(.crystal.unit_cell.direct_matrix, rot)
            t_symop = .crystal.spacegroup.seitz(1:3, 4, unique_symops(n))

            mol2.BASE:create
            mol2.scfdata.create_copy(mol1.scfdata)
            mol2.atom.create_copy(central_atoms)
            mol2.density_matrix.create_copy(mol1.density_matrix)
            mol2.molecular_orbitals.create_copy(mol1.molecular_orbitals)
            mol2.BASE:set_atom_info
            mol2.BASE:finalize_atom_groups
            mol2.BASE:resolve_basis_info
            mol2.BASE:set_basis_name(.basis_name)
            mol2.BASE:rotate_by(rot)
            mol2.INTS:make_overlap_matrix
            mol2.BASE:make_natural_orbitals
            mol2.BASE:make_atomic_multipoles

            !loop over unit cells
            do i = h_min(1),h_max(1)
                ! don't search the same unit cells too many times
                if (all(uc_count(i,:,:) >= n_symops)) then
                    cells_skipped = cells_skipped + (h_max(2) - h_min(2) + 1) * (h_max(3) - h_min(3) + 1)
                    cycle
                end
            do j = h_min(2),h_max(2)
                if (all(uc_count(i,j,:) >= n_symops)) then
                    cells_skipped = cells_skipped + (h_max(3) - h_min(3) + 1)
                    cycle
                end
            do k = h_min(3),h_max(3)
                if (uc_count(i,j,k) >= n_symops) then
                    cells_skipped = cells_skipped + 1
                    cycle
                end

                ! get translation for this unit cell
                t = matmul(.crystal.unit_cell.direct_matrix, t_symop + [i, j, k])
                p_e.set_defaults

                mol2.atom.translate_by(t)
                position = mol2.atom.center_of_mass
                separation = position - offset
                mol2.atom.get_distance_to(mol1.atom, dist)
                ! Check if this molecule is within the radius
                if(dist > radius OR dist <= prev_radius) then
                    mol2.atom.translate_by(-t)
                    cycle
                end if

                ! Check if we already have molecule here
                ! This is needed as some symops + unit cell
                ! translations are redundant
                ! and we might be searching the same unit cell twice
                equivalent = FALSE
                do a = 1, occupied_pos.dim2
                    if (occupied_pos(:, a).distance_to(position) < 0.1) then
                        equivalent = TRUE
                        mol2.atom.translate_by(-t)
                        stdout.text("Redundant molecule discarded")
                        stdout.show("Symop", symop_strings(n))
                        stdout.show("Separation", separation.norm)
                        exit
                    end if
                end do
                if(equivalent) cycle

                occupied_pos.append_column(position)
                uc_count(i,j,k) = uc_count(i,j,k) + 1

                !all_atoms.append(mol2.atom)
                p_e.set_center_separation(separation.norm)
                p_e.set_closest_distance(dist)
                p_e.set_symop_id(n)
                p_e.set_symop_str(symop_strings(n))

                ! There has to be a better way to do this, but this works for now
                ! and eliminates most redundant calculations
                ! If we have already calculated these energies, continue and
                ! increment the counter
                n_molecules = n_molecules + 1
                a = pair_energies.equivalent_pair(p_e)
                equivalent = (a > 0)
                if (equivalent) then
                    pair_energies(a).increment_count
                    mol2.atom.translate_by(-t)
                    cycle
                end

                ! If we have a unique molecule pair calculate the energies
                E = ZERO
                ! Disp
                E(3) = mol1.PROP:intermolecular_polarization_energy(mol2)
                E(4) = mol1.atom.Grimme06_dispersion_energy(mol2.atom)
                timer_12.start_timing
                E(1:2) = mol1.PROP:symmetric_intermolecular_qm_energies(mol2, monomer_energies)
                timer_12.stop_timing
                time_in_qm = time_in_qm + timer_12.elapsed_time_s

                p_e.set_energy_components(E)
                pair_energies.append(p_e.clone)
                new_mols = new_mols + 1
                stdout.show("New molecule ", new_mols)
                mol2.atom.translate_by(-t)
            end
            end
            end

            mol2.BASE:destroy
          end 

          e_iter = pair_energies.total_energy(scaled=FALSE)
          delta = e_iter - e_prev
          pair_energies.put_lattice_energy_table
          stdout.show("Cells skipped", cells_skipped)
          stdout.show("Energy change ", delta)
          stdout.show("New molecules ", new_mols)
          stdout.show("Total molecules", n_molecules)
          prev_h_min = h_min
          prev_h_max = h_max
          prev_radius = radius
          radius = radius + 7.2
          if (radius > MAX_SEARCH_RADIUS) then
              stdout.text("No convergence achieved, max search radius exceeded")
              stdout.show("Max search radius", MAX_SEARCH_RADIUS)
              exit
          end
          !all_atoms.put_xyz_file(trim(.name)//trim(n_iter.to_str))
          !all_atoms.destroy
      end do
#undef CONVERGENCE_TOLERANCE
#undef MAX_SEARCH_RADIUS

      timer.stop_timing
      stdout.show("time taken for Symmetry related mols (s) = ", timer.elapsed_time_s)
      stdout.show("time taken for E_ele + E_rep (s) = ", time_in_qm)
      pair_energies.put_lattice_energy_table

   end


end
