!-------------------------------------------------------------------------------
!
! SHELL: used to describe contracted cartesian gaussian shells.
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module SHELL

   implicit none

   keys :: VEC{STR}@, private

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

!  ===========
!  Set methods
!  ===========

   set(object) ::: get_from(OBJECT)
   ! Set the object. Pointer parts are assigned not copied.
   end

   set_l(l) ::: template, PURE
   ! Set the l value
      self :: INOUT
      l :: INT, IN

      .l              = l
      .l_chr          = GAUSSIAN_DATA:l_chr(l)
      .first_gaussian = GAUSSIAN_DATA:n_comp_up_to(l-1) + 1
      .last_gaussian  = GAUSSIAN_DATA:n_comp_up_to(l)

      .set_n_sph

   end

   set_l(l) ::: get_from(SHELL), PURE
   ! Set the l value
   end

   set_n_sph ::: template
   ! Set the number of spherical components & basis functions
      self :: INOUT

      .n_sph = 2*.l + 1

      if (.is_spherical) then; .n_bf = .n_sph
      else;                    .n_bf = .n_comp
      end

   end

   set_n_sph ::: get_from(SHELL), pure
   ! Set the number of spherical components & basis functions
   end

   set_spherical(val) ::: template
   ! Set sphericals to "val"
      self :: INOUT
      val :: BIN, IN

      .is_spherical = val

      .set_n_sph

   end

   set_spherical(val) ::: get_from(SHELL), pure
   ! Set sphericals to "val"
   end

!  ============
!  I/O Routines
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the
   ! "keyword" is inputted from "stdin".
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}            "); ! exit surrounding loop
         case ("contractions="); .read_contractions
         case ("exponents=   "); .read_exponents
         case ("ex,cc=       "); .read_ex_cc
         case ("junk=        "); .read_junk
         case ("junk,ex,cc=  "); .read_junk_ex_cc
         case ("l=           "); .read_l
         case ("l_chr=       "); .read_l_chr
         case ("n_cc=        "); .read_n_cc
         case ("put          "); .put
         case ("spherical=   "); .read_spherical
         case ("units=       "); .read_units
         case default;           UNKNOWN(word)
      end

   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_l ::: get_from(GAUSSIAN)
   ! Read in the l symbol
   end

   read_l_int ::: get_from(GAUSSIAN), private
   ! Read in the l integer
   end

   read_l_chr ::: get_from(GAUSSIAN),, private
   ! Read in the l character
   end

   read_spherical
   ! Read in if this is a spherical shell
      self :: INOUT

      stdin.read(.is_spherical)

   end

   read_n_cc
   ! Read in the number of contraction coefficients
      self :: INOUT

      stdin.read(.n_cc)

   ENSURE(.n_cc>0,"n_cc must be positive")

   end

   read_exponents ::: leaky
   ! Read in the exponents
      self :: INOUT

   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.exponent.deallocated,"ex already entered")

      .exponent.create(.n_cc)
      stdin.read(.exponent)

   end

   read_contractions ::: leaky
   ! Read in the contraction coefficients
      self :: INOUT

   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.contraction.deallocated,"cc already entered")


      .contraction.destroy
      .contraction.create(.n_cc)

      stdin.read(.contraction)

   end

   read_ex_cc ::: leaky
   ! Read in the exponents and contractions
      self :: INOUT

   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.exponent.deallocated,"ex already entered")
   ENSURE(.contraction.deallocated,"ex already entered")

      .contraction.destroy
      .exponent.destroy

      .exponent.create(.n_cc)
      .contraction.create(.n_cc)

      stdin.read_pair(.exponent,.contraction)

   end

   read_junk_ex_cc ::: leaky
   ! Read in the exponents and contractions preceded by a junk string
      self :: INOUT

   ENSURE(.n_cc>0,"n_cc must be entered first")
   ENSURE(.exponent.deallocated,"ex already entered")
   ENSURE(.contraction.deallocated,"ex already entered")

      i :: INT

      .contraction.destroy
      .exponent.destroy

      .exponent.create(.n_cc)
      .contraction.create(.n_cc)

      do i = 1,.n_cc
         stdin.skip_next_item
         stdin.read(.exponent(i))
         stdin.read(.contraction(i))
      end

   end

!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

!  =====================
!  Miscellaneous methods
!  =====================

   xyz_basis_fn_part result (res) ::: get_from(GAUSSIAN), PURE
   ! Return a character representation for the cartesian
   ! product part of the gaussians in this shell.
   end

   same_as(sh) result(same) ::: pure
   ! Return TRUE if the shell "self" is the same as "sh".
      self :: IN
      sh :: SHELL, IN
      same :: BIN

      ! Check if basic arrays are created identically
      same = .l_chr==sh.l_chr &
         AND (.is_spherical          EQV sh.is_spherical) &
         AND (.exponent.allocated      EQV sh.exponent.allocated) &
         AND (.contraction.allocated   EQV sh.contraction.allocated) 

      ! If not, we are done
      if (NOT same) return

      ! Check exponents
      if (.exponent.allocated AND sh.exponent.allocated) same = .exponent.same_as(sh.exponent) 
      if (NOT same) return

      ! Check contractions ...
      if (.contraction.allocated AND sh.contraction.allocated)   same = .contraction.same_as(sh.contraction) 

   end

!  ============
!  Contractions
!  ============

   make_contraction_matrix(ccm) ::: PURE
   ! Return the contraction coefficient matrix "ccm" which converts
   ! primitives to basis functions. It is with respect to uniform
   ! normalisation i.e. all components are normalised to the first
   ! component, x^l. 
      self :: IN
      ccm :: MAT{REAL}, OUT

   ENSURE(ccm.dim1==.n_prim,"wrong 1st dimension, ccm")
   ENSURE(ccm.dim2==.n_comp,"wrong 2nd dimension, ccm")
   ENSURE(.l_chr/="L","must not be an L=S+P shell")
   ENSURE(.n_cc>0,"no contraction coefficients")
   ENSURE(.contraction.allocated,"no contraction coefficients")

      b,p,i :: INT

      do b = 1,.n_comp       ! do over basis components
         p = b               ! primitive p
         do i = 1,.n_cc      ! do over contractions
            ccm(p,b) = .contraction(i)
            p = p + .n_comp
         end
      end

   end

   make_normalised_contraction_mx(ccm,sph) ::: PURE
   ! Return the contraction coefficient matrix "ccm". All the
   ! primitives are assumed correctly normalised.
      self :: IN
      ccm :: MAT{REAL}, OUT
      sph :: BIN, optional, IN

   ENSURE(.n_cc>0,"no contraction coefficients")
   ENSURE(.contraction.allocated,"no contraction coefficients")

      b,p,i,nc :: INT
      is_sph :: BIN

      is_sph = FALSE
      if(present(sph)) is_sph = sph

      if (is_sph) then
        ENSURE(ccm.dim1==.n_sph_prim,"wrong 1st dimension, ccm")
        ENSURE(ccm.dim2==.n_sph,"wrong 2nd dimension, ccm")
        nc = .n_sph
      else
        ENSURE(ccm.dim1==.n_prim,"wrong 1st dimension, ccm")
        ENSURE(ccm.dim2==.n_comp,"wrong 2nd dimension, ccm")
        nc = .n_comp
      end

      do b = 1,.n_comp       ! do over basis components
         p = b               ! primitive p
         do i = 1,.n_cc      ! do over contractions
            ccm(p,b) = .contraction(i)
            p = p + nc
         end
      end

   end

!  =============
!  Normalization
!  =============

   norm result (res) ::: pure
   ! Return the norm of the shell, assuming that the existing contraction
   ! coefficients are with respect to NORMALISED primitive gaussians.
      self :: IN
      res :: REAL

      i,j :: INT
      sm,a,b,ab :: REAL

      sm = ZERO

      do i = 1,.n_cc

         a = .exponent(i)

         do j = 1,i-1

            b  = .exponent(j)
            ab = TWO*sqrt(a*b)/(a+b);

            sm = sm + TWO*.contraction(i)*.contraction(j)*ab**(.l+ONE+HALF);

         end

         ! This is the normalised diagonal term
         sm = sm + .contraction(i)*.contraction(i) 

      end

      res = sqrt(sm) * ((TWO*PI)**(THREE/FOUR))

   end

   unnormalise ::: pure
   ! Assuming the existing contraction coefficients are initially with respect
   ! to NORMALISED primitive gaussians, take out this normalisation factor of
   ! each primitive and put it in the contraction coefficient. The normalisation
   ! factor removed is the one appropriate for the cartesian component x^l.
   ! NOTE: It is up to you to correct this factor with appropriate double
   ! factorial square roots for other components. The factor should be: 
   !   fac = 1/sqrt(df(nx)*df(ny)*df(nz))
   ! where nx,ny,nz are the cartesian powers of the basis component
       self :: INOUT

       .contraction(:) = .contraction(:) &
                * (FOUR*.exponent(:))**(HALF*.l+HALF+QUARTER) &
                * (ONE/(.norm*sqrt(.l.double_factorial)))

   end

   renormalise ::: pure
   ! Assuming the existing contraction coefficients are with respect to raw
   ! UNNORMALISED primitive gaussians, put back this normalisation factor for
   ! each primitive gaussian, by removing this factor from from the contraction
   ! coefficients. The result will be contraction coefficients relative to
   ! normalised primitive gausian. This will undo routine "unnormalise" routine
   ! above.  The ((TWO*PI)**(THREE/FOUR)) / .norm factor is supposed to make the
   ! contraction coefficient equal to 1 for a shell with one primitive i.e. the
   ! shell is not *really* normalised. This seems to be the usual convention.
      self :: INOUT

      .contraction(:) = .contraction(:) / ((FOUR*.exponent(:))**(HALF*.l+HALF+QUARTER)) 
      .contraction(:) = .contraction(:) * ((TWO*PI)**(THREE/FOUR)) / .norm

   end

!  =================
!  No. of primitives
!  =================

   n_prim result (res) ::: pure
   ! Return the number of primitive gaussians in the shell
      self :: IN
      res :: INT
      res = .n_comp*.n_cc
   end

   n_sph_prim result (res) ::: pure
   ! Return the number of primitive gaussians in the shell
      self :: IN
      res :: INT
      res = .n_sph*.n_cc
   end

!  =======
!  Cutoffs
!  =======

   r_max(cutoff) result (res) ::: pure
   ! Return the radius where all basis functions becomes smaller than "cutoff".
      self :: IN
      cutoff :: REAL, IN
      res :: REAL

      alpha :: REAL

      alpha = ONE/minval(.exponent)

      if (cutoff<=ZERO) then; res = huge(ONE)
      else;                   res = sqrt(-alpha*log(cutoff/sum(abs(.contraction))))
      end

   end

   r2_max(cutoff) result (res) ::: pure
   ! Return the radius where all basis functions becomes smaller than "cutoff".
      self :: IN
      cutoff :: REAL, IN
      res :: REAL

      alpha :: REAL

      alpha = ONE/minval(.exponent)

      if (cutoff<=ZERO) then; res = huge(ONE)
      else;                   res = -alpha*log(cutoff/sum(abs(.contraction)))
      end

   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("l",.l)
      stdout.dump("l_chr",.l_chr)
      stdout.dump("is_spherical",.is_spherical)
      stdout.dump("n_comp",.n_comp)
      stdout.dump("n_sph",.n_sph)
      stdout.dump("n_bf",.n_bf)
      stdout.dump("first_gaussian",.first_gaussian)
      stdout.dump("last_gaussian",.last_gaussian)
      stdout.dump("n_cc",.n_cc)

      stdout.dmpp("exponent",.exponent)
      stdout.dmpp("contraction",.contraction)

   end

   dump(object_name,ptr) ::: get_from(OBJECT, TYPE?=>SHELL)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT, TYPE?=>SHELL)
   ! Dump pointer object data as text
   end

!  ======
!  Output
!  ======

   put
   ! Put the shell information to "stdout"

      table :: VEC{TABLE_COLUMN}@

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===================")
      stdout.text("Gaussian type shell")
      stdout.text("===================")
      stdout.flush
      stdout.show("Shell type                  =",.l_chr)
      stdout.show("L quatum no.                =",.l)
      stdout.show("is_spherical                =",.is_spherical)
      stdout.show("No. of cartesian components =",.n_comp)
      stdout.show("No. of spherical components =",.n_sph)
      stdout.show("Lexical starting index      =",.first_gaussian)
      stdout.show("Lexical end index           =",.last_gaussian)
      stdout.show("No. of contractions         =",.n_cc)
      stdout.flush

      if (.exponent.deallocated) return
      if (.contraction.deallocated) return

      ! Table headings
      table.create(2)
      table(2).set_heading("Contraction")
      table(2).set_subhead("coeff.")
      table(2).set_heading("Exponent")
      table(2).set_subhead("/au")

      ! Set table column data
      table(1).set_values(.contraction)
      table(2).set_values(.exponent)

      ! Make the table
      table.put

   end

end
